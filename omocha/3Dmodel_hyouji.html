<!DOCTYPE html>
<html lang="ja">
    <head prefix="og: http://ogp.me/ns# website: http://ogp.me/ns/website#">
        <meta charset="UTF-8">
        <!--文字コードは上のほうにないとすべておしまいになるらしい-->
        <meta name="description" content="ブラウザで3Dモデル表示してみたい。">                                                                 <!--ページ説明　入力すること！-->
        <title>JUN汁ｗおもちゃばこ。/おもちゃ/3Dモデル表示したい</title>                                                         <!--タイトル　入力すること！-->
        <!--OGPとかいうの-->
        <meta property="og:site_name" content="JUN汁ｗおもちゃばこ。/omocha/3Dmodel_hyouji">                                <!--タイトル　入力すること！-->
        <meta property="og:title" content="3Dモデル表示したい">                                                               <!--タイトル　入力すること！-->
        <meta property="og:type" content="article"> <!--websiteはトップページ、articleが記事だってさ-->
        <meta property="og:url" content="https://junjiruw.github.io/DEYUTI/omocha/3Dmodel_hyouji.html">                   <!--リンク　入力すること！-->
        <meta property="og:image" content="https://github.com/junjiruw/DEYUTI/blob/master/images/site/junjiruw_bako.png?raw=true">
        <meta name="twitter:card" content="summary"><!--なにを表示するか-->
        <meta name="twitter:site" content="@junjiruw"><!--フッターに表示されるらしい…どこ？-->
        <meta name="viewport" content="width=device-width,initial-scale=1"><!--スマホで見てる人向けに表示領域の設定-->
        <link rel="stylesheet" href="../css/style.css">
        
        <link rel="icon" href="../images/site/favicon32.png">
        <style>
            
            div#parent_div{
                text-align: center;
                margin: 10px;
                position: relative;/*子要素のabsoluteの原点をここにする*/
            }
            div#slider_div_div{
                display: flex;
                flex-wrap: wrap;
            }
            div.slider_div{
                border: 1px solid #FFF;
                font-size: 1.5vw;
                width: 33%;
                box-sizing: border-box;/*ボーダー含めて幅とするよ*/
            }
            canvas{
                border: 1px solid #FFF;
            }
            canvas#cnvs{
                /*表示大きさはThree.jsで設定*/
                position: absolute;
            }
            input{
                -webkit-appearance: auto;/*デフォルトデザインのボタン殺してたんだったぜ！*/
            }
            input.slider{
                width:15Svw;
            }
        </style>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-1MB5XLN4LW"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-1MB5XLN4LW');
        </script>
        <!-- Google tag (gtag.js) -->

        <!--Three.jsのインポート用。最新バージョンはここをチェック：https://www.npmjs.com/package/three?activeTab=versions-->
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
                }
            }
        </script>
        <!--Three.jsのインポート用 examples/jsm/は外部ファイルローダーがたっぷりいる-->

        <script src="../js/public.js"></script>

        <script type="module">
            import * as THREE from "three";//インポート。type="module"じゃないと使えないらしいっス！
            import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";//GLTF形式のロードに使うッス！
            // GLTF・GLB形式のモデルデータを読み込むための…アレさ！
            const loader = new GLTFLoader();
            
            onload = async function(){
                onload_functions();
                const cnvs = document.getElementById('cnvs');//IDを指定して変数にぶち込む
                const cnvs_3D = document.getElementById('cnvs_3D');//IDを指定して変数にぶち込む

                const renderer = new THREE.WebGLRenderer({//ここに表示、よろしく！
                    canvas: cnvs_3D
                });

                function Resize_cnvs(){
                    if (navigator.userAgent.match(/iPhone|Android.+Mobile/)) {//貴様！スマホで見ているな！？
                        cnvs.style.width=cnvs.parentElement.clientWidth+"px";
                        renderer.setSize(cnvs.parentElement.clientWidth,cnvs.parentElement.clientWidth);
                        document.querySelectorAll(".slider_div").forEach(function(e) {
                            e.style.fontSize = "3vw"; //もじでかくしとこ
                            e.style.width = "50%"; //枠でかくしとこ
                        });
                        document.querySelectorAll(".slider").forEach(function(e) {
                            e.style.width = "20vw"; //スライダでかくしとこ
                        });
                    }else{//PCかな…
                        cnvs.style.width=window.innerHeight*0.7+"px";
                        renderer.setSize(window.innerHeight*0.7, window.innerHeight*0.7);
                    }
                    cnvs.style.height=cnvs.clientWidth+"px";
                }
                Resize_cnvs();//キャンバスサイズ設定してねー☆
                window.addEventListener('resize', Resize_cnvs);//キャンバスサイズ変更されたらもっかいね
                
                const scene = new THREE.Scene();                

                const 操作画像_1 = new Image();
                const 操作画像_2 = new Image();
                const 操作画像_3 = new Image();
                const 操作画像_4 = new Image();
                操作画像_1.src="../images/omocha/3Dmodel_hyouji/sousaaikon_1.png";
                操作画像_2.src="../images/omocha/3Dmodel_hyouji/sousaaikon_2.png";
                操作画像_3.src="../images/omocha/3Dmodel_hyouji/sousaaikon_3.png";
                操作画像_4.src="../images/omocha/3Dmodel_hyouji/sousaaikon_4.png";

                const 時間 = new THREE.Clock();
                let 倍速=1;

                let クリック中 = false;
                let タップ開始=0;
                let 開始x=0, 開始y=0;
                let 開始指距離=0;
                let ドラッグ移動x = 0, ドラッグ移動y = 0, ホイール移動=0;

                cnvs.addEventListener("mousedown", (e) => {
                    クリック中 = true;
                    開始x = e.clientX;
                    開始y = e.clientY;
                });

                cnvs.addEventListener("touchstart", (e) => {
                    クリック中 = true;
                    
                    if(e.touches.length == 2){//指が二本ある～～～
                        e.preventDefault(); // ブラウザのデフォルトのズーム動作を無効化する
                        開始指距離=Math.sqrt((e.touches[0].clientX-e.touches[1].clientX)**2+(e.touches[0].clientY-e.touches[1].clientY)**2);
                    }else if(e.touches.length == 1){
                        //拡大操作したときに暴発するのでちょっとガードする
                        タップ開始=0;
                        //開始x = e.touches[0].clientX;
                        //開始y = e.touches[0].clientY;
                    }
                    
                });

                document.addEventListener("mouseup", () => {
                    クリック中= false;
                    ドラッグ移動x = 0;
                    ドラッグ移動y = 0;
                });
                document.addEventListener("mouseleave", () => {
                    クリック中= false;
                    ドラッグ移動x = 0;
                    ドラッグ移動y = 0;
                });

                document.addEventListener("touchend", () => {
                    クリック中= false; 
                    タップ開始=0;
                    ドラッグ移動x = 0;
                    ドラッグ移動y = 0;
                }, { passive: false });//デフォルト操作を妨害するときのオプション？

                

                document.addEventListener("mousemove", (e) => {
                    if(クリック中){
                        ドラッグ移動x=e.clientX-開始x;
                        ドラッグ移動y=-e.clientY+開始y;

                        開始x = e.clientX;
                        開始y = e.clientY;
                    }
                });

                document.addEventListener("touchmove", (e) => {
                    if(クリック中){
                        if(e.touches.length == 2){//指が二本ある～～～
                            e.preventDefault(); // ブラウザのデフォルトのズーム動作を無効化する

                            ホイール移動=-1*(Math.sqrt((e.touches[0].clientX-e.touches[1].clientX)**2+(e.touches[0].clientY-e.touches[1].clientY)**2)-開始指距離);
                            開始指距離=Math.sqrt((e.touches[0].clientX-e.touches[1].clientX)**2+(e.touches[0].clientY-e.touches[1].clientY)**2);
                        }else if(e.touches.length == 1){
                            e.preventDefault(); // ブラウザのデフォルトのズーム動作を無効化する
                            //console.log(開始x);
                            
                            //拡大操作したときに暴発するのでちょっとガードする
                            タップ開始++;
                            if(タップ開始==3){
                                開始x = e.touches[0].clientX;
                                開始y = e.touches[0].clientY;
                            }else if(タップ開始>3){
                                ドラッグ移動x=(e.touches[0].clientX-開始x)*2;
                                ドラッグ移動y=(-e.touches[0].clientY+開始y)*2;

                                開始x = e.touches[0].clientX;
                                開始y = e.touches[0].clientY;
                            }
                            
                        }
                    }
                    
                }, { passive: false });//デフォルト操作を妨害するときのオプション？

                cnvs.addEventListener("wheel", (e) => {
                    e.preventDefault(); // ブラウザのデフォルトのスクロール動作を無効化する
                    ホイール移動=e.deltaY;//-100 or 0 or 100
                }, { passive: false });//デフォルト操作を妨害するときのオプション？




                //カメラ
                const camera = new THREE.PerspectiveCamera(90, 1);// 画角, アスペクト比
                camera.position.set(0, 3, -5);
                camera.lookAt(new THREE.Vector3(0, 3, 0));

                /*
                頂点シェーダ。
                position 座標データ。vec3
                uv UV座標。vec2。 

                ↓記述はMainより前に。
                uniform シェーダ外から変数を持ってくる。マテリアルのとこで設定
                attribute こっちは頂点ごとに異なる情報を持てる。頂点シェーダでのみ使う
                varying って型の前に書くとフラグメントシェーダに投げられる。

                gl_Position　←こいつに頂点座標をぶんなげるとよい(vec4)
                
                ----
                ここからは頂点シェーダーのアニメーション対応とかの話
                THREE.ShaderChunk　どうやらシェーダーの一部を読み込んでくれるようだ
                ・common 共通部分だろう。たぶん
                ・skinning_vertex　名前からすると頂点のボーンからの影響とか計算をしてくれるんだろう
                ・その他　知らん。エラーが出ないようにぶちこみまくった
                
                ShaderChunkのソースコードはココから探せばあるとおもう。解体するときは中身をコピペして使ってるよ
                github: https://github.com/mrdoob/three.js/tree/master/src/renderers/shaders/ShaderChunk

                > Three.jsでBoneアニメーションをShaderMaterialで動かす
                > https://qiita.com/ykido/items/55c7f17fb32216056705 ←参考資料。天才

                ---- 
                */
               
                const vertexShader = `
                varying vec4 model_pos;
                uniform float time;
                uniform float length_value;
                uniform float amp;
                uniform float omega;
                uniform float wave_num;

                #include <common>              
                #include <skinning_pars_vertex>

                void main() {
                    #include <begin_vertex>
                    #include <skinbase_vertex>
                    #include <skinning_vertex>                    

                    vec4 mvPosition = vec4( transformed, 1.0 );
                    mvPosition.x=mvPosition.x*(sin(mvPosition.y*wave_num+time*omega)*amp+1.0);
                    mvPosition.y*=length_value;
                    mvPosition = modelViewMatrix * mvPosition;

                    gl_Position = projectionMatrix * mvPosition;
                    
                    
                    model_pos = mvPosition ;
                }`;

                /*
                フラグメントシェーダ。

                ↓記述はMainより前に。
                uniform シェーダ外から変数を持ってくる。マテリアルのとこで設定
                varying って型の前に書くとフラグメントシェーダに投げられる。

                gl_FragColor　←こいつに色をぶんなげるとよい(vec4)
                */
                const fragmentShader = `
                varying vec4 model_pos;
                uniform float time;
                uniform vec3 model_color;
                void main() {
                    vec3 color = 0.3*vec3(model_pos.x*0.5+0.5, model_pos.y*0.5+0.5 ,model_pos.z*0.5+0.5)+model_color;
                    gl_FragColor = vec4(color, 1.0);
                   
                }`;
                let customMaterial_s=[];//シェーダー適用されたマテリアルの配列

                
                /*
                頂点シェーダ。こっちは影をつくるためにcustomDepthMaterialにぶちこむ

                THREE.ShaderLib['depth']　ってやるとシェーダーがとれるので、フラグメントシェーダーのほうはそのまま使用。
                頂点シェーダーは中身を奪ってくる
                github: https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderLib/depth.glsl.js

                あ！色々消してたら頂点いじってたシェーダーとほぼ同じになちゃった
                本質はvHighPrecisionZW;って変数なのか？

                > three.jsのcustomDepthMaterialを使ってみる  
                > https://qiita.com/aa_debdeb/items/2a3527b1527380e4af85 ←参考資料。天才

                > 【React Three Fiber】Shaderを使用してMaterialを変更する  
                > https://qiita.com/nemutas/items/434806b73455634a5d27 ←参考資料。天才
                ----
                */
               /*
                const depth_vertexShader = `
                uniform float time;

                #include <common>
                #include <skinning_pars_vertex>

                varying vec2 vHighPrecisionZW;
                void main() {
                    #include <begin_vertex>
                    #include <skinbase_vertex>
                    #include <skinning_vertex>  
                    
                    vec4 mvPosition = vec4( transformed, 1.0 );
                    mvPosition = modelViewMatrix * mvPosition;

                    gl_Position = projectionMatrix * mvPosition;
                        
                    vHighPrecisionZW = gl_Position.zw;
                }`;
                */
                
                //どうせ似たようなコードになったんなら、流用しちゃおうぜ
                //.onBeforeCompile っての使ったほうがお上品なのかな…まあイイかァ！
                let depth_vertexShader=vertexShader;
                depth_vertexShader="varying vec2 vHighPrecisionZW;"+depth_vertexShader.slice(0, -1)+"vHighPrecisionZW = gl_Position.zw;}";
                
                //フラグメントはオリジナルをそのまま。
                const depth_fragmentShader=THREE.ShaderLib['depth'].fragmentShader;

                let custom_depth_Material_s=[];//depth_シェーダー適用されたマテリアルの配列

                // しゅうくんだ！
                const glb = await loader.loadAsync('../3D/omocha/3Dmodel_hyouji/LOW_SYUUKUN.glb');
                const SYUUKUN = glb.scene;
                SYUUKUN.position.set(0, 0, 0);                

                SYUUKUN.traverse((SYUUKUN)=>{
                    if (SYUUKUN.isMesh) {
                        SYUUKUN.castShadow = true;//影を落とす

                        // カスタムシェーダーマテリアルを作成
                        let customMaterial = new THREE.ShaderMaterial({
                            uniforms: {// ユニフォーム変数と初期値くん
                                model_color:{value:SYUUKUN.material.color},
                                time: { value: 0.0 } ,
                                length_value: { value: 1.0 } ,
                                amp: { value: 0.0 } ,
                                omega: { value: 1.0 } ,
                                wave_num: { value: 1.0 } ,
                            },
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                        });
                        customMaterial_s.push(customMaterial);//マテリアルの格納配列に入れておくね
                        SYUUKUN.material = customMaterial;
                        
                        

                        // カスタム深度シェーダーマテリアルを作成
                        let custom_depth_Material = new THREE.ShaderMaterial({
                            uniforms: {// ユニフォーム変数と初期値くん
                                time: { value: 0.0 } ,
                                length_value: { value: 1.0 } ,
                                amp: { value: 0.0 } ,
                                omega: { value: 1.0 } ,
                                wave_num: { value: 1.0 } ,
                            },
                            vertexShader: depth_vertexShader,
                            fragmentShader: depth_fragmentShader,
                            
                            defines: {
                                //深度情報のパッキングをする　←なんて…？
                                DEPTH_PACKING: THREE.RGBADepthPacking
                            }

                        });
                        custom_depth_Material_s.push(custom_depth_Material);//マテリアルの格納配列に入れておくね
                        SYUUKUN.customDepthMaterial = custom_depth_Material;
                    }
                });
                scene.add(SYUUKUN);      
                console.log("マテリアル数:"+customMaterial_s.length);  
                
                const syuukun_anim= glb.animations;//アニメーション
                const syuukun_mixer = new THREE.AnimationMixer(SYUUKUN);//アニメーションミキサー
                var アクション={};
                for (let i = 0; i < syuukun_anim.length; i++) {        
                    アクション[i] = syuukun_mixer.clipAction(syuukun_anim[i]) ;
                    アクション[i].setLoop(THREE.LoopRepeat);//無限ルーピ        
                    console.log("アクション"+i+":"+syuukun_anim[i].name);
                }
                const speed = document.getElementById('speed');
                const speed値 = document.getElementById('speed値');
                speed.addEventListener('input', function() {
                    倍速 = (this.value)**2;
                    speed値.textContent = 倍速.toFixed(2);
                });
                const length = document.getElementById('length');
                const length値 = document.getElementById('length値');
                length.addEventListener('input', function() {
                    let 長さ = parseFloat(this.value);
                    length値.textContent = 長さ.toFixed(1);
                    customMaterial_s.forEach(materialくん=>{
                        materialくん.uniforms.length_value.value=長さ;
                    });
                    custom_depth_Material_s.forEach(materialくん=>{
                        materialくん.uniforms.length_value.value=長さ;
                    });
                });
                const amp = document.getElementById('amp');
                const amp値 = document.getElementById('amp値');
                amp.addEventListener('input', function() {
                    let 振幅 = parseFloat(this.value);
                    amp値.textContent = 振幅.toFixed(2);
                    customMaterial_s.forEach(materialくん=>{
                        materialくん.uniforms.amp.value=振幅;
                    });
                    custom_depth_Material_s.forEach(materialくん=>{
                        materialくん.uniforms.amp.value=振幅;
                    });
                });
                const omega = document.getElementById('omega');
                const omega値 = document.getElementById('omega値');
                omega.addEventListener('input', function() {
                    let おめが = parseFloat(this.value);
                    omega値.textContent = おめが.toFixed(1);
                    customMaterial_s.forEach(materialくん=>{
                        materialくん.uniforms.omega.value=おめが;
                    });
                    custom_depth_Material_s.forEach(materialくん=>{
                        materialくん.uniforms.omega.value=おめが;
                    });
                });
                const wave_num = document.getElementById('wave_num');
                const wave_num値 = document.getElementById('wave_num値');
                wave_num.addEventListener('input', function() {
                    let 波の数 = this.value;
                    wave_num値.textContent = 波の数;
                    customMaterial_s.forEach(materialくん=>{
                        materialくん.uniforms.wave_num.value=波の数;
                    });
                    custom_depth_Material_s.forEach(materialくん=>{
                        materialくん.uniforms.wave_num.value=波の数;
                    });
                });
                
                
                const チェック1 = document.getElementById('check_1');
                const チェック2 = document.getElementById('check_2');
                const チェック3 = document.getElementById('check_3');

                アクション[0].play();//デフォでうごかしとこ
                チェック1.addEventListener('change', function() {
                    if (this.checked) {
                        アクション[0].play();
                    } else {
                        アクション[0].stop();
                    }
                });

                チェック2.addEventListener('change', function() {
                    if (this.checked) {
                        アクション[1].play();
                    } else {
                        アクション[1].stop();
                    }
                });

                チェック3.addEventListener('change', function() {
                    if (this.checked) {
                        アクション[2].play();
                    } else {
                        アクション[2].stop();
                    }
                });
                
                const cube = new THREE.Mesh( new THREE.BoxGeometry( 10, 1, 10 ),new THREE.MeshLambertMaterial({color: 0x6699FF}));
                cube.position.set(0, -0.5, 0);
                cube.receiveShadow = true;//影を受ける
                scene.add( cube );

                const cube2 = new THREE.Mesh( new THREE.BoxGeometry( 10, 8, 1 ),new THREE.MeshLambertMaterial({color: 0x66FF99}));
                cube2.position.set(0, 3, 5.5);
                cube2.receiveShadow = true;//影を受ける
                scene.add( cube2 );

                const cube3 = new THREE.Mesh( new THREE.BoxGeometry( 1, 8, 7 ),new THREE.MeshLambertMaterial({color: 0xFF6699}));
                cube3.position.set(-5.5, 3, 2.5);
                cube3.receiveShadow = true;//影を受ける
                scene.add( cube3 );

                //環境光    
                const light = new THREE.AmbientLight(0xFFFFFF, 0.1);
                scene.add(light);

                // 平行光源
                const directionalLight = new THREE.DirectionalLight(0xFFFFFF,1);
                directionalLight.position.set(4, 4, -5);//この位置から (この位置はめりこまないように)
                directionalLight.target.position.set(0, 2, 0);//この位置へ光を
                scene.add(directionalLight);
                
                directionalLight.castShadow = true;//影を有効に。
                renderer.shadowMap.enabled = true;//影を有効に。
                //影カメラの範囲にある影が作成される。                
                directionalLight.shadow.camera.right = 5;
                directionalLight.shadow.camera.left = -5;
                directionalLight.shadow.camera.top = 12;
                directionalLight.shadow.camera.bottom = -1;
                directionalLight.shadow.mapSize.set(1024, 1024);//影の解像度
                //影カメラの範囲がこれでわかるぴゃお
                /*
                var directionalLightShadowHelper = new THREE.CameraHelper( directionalLight.shadow.camera);
                scene.add( directionalLightShadowHelper);
                */


                var ctx = cnvs.getContext("2d");
                ctx.font = "30px 'ＭＳ Ｐゴシック'";//フォント設定。左のフォントがないと右のフォントを適用するらしい。
                ctx.fillStyle="#FFFFFF";
                

                Main();//ループ関数
                function Main() {
                    ctx.clearRect(0, 0, cnvs.width, cnvs.height);//更新！
                    
                    ///SYUUKUN.rotation.y += 0.01;

                    //まずは上下左右ぐりぐり
                    ドラッグ移動x*=0.01;
                    ドラッグ移動y*=-0.01;

                    let now_x=camera.position.x;
                    let now_y=camera.position.y-3;
                    let now_z=camera.position.z;

                    camera.position.x = 1 *now_x*Math.cos(ドラッグ移動x )- 1*now_z*Math.sin(ドラッグ移動x );
                    camera.position.z = 1 *now_x*Math.sin(ドラッグ移動x )+ 1*now_z*Math.cos(ドラッグ移動x );
                    
                    now_x=camera.position.x;
                    now_y=camera.position.y-3;
                    now_z=camera.position.z;

                    let xz_kyori=Math.sqrt(now_x*now_x+now_z*now_z);

                    let next_x=-1 *now_x/xz_kyori*now_y*Math.sin(ドラッグ移動y )+ 1*now_x*Math.cos(ドラッグ移動y );
                    let next_y= 1 *now_y*Math.cos(ドラッグ移動y )+ 1*xz_kyori*Math.sin(ドラッグ移動y )+3;
                    let next_z=-1 *now_z/xz_kyori*now_y*Math.sin(ドラッグ移動y )+ 1*now_z*Math.cos(ドラッグ移動y );
                    //console.log("k"+xz_kyori);
                    if(now_x*next_x<0 && now_z*next_z<0){
                        //真上、真下で操作が逝くので制限。
                        //更新しないでおいて
                    }else{
                        camera.position.x = next_x;
                        camera.position.y = next_y;
                        camera.position.z = next_z;
                        
                    }
                    
                    //拡大縮小
                    let camera_length=Math.sqrt(camera.position.x*camera.position.x +(camera.position.y-3)*(camera.position.y-3) +camera.position.z*camera.position.z)
                    if(camera_length<5){//近いなら小さく動く
                        camera.position.x *= (camera_length+(ホイール移動)/500)/camera_length;
                        camera.position.y = (camera.position.y-3)*(camera_length+(ホイール移動)/500)/camera_length+3;
                        camera.position.z *= (camera_length+(ホイール移動)/500)/camera_length;
                    }else{//遠いなら大きく動く                 
                        camera.position.x *= (camera_length+(ホイール移動)/100)/camera_length;
                        camera.position.y =(camera.position.y-3)*(camera_length+(ホイール移動)/100)/camera_length+3;
                        camera.position.z *= (camera_length+(ホイール移動)/100)/camera_length;
                    }
                    ホイール移動=0;
                    
                    
                    ctx.fillText("操作方法は…上のコレの通りだ！", 15, 130);
                    ctx.drawImage(操作画像_1, 0, 0);
                    ctx.drawImage(操作画像_2, 130, 0);
                    ctx.drawImage(操作画像_3, 300, 0);
                    ctx.drawImage(操作画像_4, 430, 0);

                    camera.lookAt(new THREE.Vector3(0, 3, 0));
                    ドラッグ移動x = 0;
                    ドラッグ移動y = 0;

                    customMaterial_s.forEach(materialくん=>{
                        materialくん.uniforms.time.value += 0.1*倍速;
                    });
                    custom_depth_Material_s.forEach(materialくん=>{
                        materialくん.uniforms.time.value += 0.1*倍速;
                    });
                    renderer.shadowMap.needsUpdate= true;//影を有効に。

                    syuukun_mixer.update(時間.getDelta()*倍速);//ちょっと動けー！
                    renderer.render(scene, camera); // レンダリング
                    requestAnimationFrame(Main);// 次フレームも実行よろしく！
                }
            }
        </script>
    </head>
    <body>
        <div id="top"></div>
        <header id="header">
            <button onclick="html_link_btn()" id="html_link_btn"></button>
            <nav id="html_link_nav">
                <ul id="html_link_ul"></ul>
            </nav>
            <a href="../index.html">
                <img id="go_home" src="../images/site/omotyabako_deka.png" alt="トップページへ" height="1px"><!--ここで高さを入れておかないと、クソでかい画像が一瞬読み込まれてボタンの大きさが暴走する-->
            </a>
            <h1 id="title_h1">
                JUN汁ｗおもちゃばこ。
            </h1>
        </header>
        <div id="mannaka">
            <div id="parent_div">
                <canvas id="cnvs" height="1000px" width="1000px"><!--実大きさはThree.jsで決めてる-->
                </canvas>
                <canvas id="cnvs_3D"><!--実大きさはThree.jsで決めてる-->
                </canvas>
            </div>

            <input type="checkbox" id="check_1" checked> <label for="check_1">ポカポカ</label>
            <input type="checkbox" id="check_2" > <label for="check_2">うずうず待機</label>
            <input type="checkbox" id="check_3" > <label for="check_3">歩き</label>
            <div id="slider_div_div">
                <div class="slider_div">
                    <input type="range" class="slider" min="0" max="10" value="1" id="speed" step="0.1"> 速度 <span id="speed値">1.00</span> 倍
                </div>
                <div class="slider_div">
                    <input type="range" class="slider" min="0" max="10" value="1" id="length" step="0.1"> 身長 <span id="length値">1.0</span> 倍
                </div>
                <div class="slider_div">
                    <input type="range" class="slider" min="0" max="5" value="0" id="amp" step="0.05"> 揺れ幅 <span id="amp値">0.00</span> 倍
                </div>
                <div class="slider_div">
                    <input type="range" class="slider" min="0" max="10" value="1" id="omega" step="0.1"> 周波数 <span id="omega値">1.0</span> 倍
                </div>
                <div class="slider_div">
                    <input type="range" class="slider" min="0" max="10" value="1" id="wave_num" step="0.1"> 波の数 <span id="wave_num値">1</span> 個
                </div>
            </div>
            
            <footer>
                <ul id="footul">
                    <li id="foot_tweet_li">
                        <a href=""  target="_blank" rel="noopener noreferrer" id="foot_tweet_a"><!--onload_functions()でhrefを書き込んでるで！-->
                            <img src="../images/site/twitterbutton.gif" alt="ツイートボタン" id="tweet_img">
                        </a>
                    </li>
                    <li>
                        <a href="#top" id="totop"> 
                            ページ上部に移動
                        </a>
                    </li>
                </ul>
            </footer>
        </div>
    </body>
</html>
