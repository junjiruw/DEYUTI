<!DOCTYPE html>
<html lang="ja">
    <head prefix="og: http://ogp.me/ns# website: http://ogp.me/ns/website#">
        <meta charset="UTF-8">
        <!--文字コードは上のほうにないとすべておしまいになるらしい-->
        <meta name="description" content="でゆっち用お絵描きソフトウェア #deyukaki">                                                                 <!--ページ説明　入力すること！-->
        <title>JUN汁ｗおもちゃばこ。/おもちゃ/でゆ描き</title>                                                         <!--タイトル　入力すること！-->
        <!--OGPとかいうの-->
        <meta property="og:site_name" content="JUN汁ｗおもちゃばこ。/omocha/deyukaki">                                <!--タイトル　入力すること！-->
        <meta property="og:title" content="でゆ描き">                                                               <!--タイトル　入力すること！-->
        <meta property="og:type" content="article"> <!--websiteはトップページ、articleが記事だってさ-->
        <meta property="og:url" content="https://junjiruw.github.io/DEYUTI/omocha/deyukaki.html">                   <!--リンク　入力すること！-->
        <meta property="og:image" content="https://github.com/junjiruw/DEYUTI/blob/master/images/site/junjiruw_bako.png?raw=true">
        <meta name="twitter:card" content="summary"><!--なにを表示するか-->
        <meta name="twitter:site" content="@junjiruw"><!--フッターに表示されるらしい…どこ？-->
        <meta name="viewport" content="width=device-width,initial-scale=1"><!--スマホで見てる人向けに表示領域の設定-->
        <link rel="stylesheet" href="../css/style.css">
        
        <link rel="icon" href="../images/site/favicon32.png">
        <style>
            header{
                position: static;/*fixedじゃなくするとpublic.js内の処理をスキップするよん*/
                
            }
            #html_link_nav{
                z-index: 20; /* 高い値を指定して上に表示 */
            }
            div#mannaka{
                width: 100%;
                margin: 0.5em 0px 0.5em 0px;
                border: 2px solid #ffffff;
                color: #ffffff;   
                font-size: 16px;    
            }
            #三分割くん {
                position: relative;
                height: 100%; /* 親要素の高さに合わせる */
            }

            #真ん中分割 {
                width: 100%;
                height: 100%; /* 親要素の高さに合わせる */
                text-align: center;
                overflow: scroll;
                cursor: url("../images/omocha/deyukaki/pen16.png"),default; /* カスタムカーソル画像 */
            }
            /* スクロールバーの幅を指定 */
            #真ん中分割::-webkit-scrollbar {
                width: 1em; /* 垂直スクロールバーの幅 */
                height: 1em; /* 水平スクロールバーの高さ */
            }
            #真ん中分割::-webkit-scrollbar-track {
                background: #757575;
            }
            #真ん中分割::-webkit-scrollbar-thumb {
                background: #dadada;
                border-radius: 6px;
            }
            #真ん中分割::-webkit-scrollbar-thumb:hover {
                background: #b4b4b4;
            }
            
            #スクロールサイズ調整 {
                position: relative;
                z-index: 1; /* 邪魔なので一番奥に。*/
            }

            .描画用 {
                position: absolute;
                transform-origin: top left; /* 拡大縮小の基準点を左上に設定 */
                top:0;
                left:0;
                background-clip: padding-box;/*背景色がborderまでいかないようになる*/
                image-rendering: pixelated;/* 画像の拡大縮小時にピクセルを強調する */
                
            }


            #移動UI{
                display:none;
                position:absolute;
                transform-origin: top left; /* 拡大縮小の基準点を左上に設定 */
                top:0;
                left:0;
                z-index:5; /* ちょい高い値を指定して上に表示 */
            }

            #移動UI_ボタン群 {
                position: absolute;
                top: -2.5em; /* 移動UI_大きさの上に配置（必要に応じて調整） */
                left: 50%;
                transform: translateX(-50%);
                z-index: 15; /* ハンドルより上に */
                display: flex;
                gap: 0.5em;/*ボタンの隙間決定*/
                
            }

            #移動UI_大きさ{
                position: relative;
                width: 100%;
                height: 100%;
                background:rgba(255,0,0,0.2);
                transform: (50%,50%);
                transform-origin: center; /* 中心を基準にスケーリング */
                top: 0px;
                left: 0px;
            }
            #移動UI_大きさ .resize-handle {
                position: absolute;
                width: 2em;
                height: 2em;
                transform-origin: center; /* 中心を基準にスケーリング */
                background: #fff;
                border: 2px solid #333;
                border-radius: 50%;
                z-index: 10;
                pointer-events: auto;
                user-select: none; /* テキスト選択を無効化 */
            }
            #移動UI_大きさ_左上 { left: -1em; top: -1em; cursor: nwse-resize; }
            #移動UI_大きさ_右上 { right: -1em; top: -1em; cursor: nesw-resize; }
            #移動UI_大きさ_左下 { left: -1em; bottom: -1em; cursor: nesw-resize; }
            #移動UI_大きさ_右下 { right: -1em; bottom: -1em; cursor: nwse-resize; }

            .浮かせる {
                position: absolute;
                top: 0;
                background: #555;
                color: #fff;
                
                display: flex;
                justify-content: center;/* 2分割くんの中身を真ん中によせる */
            }

            #左分割 {
                left: 0;
                z-index: 10; /* 高い値を指定して上に表示 */
                user-select: none; /* テキスト選択を無効化 */
            }

            #右分割 {
                right: 1em;
                z-index: 10; /* 高い値を指定して上に表示 */
            }

            #左最小化領域 {
                display: flex; /* 子要素を横並びにする */
            }
            .color_行{
                display: flex; /* 子要素を横並びにする */
                border: 2px solid #aaa;
                padding: 2px;
                margin: 2px;
            }
            .縦並べ{
                display: flex;
                flex-direction: column; /* 縦に並べる */
                align-items: center; /* 中央揃え */
            }
            .img_layer{
                image-rendering: pixelated; /* ピクセルを強調してぼやけを防ぐ */
                width: 1.5em;
                height: 1.5em;

            }
            .radio_div{
                display: flex;
                flex-direction: column; /* ラジオボタンとラベルを縦に並べる */
                align-items: center; /* 中央揃え */
            }

            .radio{
                display: inline-block;
                width: 1em;
                height: 1em;
                border: 2px solid #aaa;
                background-color: #fff;
                border-radius: 50%;
            }
            .radio:checked{
                background-color: rgb(80, 160, 255);
            }
            .色箱{
                position: relative;
                margin: 0.2em;
            }
            .色箱_input {
                position: relative;
                width: 1.5em;
                height: 1.5em;
            }
            .色箱_cover{
                position: absolute;
                /*pointer-events: none; /* クリックイベントを無効化 してたのを無効化！！！！！*/
                cursor: pointer;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 255, 255 ); 
                border: 2px solid #c5c5c5;
            }
            .中身のない色箱表示のための親{
                position: relative;
                width: 1.5em;
                height: 1.5em;
            }
            .透明色だよ{
                border-radius: 50%;
                background: 
                    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%),
                    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%);
                background-size: 0.5em 0.5em;
                background-position: 0 0, 0.25em 0.25em;

            }
            #太さ{
                width: 3em;
                height: 1em;
            }
            .太さボタン{
                width: 1.5em;
                height: 1.5em;
                border-radius: 50%;
            }
            #slider太さ{
                width: 10em;
            }
            #ツール選択 input{
                display: none; /* デフォルトのラジオボタンを非表示 */
            }
            .ペンボタン {
                display: inline-block;
                width: 3em; /* ボタンの幅 */
                height: 3em; /* ボタンの高さ */
                background-size: cover; /* 画像をボタン全体にフィットさせる */
                background-repeat: no-repeat; /* 画像を繰り返さない */
                cursor: pointer; /* マウスカーソルをポインターに変更 */
                image-rendering: pixelated; /* ピクセルを強調してぼやけを防ぐ */
                filter: brightness(40%) saturate(20%); /* 色味調整 */
                border: 2px solid #aaa; /* ボタンの枠線 */
            }
            input[type="radio"]:checked + .ペンボタン {
                background-color: #007bff; /* 選択時の背景色（青） */
                filter: brightness(100%) saturate(100%); /* 色味調整 */
            }

            #ペン_ボタン {
                background-image: url("../images/omocha/deyukaki/pen16.png"); 
            }

            #バケツ_ボタン {
                background-image: url("../images/omocha/deyukaki/baketu16.png"); 
            }

            #スポイト_ボタン {
                background-image: url("../images/omocha/deyukaki/supoito16.png");
            }

            #移動_ボタン {
                background-image: url("../images/omocha/deyukaki/move16.png");
            }

            #スワップ_ボタン {
                background-image: url("../images/omocha/deyukaki/swap16.png");
                filter: brightness(80%) saturate(100%); /* 色味調整 */
            }

            #パレット_ボタン {
                background-image: url("../images/omocha/deyukaki/paretto16.png");
                filter: brightness(80%) saturate(100%); /* 色味調整 */
            }
            .lockボタン {
                background-image: url("../images/omocha/deyukaki/lock16.png"); 
                
                width: 2em; /* ボタンの幅 */
                height: 2em; /* ボタンの高さ */
            }
            input[type="checkbox"]:checked {
                filter: brightness(1.5) saturate(2);
                background-color: #007bff;
            }


            .保存系ボタン{
                margin: 0.1em;
                cursor: pointer;
            }
            .保存系ボタン:hover {
                background-color: #ccc;
            }
            .保存系ボタン:active {
                background-color: #aaa;
            }
            #マウス追従{
                display: none; /* デフォルトで非表示 */
                position: absolute;
                background-color: rgb(174, 238, 46);
                border-radius: 50%;
                border: #3b3b3b 2px solid;
                box-shadow: inset 0 0 0 1px white;
                width: 2em;
                height: 2em;
                pointer-events: none; /* マウスイベントを無効化 */
                z-index: 5; /* canvasよりは、高い値を指定して上に表示 */
            }

            #カラーピッカー{
                position : absolute;
                top: 0;
                left: 0;
                width: 30%;
                height: 50%;
                background-color: rgba(0, 0, 0, 0.5); /* 半透明の黒 */
                border: 2px solid #ffffff;
                z-index: 100;/*とにかく上へ*/
                display : none;

                flex-direction: column; /*縦に*/
                align-items: center; /*左右中央に*/
                justify-content: center;/*上下中央に*/
            }

            #カラピカ上段{
                position: relative;
                display: flex;
                width: 95%;
                height: 80%;
            }

            #今の色{
                display : flex;
                flex-direction: column; /*縦に*/
                align-items: center; /*左右中央に*/
                justify-content: space-evenly;/*余白をいい感じにする。*/
                width: 15%;
                height: 100%;
            }

            #今の色表示{
                width: 80%;
                aspect-ratio: 1 / 1; /* 幅 = 高さ */
                border: 2px solid #ffffff;
            }

            #色参照スポイト{
                width: 60%;
                aspect-ratio: 1 / 1; /* 幅 = 高さ */
                border: 2px solid #ffffff;
                background-image: url("../images/omocha/deyukaki/supoito16.png");
                
                background-size: cover; /* 画像をボタン全体にフィットさせる */
                background-repeat: no-repeat; /* 画像を繰り返さない */
                cursor: pointer; /* マウスカーソルをポインターに変更 */
                image-rendering: pixelated; /* ピクセルを強調してぼやけを防ぐ */
            }

            .色参照スポイト_clicked{
                background-color: #007bff !important;
            }

            .色選択ボタン{
                width: 3em;
                padding: 0px;
                background-color: rgb(255, 255, 255);
            }

            .色選択ボタン:hover {
                filter: brightness(0.8);
            }

            .色選択ボタン:active {
                filter: brightness(0.6);
            }

            .採用ボタン{
                background-color: rgb(255, 202, 202);
            }

            .破棄ボタン{
                background-color: rgb(200, 235, 255);
            }

            .その他ボタン{
                background-color: rgb(200, 255, 200);
            }


            #彩度選択div{
                position:relative;
                height: 70%;
                width: 95%;
                margin : 0.3em
            }

            #彩度選択{
                height: 100%;
                width: 100%;
                border: #FFF 2px solid;
            }

            #色相選択div{
                position:relative;
                height: 5%;
                width: 85%;
                margin: 0.3em;

            }

            #色相選択{
                height: 100%;
                width: 100%;
                border: #FFF 3px solid;
            }

            .色選択ガイド{
                position : absolute;
                top: 0;
                left: 0;
                border-radius: 50%;
                border: 3px solid #ffffff;
                
                aspect-ratio: 1 / 1; /* 幅 = 高さ */
                pointer-events: none; /* マウスイベントを無効化 */
            }

            #今の彩度{
                height: 5%;
                transform: translateX(-50%) translateY(-50%);
            }

            #今の色相{
                height: 100%;
                transform: translateX(-50%);
            }

            
            #スワップメニュー{
                position : absolute;
                top: 0;
                left: 0;
                width: 20em;
                height: 30%;
                background-color: rgba(0, 0, 0, 0.7); /* 半透明の黒 */
                border: 2px solid #ffffff;
                z-index: 90;/*それなりに上へ*/
                display : none;

                flex-direction: column; /*縦に*/
                align-items: center; /*左右中央に*/
                justify-content: center;/*上下中央に*/
            }
            #スワメニュ上段{
                width: 15em;
                display : flex;
                align-items: center; /*左右中央に*/
                justify-content: center;/*上下中央に*/
                text-align: center;
                margin: 1em;
            }
            #スワメニュ上段 div{
                flex: 1; /* 幅を均等に */
            }
            #スワメニュ下段{
                display : flex;
                justify-content: space-evenly;
                width: 50%;
            }


            #パレットメニュー{
                position : absolute;
                top: 0;
                left: 0;
                width: 20em;
                height: 20em;
                background-color: rgba(0, 0, 0, 0.7); /* 半透明の黒 */
                border: 2px solid #ffffff;
                z-index: 90;/*それなりに上へ*/
                display : none;

                flex-direction: column; /*縦に*/
                align-items: center; /*左右中央に*/
                justify-content: center;/*上下中央に*/
            }

            .パレットエリア_上下{
                display: flex;
                flex-direction: row; /* 横並び（左右）にする */
                justify-content: center;   /* 横方向中央寄せ */
                width: 100%;
                margin: 0.5em;
            }

            .パレットエリア{
                padding: 0.2em;
            }

            .パレットエリア_段{
                position: relative;
                display: flex;
                padding: 0.1em;
                
                justify-content: center;   /* 横方向中央寄せ */
            }

            .中身のない色箱表示のための親{
                width: 2em;
                height: 2em;
                margin: 0.2em;
            }


            /* 横幅が40em未満の場合 */
            @media (max-width: 40em) {
                #右分割 {
                    bottom: 1em; /* 下に配置 */
                    top: auto; /* 上の位置をリセット */
                }
                .radio{
                    width: 2em;
                    height: 2em;
                }
                .色箱_input {
                    position: relative;
                    width: 2.5em;
                    height: 2.5em;
                }
                #太さ{
                width: 3em;
                height: 1.5em;
                }
                #マウス追従{
                    width: 5em;
                    height: 5em;
                }
                #カラーピッカー{
                    width: 60%;
                }
                #カラピカ上段{
                    /*縦にならべるね*/
                    flex-direction: column; /*縦に*/
                    width: 100%;
                    height: 70%;
                }
                #今の色{
                    /*こっちは横に*/
                    flex-direction: row; 
                    width: 100%;
                    height: 20%;
                }
                #今の色表示{
                    height: 100%;
                    width:auto;
                }
                #色参照スポイト{
                    width:2em;
                }
                
                #彩度選択div{
                    margin-left: 1em;
                    width: 90%;
                }
            }

        </style>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-1MB5XLN4LW"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-1MB5XLN4LW');
        </script>
        <!-- Google tag (gtag.js) -->

        <script src="../js/public.js"></script>
        <script>
            /*
            作りたい機能リスト
            ・反転表示
            ・回転
            　ー移動変形を使いまわせる気がするけどまあ需要ないし放置で…
            ・ツールじゃないツールをホバーしたら明るくしたら？
            ・radioボタンのchangeイベントを発火させればいいだけのところに無駄な処理書いてない？
            　ー主に色かな。ツールもあるかも？
            ・画像読み込み？でもレイヤー分離できないし、独自保存ファイル形式？でもこんなツールで数日かけて絵描くべきじゃないと思うよ。俺は。

            多すぎ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
            */
            onload = function(){
                onload_functions();

                document.getElementById("左最小化").addEventListener("click", function() {
                    var container = document.getElementById("左最小化領域");
                    if (container.style.display === "none") {
                        container.style.display = "flex";//要検討
                        this.textContent = "<";
                    } else {
                        container.style.display = "none";
                        this.textContent = ">";
                    }
                });
                document.getElementById("右最小化").addEventListener("click", function() {
                    var container = document.getElementById("右最小化領域");
                    if (container.style.display === "none") {
                        container.style.display = "block";//要検討
                        this.textContent = ">";
                    } else {
                        container.style.display = "none";
                        this.textContent = "<";
                    }
                });

                function 真ん中高さ調整() {
                    var 上下padding= parseFloat(getComputedStyle(document.getElementById("mannaka")).marginTop)+parseFloat(getComputedStyle(document.getElementById("mannaka")).marginBottom);
                    var mannaka_height = window.innerHeight-document.getElementById("header").offsetHeight -上下padding;
                    document.getElementById("mannaka").style.height = mannaka_height + "px";
                    document.getElementById("三分割くん").style.height = mannaka_height-document.querySelector("footer").offsetHeight+ "px";
                    //document.getElementById("デバッグ用").textContent = 上下padding;
                }
                真ん中高さ調整();
                window.addEventListener("resize", 真ん中高さ調整);

                var canvas_0 = document.getElementById("cnvs_0");
                var canvas_1 = document.getElementById("cnvs_1");
                var canvas_border = document.getElementById("canvas_border");
                var キャンバス拡大率 = 1;
                var border_width = 0;
                var border_height = 0;
                var 移動UI = document.getElementById("移動UI");
                
                function キャンバスボーダー設定() {                    
                    var 三分割くん=document.getElementById("三分割くん");
                    var スクロールサイズ調整=document.getElementById("スクロールサイズ調整");

                    スクロールサイズ調整.style.width = canvas_0.width*キャンバス拡大率 + "px";
                    スクロールサイズ調整.style.height = canvas_0.height*キャンバス拡大率 + "px";
                    スクロールサイズ調整.style.borderLeftWidth = 三分割くん.offsetWidth + "px";
                    スクロールサイズ調整.style.borderRightWidth = 三分割くん.offsetWidth + "px";
                    スクロールサイズ調整.style.borderTopWidth = 三分割くん.offsetHeight + "px"; 
                    スクロールサイズ調整.style.borderBottomWidth = 三分割くん.offsetHeight + "px";
                    スクロールサイズ調整.style.borderStyle = "solid";
                    スクロールサイズ調整.style.borderColor = "rgba(0, 0, 0, 0)";//透明化
                }
                
                キャンバスボーダー設定();
                window.addEventListener("resize", キャンバスボーダー設定);

                var 真ん中分割=document.getElementById("真ん中分割");
                function キャンバススクロール中央() {
                    真ん中分割.scrollLeft = (真ん中分割.scrollWidth-真ん中分割.clientWidth) / 2;
                    真ん中分割.scrollTop = (真ん中分割.scrollHeight-真ん中分割.clientHeight) / 2;
                }
                キャンバススクロール中央();
            
                //ここからおえかき機能
                var ctx_0 = canvas_0.getContext("2d");
                var ctx_1 = canvas_1.getContext("2d");
                var drawing = false;
                var スポイト追従座標;
                var 撒き戻しやり直し判定=0;
                var moveカウント=0;//n本指の即時タッチだったのかを判定するためにカウンターを用意したよ
                var バケツ判定=false;//上の奴と似たようなことをするよ
                var 撒き戻し_0=[];
                var 撒き戻し_1=[];
                var やりなおし_0=[];
                var やりなおし_1=[];
                var 履歴最大数=100;//やり直し最大数はなくてもいい。はず。
                var 一時保存用キャンバス_0;//初期化はあとでね
                var 一時保存用キャンバス_1;//初期化はあとでね
                var 現在キャンバス_0 = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                var 現在キャンバス_1 = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                var 現在キャンバス_データ部分 = 現在キャンバス_0.data;//こっちは0も1も使う感じなので1つあればいいかな
                var slider太さ = document.getElementById("slider太さ");
                var 太さ = document.getElementById("太さ");
                var 筆太さ=5;
                var 消しゴム太さ=5;
                
                var 現在の色={r:0,g:0,b:0,a:255,layer:0,num:1,rgb:"#000000"};
                var 最後の色=JSON.parse(JSON.stringify(現在の色));//参照切りしながら渡す
                var 変更する色={layer:0,num:0}

                function 色選択関数を適用(親要素名称){
                    var 親要素 = document.getElementById(親要素名称);
                    var これ数字レイヤーか=!isNaN(親要素名称.split("_")[1]);
                    if(これ数字レイヤーか){
                        var radio要素 = 親要素.querySelector(".radio");
                        radio要素.addEventListener("change", function (e) {
                            if(e.target.checked) {
                                選択色変更(input要素.value,親要素名称);
                            }
                        });
                    }
                    var input要素 = 親要素.querySelector(".色箱_input");
                    input要素.addEventListener("input", function () {
                        親要素.querySelector(".色箱_cover").style.backgroundColor = this.value; // 色を適用
                        if(これ数字レイヤーか){
                            選択色変更(this.value,親要素名称);
                            radio要素.checked = true; 
                        }
                        色箱保存(親要素名称);
                    });
                    親要素.querySelector(".色箱_cover").addEventListener("click", function () {
                        //自作カラーピッカーを表示したいと思いませんか？
                        カラーピッカー.style.display = "flex";
                        if(これ数字レイヤーか){
                            変更する色.layer = parseInt(親要素名称.split("_")[1], 10);
                        }else{
                            変更する色.layer = 親要素名称.split("_")[1];
                        }
                        変更する色.num = parseInt(親要素名称.split("_")[2], 10);

                        色参照の色更新(parseInt(input要素.value.slice(1, 3), 16),parseInt(input要素.value.slice(3, 5), 16),parseInt(input要素.value.slice(5, 7), 16),input要素.value);
                        
                    });
                    //ついでに背景色を初期化しておくか
                    親要素.querySelector(".色箱_cover").style.backgroundColor = input要素.value;

                }
                function 選択色変更(色文字列,親要素名称){
                    var 現在の色_文字列=色文字列;
                    現在の色_文字列=現在の色_文字列.replace("#", "");
                    現在の色.r = parseInt(現在の色_文字列.slice(0, 2), 16);
                    現在の色.g = parseInt(現在の色_文字列.slice(2, 4), 16);
                    現在の色.b = parseInt(現在の色_文字列.slice(4, 6), 16);
                    if(親要素名称=="color_0_0"){
                        現在の色.a=0;//なんかすごい実装だけど、まあいいか…
                    }else{
                        現在の色.a=255;
                    }
                    現在の色.rgb = 色文字列;
                    現在の色.layer = parseInt(親要素名称.split("_")[1], 10);
                    現在の色.num = parseInt(親要素名称.split("_")[2], 10);

                    //消しゴムじゃないなら色更新
                    if(現在の色.layer!=0 || 現在の色.num!=0){
                        最後の色=JSON.parse(JSON.stringify(現在の色));//参照切りしながら渡す
                    }
                    if(現在の色.num==0){
                        太さ.value=消しゴム太さ;
                    }else{
                        太さ.value=筆太さ;
                    }
                    太さからスライダー位置調整();
                }
                色選択関数を適用("color_0_0");
                色選択関数を適用("color_0_1");
                色選択関数を適用("color_0_2");

                色選択関数を適用("color_1_0");
                色選択関数を適用("color_1_1");
                色選択関数を適用("color_1_2");
                
                var 現在のツール="pen";
                var 前のツール="pen";
                var 優先ツール="";
                function ペン選択関数を適用(親要素名称){
                    var 親要素 = document.getElementById(親要素名称);
                    var radio要素 = 親要素.querySelector(".tool_radio");

                    radio要素.addEventListener("change", function (e) {
                        if(e.target.checked) {
                            if(現在のツール!=親要素名称){
                                前のツール=現在のツール;
                            }
                            現在のツール=親要素名称;
                            if(優先ツール==""){
                                真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+親要素名称+"16.png),default"; // カスタムカーソルを適用
                                var マウス追従 = document.getElementById("マウス追従");
                                マウス追従.style.display = "none"; // マウス追従を非表示…なくてもいいけどね
                            }
                            //ツールごとの固有処理
                            if(親要素名称 === "move"){
                                一時保存用キャンバス_0=ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                                一時保存用キャンバス_1=ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                                
                                // 移動UIの準備
                                var 移動UI = document.getElementById("移動UI");
                                var キャンバス位置 = canvas_0.getBoundingClientRect();
                                var 親位置 = 真ん中分割.getBoundingClientRect();

                                移動UI.style.width = canvas_0.width + "px";
                                移動UI.style.height = canvas_0.height + "px";
                                移動UI.style.left = canvas_0.style.left  + "px";
                                移動UI.style.top = canvas_0.style.top + "px";
                                移動UI.style.display = "block";

                                var 移動UI_大きさ = document.getElementById("移動UI_大きさ");
                                移動UI_大きさ .style.width = canvas_0.width + "px";
                                移動UI_大きさ .style.height = canvas_0.height + "px";
                                移動UI_大きさ.style.left =0+"px";
                                移動UI_大きさ.style.top =0+"px";
                                
                            }else{
                                if(前のツール=="move"){
                                    document.getElementById("移動UI").style.display = "none";
                                    //絵も元に戻そう。
                                    ctx_0.putImageData(一時保存用キャンバス_0, 0, 0);
                                    ctx_1.putImageData(一時保存用キャンバス_1, 0, 0);
                                }
                            }
                            
                        }
                    });
                    

                }
                ペン選択関数を適用("pen");
                ペン選択関数を適用("baketu");
                ペン選択関数を適用("supoito");
                ペン選択関数を適用("move");
                function 自動ツール選択(ツール名){
                    /*
                    if(現在のツール!=ツール名){
                        前のツール=現在のツール;
                    }
                    現在のツール=ツール名;
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+ツール名+"16.png),default"; // カスタムカーソルを適用
                    */
                    //radioも変更にする
                    var radio_div要素 = document.getElementById(ツール名);
                    var radio要素 = radio_div要素.querySelector(".tool_radio");
                    radio要素.checked = true; 
                    radio要素.dispatchEvent(new Event("change"));//changeされたことにすることができる
                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.display = "none"; // マウス追従を非表示…なくてもいいけどね
                }

                function 色スワップ表示(){
                    スワップメニュー.style.display = "flex";
                    一時保存用キャンバス_0=ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    一時保存用キャンバス_1=ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);

                }
                var スワップボタン = document.getElementById("スワップ_ボタン");
                スワップボタン.addEventListener("click",色スワップ表示);
                //↓これべつにここじゃなくて、メニュー作ってるところでもいいんじゃね？と思ったけど、いいか
                色選択関数を適用("color_swap_0");
                色選択関数を適用("color_swap_1");

                function パレットチェンジ表示(){
                    パレットメニュー.style.display = "flex";
                }
                var パレットボタン = document.getElementById("パレット_ボタン");
                パレットボタン.addEventListener("click",パレットチェンジ表示);
                
                function キャンバスを白で塗りつぶす() {
                    ctx_0.clearRect(0, 0, canvas_0.width, canvas_0.height); // 上のキャンバスはクリア
                    ctx_1.fillStyle = document.getElementById("color_pick_1_0").value; // 塗りつぶしの色を0_0に設定
                    ctx_1.fillRect(0, 0, canvas_1.width, canvas_1.height); // キャンバス全体を塗りつぶす
                }
                キャンバスを白で塗りつぶす();
                一時保存用キャンバス_0=ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                一時保存用キャンバス_1=ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);

                function キャンバス比較(data1,data2){
                    for (let i = 0; i < data1.length; i++) {
                        if (data1[i] !== data2[i]) {
                            return false;
                        }
                    }
                    return true;
                }
                function キャンバス最新保持(){
                    //次に履歴を残すために今を一時保存するやつ
                    一時保存用キャンバス_0=ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    一時保存用キャンバス_1=ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                    
                    //ここで保存しておけばいいか？
                    Canvas保存タイマー開始();
                }
                function 履歴残し(保存はいいです=false){
                    if(キャンバス比較(ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height).data,一時保存用キャンバス_0.data) &&
                       キャンバス比較(ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height).data,一時保存用キャンバス_1.data)){
                        return;//履歴が変わってないから保存しない
                    }
                    if(撒き戻し_0.length>=履歴最大数){//はみ出るから消すね
                        撒き戻し_0.shift();
                        撒き戻し_1.shift();
                    }
                    撒き戻し_0.push(一時保存用キャンバス_0);
                    撒き戻し_1.push(一時保存用キャンバス_1);
                    やりなおし_0=[];//履歴が残ったってことは次のアクションが消えるべきってわけだ！
                    やりなおし_1=[];//履歴が残ったってことは次のアクションが消えるべきってわけだ！
                    if(!保存はいいです){
                        キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ
                    }
                }
                function 描き戻し(){
                    if(撒き戻し_0.length==0){
                        return;
                    }
                    やりなおし_0.push(ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height));
                    やりなおし_1.push(ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height));
                    ctx_0.putImageData(撒き戻し_0.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    ctx_1.putImageData(撒き戻し_1.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ
                }
                function やり直し(){
                    if(やりなおし_0.length==0){
                        return;
                    }
                    撒き戻し_0.push(ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height));
                    撒き戻し_1.push(ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height));
                    ctx_0.putImageData(やりなおし_0.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    ctx_1.putImageData(やりなおし_1.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ
                }

                var 円周マスク=[];//半径をいれるとその辺の点がわかるやつ
                var 前の直径=-1;
                function 円マスク作成(直径){
                    if(直径==前の直径){
                        return;//サボっておｋ
                    }
                    前の直径=直径;
                    円周マスク=[];
                    var 半径 =Math.floor(直径/2);
                    var 半径の二乗 = 直径*直径/4;
                    for (var i = 0; i <= 半径+10; i++) {
                        円周マスク.push([]);//空配列で初期化しとくね
                    }
                    for (var i = -半径; i <= 半径; i++) {
                        for (var j = -半径; j <= 半径; j++) {//正方形領域に対して
                            if (i * i + j * j <= 半径の二乗) {//半径に収まっていれば
                                var 距離 = Math.floor(Math.sqrt(i * i + j * j));
                                円周マスク[距離].push([i, j]);
                            }
                        }
                    }
                }

                slider太さ.addEventListener("input", function() {
                    //太さは1~20で調整しやすいようにして、20~はおおざっぱな選択にする
                    var 本質太さ=1;
                    if(this.value<=80){
                        //1~80は1~20に変換する
                        本質太さ= Math.ceil(this.value*20/80);
                    }else{
                        ////80~100は20~100に変換する
                        本質太さ= Math.ceil(Math.round((this.value-80)*80/20+20)/10)*10;
                    }
                    太さ.value = 本質太さ;
                    if(現在の色.num==0){
                        消しゴム太さ=太さ.value;
                    }else{
                        筆太さ=太さ.value;
                    }
                    太さ保存();
                });
                function 太さからスライダー位置調整(){
                    //太さは1~20で調整しやすいようにして、20~はおおざっぱな選択にする
                    var slider位置=1;
                    if(太さ.value<=20){
                        //1~80は1~50に変換する
                        slider位置 = Math.floor(太さ.value*80/20);
                    }else{
                        //20~100は80~100に変換する
                        slider位置 = Math.floor((太さ.value-20)*20/80)+80;
                    }
                    slider太さ.value = slider位置;
                    if(現在の色.num==0){
                        消しゴム太さ=太さ.value;
                    }else{
                        筆太さ=太さ.value;
                    }
                    太さ保存();
                }

                太さ.addEventListener("input", 太さからスライダー位置調整);

                document.getElementById("太さ減").addEventListener("click", function() {
                    if (太さ.value > 1) {
                        太さ.value =parseInt(太さ.value, 10) -1;
                        太さ.dispatchEvent(new Event("input"));
                    }
                });
                document.getElementById("太さ増").addEventListener("click", function() {
                    if (太さ.value < 100) {
                        太さ.value =parseInt(太さ.value, 10) +1;
                        太さ.dispatchEvent(new Event("input"));
                    }
                });

                function 改行来たから終わるね(e){
                    //改行が着たら、選択から外すという親切心
                    if (e.key === "Enter") {
                        e.target.blur();
                    }
                }
                太さ.addEventListener("keydown", 改行来たから終わるね);

                var 前回のマウス = {
                    x: 0,
                    y: 0
                };
                let スマホ誤動作判定タイマー=null;//スマホで二本指移動しようとすると、誤タッチで点が撃たれるのを撒きもどして消す。
                let スマホ誤動作判定結果フラグ=false;
                function すみません今描いてるやつってなかったことにできませんか(){
                    if (一時保存用キャンバス_0 && 一時保存用キャンバス_1) {
                        ctx_0.putImageData(一時保存用キャンバス_0, 0, 0);
                        ctx_1.putImageData(一時保存用キャンバス_1, 0, 0);
                    }
                }
                function 描き始め(e) {
                    drawing = true;

                    //現在の画像を取得しておく。moveで取得するとクソ遅いからね
                    現在キャンバス_0 = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    現在キャンバス_1 = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                    if(現在の色.layer==0){
                        現在キャンバス_データ部分 = 現在キャンバス_0.data;
                    }else if(現在の色.layer==1){
                        現在キャンバス_データ部分 = 現在キャンバス_1.data;
                    }
                    

                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    if (e.touches) {//これ指じゃね？
                        前回のマウス.x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        前回のマウス.x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }

                    // スマホ用：巻き戻しフラグをセットし、n秒後に解除
                    スマホ誤動作判定結果フラグ = true;
                    if(スマホ誤動作判定タイマー) clearTimeout(スマホ誤動作判定タイマー);
                    スマホ誤動作判定タイマー = setTimeout(() => {
                        スマホ誤動作判定結果フラグ = false;
                        //document.getElementById("デバッグ用").textContent ="end";

                    }, 100); // 0.2秒
                    
                    描き途中(e);//チョン押しでも点が打てるように                 
                }

                function 描き途中(e) {
                    if (!drawing){//そんなことあるか？
                        return;
                    }

                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var x, y;

                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    
                    //アンチエイリアスが嫌なので、1ピクセルずつ.fillRect()で描く
                    //前回のマウスの座標から、現在のマスウの座標までの移動距離だけループする
                    var dx = x - 前回のマウス.x;
                    var dy = y - 前回のマウス.y;
                    if(Math.abs(dx)>Math.abs(dy)){
                        var ループ回数 = Math.abs(dx)+1;
                    }else{
                        var ループ回数 = Math.abs(dy)+1;
                    }
                    //太さ決定。ここでいいのか…？
                    /*
                    //俺のペンタブ、ブラウザで筆圧検知できねえわ（笑）
                    console.log(e.pressure);
                    if(e.pressure){
                        var 圧力直径=Math.floor(太さ.value*e.pressure);//筆圧で太さを変える
                    }else{
                        var 圧力直径=太さ.value;
                    }
                    */
                    if(現在の色.num==0){
                        var 圧力直径=消しゴム太さ;
                    }else{
                        var 圧力直径= 筆太さ;
                    }
                    //円の計算大変なので最初にやって保存する。
                    円マスク作成(圧力直径);
                    var 円データ = [];
                    //線を分割
                    for (var i = 0; i < ループ回数; i++) {
                        var ループx = Math.floor(前回のマウス.x + (dx / ループ回数) * i);
                        var ループy = Math.floor(前回のマウス.y + (dy / ループ回数) * i);
                        円データ.push([ループx, ループy, 圧力直径]);
                    }
                    //塗らずに円を描きまくっても線になるので、ガワだけ描いていく。
                    for (const [ループx, ループy, 直径] of 円データ) {
                        円を描く(ループx, ループy, 直径,true);//ガワだけ描くよ
                    }
                    //チョン押しだった場合は真ん中が塗られないので、塗る。
                    円を描く(x,y,圧力直径,false);
                    
                    if(現在の色.layer==0){
                        ctx_0.putImageData(現在キャンバス_0, 0, 0);//渡すのはデータ部ではない。
                        /*
                        //ここで塗ることで時短。筆圧で変化するようにしたらアレになるかも？
                        //残りはもう直接塗っちゃえばよくね？
                        ctx_0.fillStyle = 現在の色.rgb;
                        ctx_0.beginPath();
                        ctx_0.arc(x+0.5, y+0.5, Math.max(0,Math.floor(圧力直径/2)-1), 0, Math.PI * 2);//ちょっとちっちゃめにしとこうぜ
                        //+0.5は、円周の表示と比べて中心位置がちょいずれてるから入れた
                        ctx_0.fill();
                        */
                    }else if(現在の色.layer==1){
                        ctx_1.putImageData(現在キャンバス_1, 0, 0);//渡すのはデータ部ではない。
                        /*
                        //ここで塗ることで時短。筆圧で変化するようにしたらアレになるかも？
                        //残りはもう直接塗っちゃえばよくね？
                        ctx_1.fillStyle = 現在の色.rgb;
                        ctx_1.beginPath();
                        ctx_1.arc(x+0.5, y+0.5, Math.max(0,Math.floor(圧力直径/2)-1), 0, Math.PI * 2);//ちょっとちっちゃめにしとこうぜ
                        //+0.5は、円周の表示と比べて中心位置がちょいずれてるから入れた
                        //ctx_1.fill();
                        */
                    }


                    //次回の始点を更新更新！
                    if (e.touches) {//これ指じゃね？
                        前回のマウス.x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        前回のマウス.x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                }


                function 円を描く(x, y, 直径,ガワだけ) {
                    //円周部分だけはしっかりと3ピクセルくらいだけ描いて、真ん中はまあ適当にって感じ
                    var 半径 =Math.floor(直径/2);
                    var 半径の二乗 = 直径*直径/4;

                    //レイヤー分けは不要だよね（だよねだよね）

                    //色ロックをしてるときはフラグ立てるか
                    var 色ロック=-1;
                    if(現在の色.layer==0 && document.getElementById("lock_0").checked ){
                        色ロック=0;
                    }else if(現在の色.layer==1 && document.getElementById("lock_1").checked ){
                        色ロック=1;
                        
                        var 背景色_文字列= document.getElementById("color_pick_1_0").value;
                        背景色_文字列=背景色_文字列.replace("#", "");
                        var 背景色={r:0,g:0,b:0};
                        背景色.r = parseInt(背景色_文字列.slice(0, 2), 16);
                        背景色.g = parseInt(背景色_文字列.slice(2, 4), 16);
                        背景色.b = parseInt(背景色_文字列.slice(4, 6), 16);
                    }

                    if(ガワだけ){
                        var 描き初め=Math.max(0, 半径-2); //マイナスの値ってなにが適切なんだろうね           
                    }else{
                        var 描き初め=0;    
                    }
                    for(var r=描き初め; r<=半径; r++){//ちゃんと描く。
                        for (const [i, j] of 円周マスク[r]) {
                            if(i+x<0 || i+x>=canvas_0.width || j+y<0 || j+y>=canvas_0.height){
                                continue;//キャンバス外は無視
                            }
                            if (i * i + j * j <= 半径の二乗) {//半径に収まっていれば
                                //lockボタン判定
                                if (色ロック==0 && 現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4+3] === 0){
                                    continue;//ここ透明だからスキップするね
                                }else if (色ロック==1){
                                    //レイヤー1はcolor_pick_1_0の色と比較
                                    if (現在キャンバス_データ部分[((y + j) * canvas_1.width + (x + i))*4] === 背景色.r &&
                                        現在キャンバス_データ部分[((y + j) * canvas_1.width + (x + i))*4+1] === 背景色.b &&
                                        現在キャンバス_データ部分[((y + j) * canvas_1.width + (x + i))*4+2] === 背景色.g ){
                                        continue;//ここ背景色だからスキップするね
                                    }
                                }
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4] = 現在の色.r;//直接色変える
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4+1] = 現在の色.g;//直接色変える
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4+2] = 現在の色.b;//直接色変える
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4+3] = 現在の色.a;//直接色変える
                            }
                        }
                    }    
                     
                }
                
                function 描き終わり() {                      
                    drawing = false;
                    履歴残し();
                    
                }

                function バケツ(e){
                    現在キャンバス_0 = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    現在キャンバス_1 = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                    var 現在キャンバス_データ部分_0= 現在キャンバス_0.data;
                    var 現在キャンバス_データ部分_1= 現在キャンバス_1.data;

                    var キャンバス位置 = canvas_0.getBoundingClientRect();//まあこれはどっちでもいいよね
                    var x, y;

                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    //マウス位置の色を取得
                    //レイヤー0が透明だったらレイヤー1を参照
                    if(ctx_0.getImageData(x, y, 1, 1).data[3]!=0){
                        //透明じゃねえな
                        if(現在の色.layer==1){
                            //そこ、レイヤー0に色があるのでレイヤー1の色塗ろうとすると死にます。
                            return;
                        }
                        var 塗られる色 = ctx_0.getImageData(x, y, 1, 1).data;
                        var 参照レイヤー=0;
                    }else{    
                        if(現在の色.a==0){//いや、お前も透明色じゃねえか
                            return;
                        }
                        var 塗られる色 = ctx_1.getImageData(x, y, 1, 1).data;
                        var 参照レイヤー=1;
                    }
                    //塗られる色と、今から塗る色が同じだと意味ないし無限ループ入るから終了する。
                    if (塗られる色[0] === 現在の色.r && 塗られる色[1] === 現在の色.g && 塗られる色[2] === 現在の色.b && 塗られる色[3] === 現在の色.a) {
                        return;
                    }
                    var キュー = [[x, y]];

                    //キューが無くなるまでループして、色を判定→周囲をキューに入れる→自分を塗って削除を繰り返す
                    while (キュー.length > 0) {
                        var [キューx, キューy] = キュー.pop();//キューの先頭を取り出す
                        //キャンバス外は無視
                        if (キューx < 0 || キューx >= canvas_0.width || キューy < 0 || キューy >= canvas_0.height) {
                            continue;
                        }
                        if(参照レイヤー==0){
                            //すでに塗られている色は無視
                            if (現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4] === 塗られる色[0] 
                            && 現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4+1] === 塗られる色[1] 
                            && 現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4+2] === 塗られる色[2] 
                            && 現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4+3] === 塗られる色[3]) {
                                //お前の色はバケツ対象だから、周囲をキューにぶち込む
                                キュー.push([キューx + 1, キューy]);
                                キュー.push([キューx - 1, キューy]);
                                キュー.push([キューx, キューy + 1]);
                                キュー.push([キューx, キューy - 1]);

                                //塗る
                                現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4] = 現在の色.r;//直接色変える
                                現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 1] = 現在の色.g;//直接色変える  
                                現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 2] = 現在の色.b;//直接色変える
                                現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 3] = 現在の色.a;//直接色変える
                            }

                        }else{
                            //レイヤー0が透明だから…
                            if (現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4+3] == 0) {
                                if (現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4] === 塗られる色[0] 
                                && 現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4+1] === 塗られる色[1] 
                                && 現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4+2] === 塗られる色[2] 
                                && 現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4+3] === 塗られる色[3]) {
                                    //お前の色はバケツ対象だから、周囲をキューにぶち込む
                                    キュー.push([キューx + 1, キューy]);
                                    キュー.push([キューx - 1, キューy]);
                                    キュー.push([キューx, キューy + 1]);
                                    キュー.push([キューx, キューy - 1]);

                                    //塗る
                                    if(現在の色.layer==0){
                                        現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4] = 現在の色.r;//直接色変える
                                        現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 1] = 現在の色.g;//直接色変える  
                                        現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 2] = 現在の色.b;//直接色変える
                                        現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 3] = 現在の色.a;//直接色変える
                                    }else{
                                        現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4] = 現在の色.r;//直接色変える
                                        現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4 + 1] = 現在の色.g;//直接色変える  
                                        現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4 + 2] = 現在の色.b;//直接色変える
                                        現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4 + 3] = 現在の色.a;//直接色変える
                                    }

                                }

                            }
                        }
                    }
                    //画像をcanvasへ反映
                    ctx_0.putImageData(現在キャンバス_0, 0, 0);//渡すのはデータ部ではない。
                    ctx_1.putImageData(現在キャンバス_1, 0, 0);//渡すのはデータ部ではない。
                    
                    //document.getElementById("デバッグ用").textContent ="終";
                    履歴残し();
                }

                function スポイトの色表示(x,y){
                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.left = x+10+"px";
                    マウス追従.style.top =  y+10+"px";

                    var canv_x, canv_y;
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    canv_x = Math.floor((x - キャンバス位置.left )/キャンバス拡大率);
                    canv_y = Math.floor((y - キャンバス位置.top )/キャンバス拡大率);
                    
                    マウス追従.style.display = "block"; // マウス追従を表示

                    //色もっていく
                    var そこの色 = ctx_0.getImageData(canv_x, canv_y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        そこの色=ctx_1.getImageData(canv_x, canv_y, 1, 1).data;
                    }
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    マウス追従.style.backgroundColor = 色文字列; // 色を適用
                    
                }

                function 色参照スポイトの色表示(x,y){

                    var canv_x, canv_y;
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    canv_x = Math.floor((x - キャンバス位置.left )/キャンバス拡大率);
                    canv_y = Math.floor((y - キャンバス位置.top )/キャンバス拡大率);
                    

                    //色もっていく
                    var そこの色 = ctx_0.getImageData(canv_x, canv_y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        そこの色=ctx_1.getImageData(canv_x, canv_y, 1, 1).data;
                    }
                    選択色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    //ここから色々やる
                    色参照の色更新(そこの色[0],そこの色[1],そこの色[2],選択色文字列);
                }

                function 色参照の色更新(r,g,b,rgb){
                    [選択された色相,選択された彩度,選択された明度]= rgbからhsv(r,g,b);
                    選択色文字列=rgb;

                    var キャンバスでかさ_色相 = 色相バー.getBoundingClientRect();
                    var キャンバスでかさ_彩度 = 彩度表示.getBoundingClientRect();
                    var CSSでかさ_色相=getComputedStyle(色相バー);
                    var CSSでかさ_彩度=getComputedStyle(彩度表示);
                    var [r, g, b] = hsvからRgb(選択された色相, 1, 1);//色相以外無視した色作る
                    var 選択色文字列_色相= "#"+[r, g, b].map(n => n.toString(16).padStart(2, '0')).join('');//各要素に対して、16進数にしたあとに2桁未満なら0を付けて、文字列結合する
                    今の色相.style.backgroundColor=選択色文字列_色相;
                    今の色相.style.left = 選択された色相*(キャンバスでかさ_色相.width-parseFloat(CSSでかさ_色相.borderLeftWidth)*2)+"px";//あってんの？まあいいけど
                    彩度エリアの表示(選択された色相);
                    今の彩度.style.backgroundColor=rgb;
                    今の色表示.style.backgroundColor=rgb;
                    今の彩度.style.top = (1-選択された明度)*(キャンバスでかさ_彩度.height-parseFloat(CSSでかさ_彩度.borderBottomWidth)*2)+"px";
                    今の彩度.style.left = 選択された彩度*(キャンバスでかさ_彩度.width-parseFloat(CSSでかさ_彩度.borderLeftWidth)*2)+"px";
                }

                function スポイト端っこ表示(e){
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var x, y;
                    
                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }

                    //範囲外なら無視
                    if (x < 0 || x >= canvas_0.width || y < 0 || y >= canvas_0.height) {
                        return;
                    }

                    var マウス追従 = document.getElementById("マウス追従");
                    //ここでは画面の左下に表示
                    マウス追従.style.left = 0 + "px";
                    マウス追従.style.top =真ん中分割.clientHeight+"px";

                    マウス追従.style.display = "block"; // マウス追従を表示
                    
                    //色縫っていく
                    var そこの色 = ctx_0.getImageData(x,y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        そこの色=ctx_1.getImageData(x, y, 1, 1).data;
                    }
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    マウス追従.style.backgroundColor = 色文字列; // 色を適用

                }

                function スポイト反映(e){
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var x, y;
                    
                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    
                    //範囲外なら無視
                    if (x < 0 || x >= canvas_0.width || y < 0 || y >= canvas_0.height) {
                        return;
                    }

                    
                    var 対象色レイヤー=0;
                    //マウス位置の色を取得
                    var そこの色 = ctx_0.getImageData(x, y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        対象色レイヤー=1;
                        そこの色=ctx_1.getImageData(x, y, 1, 1).data;
                    }
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    //radio_divに同じ色のやつがないか探す
                    var 色箱一覧 = document.querySelectorAll(".色箱_input");

                    
                    var color_0_div = document.getElementById("color_0");
                    var radio_0 = color_0_div.querySelectorAll(".radio_div");
                    var 上段色数=radio_0.length;
                    var 開始位置=1;
                    var 終了位置=上段色数;
                    if(対象色レイヤー==1){//レイヤー1の色は、レイヤー1用の箱でだけ処理しよう。
                        開始位置=上段色数;
                        終了位置=色箱一覧.length;
                    }

                    for (var i = 開始位置; i < 終了位置; i++) {//i=0は消しゴムなので無視。
                        var 色箱 = 色箱一覧[i];
                        //idが数字じゃないやつは無視
                        if (isNaN(色箱.id.split("_")[2])){
                            continue;
                        }
                        if (色箱.value.toLowerCase() === 色文字列.toLowerCase()) {//.toLowerCase()は小文字にするやつ
                            // 同じ色が見つかった場合、その色を選択
                            色箱.parentElement.parentElement.querySelector(".radio").checked = true;
                            選択色変更(色箱.value, 色箱.parentElement.parentElement.id);
                            自動ツール選択(前のツール);
                            return;
                        }
                    }
                    //色を取ってきたレイヤーの、今選択してる色の縦列で色設定。え？上下で色の数が違ったら…？それは、そんな改造をしてるほうが悪いザンス。
                    if(対象色レイヤー==0 && 現在の色.num==0){
                        //まって、それ消しゴムだからずらすね
                        var radio_div要素 = document.getElementById("color_0_1");
                    }else{
                        var radio_div要素 = document.getElementById("color_" + 対象色レイヤー + "_" + 現在の色.num);
                    }
                    var input要素 = radio_div要素.querySelector(".色箱_input");
                    input要素.value =色文字列;
                    input要素.dispatchEvent(new Event("input"));//inputが変更されたことにすることができる
                    自動ツール選択(前のツール);
                }

                function 色参照スポイト反映(e){
                    if (e.touches) {//これ指じゃね？
                        色参照スポイトの色表示(e.touches[0].clientX, e.touches[0].clientY);
                    } else {//マウスだわ
                        色参照スポイトの色表示(e.clientX, e.clientY);
                    }
                    優先ツール="";                    
                    色参照スポイト.classList.remove("色参照スポイト_clicked");
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+現在のツール+"16.png),default"; // カスタムカーソルを適用
                    //以上！…ほんとに？
                }

                function スポイト非表示(){
                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.display = "none"; // マウス追従を非表示
                }

                var 動かし前指間距離 = 0;
                var 前回指間座標 = [0, 0];

                function 指間距離計算(touches) {
                    var dx = touches[0].clientX - touches[1].clientX;
                    var dy = touches[0].clientY - touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }

                function 指間座標計算(e) {
                    return [(e.touches[0].clientX + e.touches[1].clientX) / 2, (e.touches[0].clientY + e.touches[1].clientY) / 2];
                }
                真ん中分割.addEventListener("pointerdown", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    // スクロールバー上でのクリックを無視
                    if (e.clientX > 真ん中分割.clientWidth+真ん中分割.getBoundingClientRect().left || e.clientY > 真ん中分割.clientHeight+真ん中分割.getBoundingClientRect().top) {
                        return;
                    }
                    真ん中分割.setPointerCapture(e.pointerId);//ポインターを追跡する。どっか行ってもキャンセルを監視できる
                    
                    if(優先ツール==="色参照スポイト"){
                        return;
                    }

                    // 右クリックはスポイト
                    if (e.button === 2) {
                        自動ツール選択("supoito");
                        return;
                    }

                    if(現在のツール==="pen"){
                        描き始め(e);
                    }else if(現在のツール==="baketu"){
                        バケツ(e);
                    }else if(現在のツール==="supoito"){
                        
                    }
                });
                真ん中分割.addEventListener("pointermove", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    if(優先ツール==="色参照スポイト"){
                        return;
                    }

                    if(現在のツール==="pen"){
                        描き途中(e);
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                    }else if(現在のツール=="move"){
                        四隅拡大縮小移動(e);
                    }
                    
                });
                canvas_0.addEventListener("contextmenu", function(e){
                    e.preventDefault(); // 右クリックメニューを消す
                });
                canvas_0.addEventListener("pointermove", function(e){
                    //※どうやら右クリックしてるとこいつが動かないっぽい
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    if(優先ツール==="色参照スポイト"){
                        色参照スポイトの色表示(e.x, e.y);
                        return;
                    }

                    if(現在のツール==="pen"){

                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                        スポイトの色表示(e.x, e.y);
                    }
                });
                window.addEventListener("mousemove", (e) => {
                    //※どうやら右クリックしててもこいつはうごくっぽい
                    if(現在のツール==="supoito"){
                        スポイトの色表示(e.x, e.y);
                    }
                });
                canvas_0.addEventListener("pointerleave", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    if(優先ツール==="色参照スポイト"){
                        return;
                    }

                    if(現在のツール==="pen"){
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                        スポイト非表示();
                    }else if(現在のツール=="move"){
                        四隅拡大縮小終了();
                    }
                });

                真ん中分割.addEventListener("pointerup", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    if(優先ツール==="色参照スポイト"){
                        色参照スポイト反映(e);
                        return;
                    }

                    if(現在のツール==="pen"){
                        描き終わり();
                    }else if(現在のツール==="baketu"){
                        
                    }else if(現在のツール==="supoito"){
                        スポイト反映(e);
                    }else if(現在のツール=="move"){
                        四隅拡大縮小終了();
                    }
                    
                });
                真ん中分割.addEventListener("pointercancel", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    if(優先ツール==="色参照スポイト"){
                        return;
                    }

                    if(現在のツール==="pen"){
                        描き終わり();
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){

                    }else if(現在のツール=="move"){
                        四隅拡大縮小終了();
                    }
                });

                真ん中分割.addEventListener("wheel", function(e) {
                    //スクロールバーの上でのホイール操作を無視

                    if (e.clientX < 真ん中分割.clientWidth+真ん中分割.getBoundingClientRect().left && e.clientY < 真ん中分割.clientHeight+真ん中分割.getBoundingClientRect().top) {
                        e.preventDefault();
                        キャンバス拡大(e.deltaY > 0 ? -0.1 : 0.1, e.clientX, e.clientY);
                    }else if(e.clientY > 真ん中分割.clientHeight+真ん中分割.getBoundingClientRect().top){
                        e.preventDefault();
                        //上下スクロールでキャンバスの横向きの位置を調整する.カクカクするけど、いいよね！
                        真ん中分割.scrollLeft += e.deltaY/2;
                    }
                }); 

                function キャンバス拡大(拡大率, 中心x, 中心y){                    
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var 変動前位置x=(中心x - キャンバス位置.left )/キャンバス拡大率;
                    var 変動前位置y=(中心y - キャンバス位置.top )/キャンバス拡大率;

                    var 前拡大率 = キャンバス拡大率;
                    キャンバス拡大率 += 拡大率;
                    キャンバス拡大率 = Math.max(0.1, キャンバス拡大率);
                    キャンバス拡大率 = Math.min(10, キャンバス拡大率);

                    //キャンバスの位置を調整する
                    真ん中分割.scrollLeft +=  (中心x - キャンバス位置.left )*(キャンバス拡大率/前拡大率-1);
                    真ん中分割.scrollTop += (中心y - キャンバス位置.top )*(キャンバス拡大率/前拡大率-1);
                 

                    //キャンバスを拡大（ズラす→拡大の順番じゃないとどうやら非同期処理で計算狂うっぽい）
                    canvas_0.style.transform = "scale("+キャンバス拡大率+")";
                    canvas_1.style.transform = "scale("+キャンバス拡大率+")";
                    キャンバスボーダー設定();
                    //ま、それでもちょっとずれてるけどね

                    移動UI.style.transform = "scale("+キャンバス拡大率+")";
                }
                
                var バケツ位置保存;
                真ん中分割.addEventListener("touchstart", function(e) {
                    moveカウント=0;
                    if (e.touches.length === 1) {
                        e.preventDefault();
                        if(優先ツール==="色参照スポイト"){
                            スポイト追従座標=e;
                            return;
                        }
                        if(現在のツール==="pen"){
                            描き始め(e);
                        }else if(現在のツール==="baketu"){
                            バケツ位置保存=e;//ここで保存しないと、指を離したときにはどっかいってる。
                        }else if(現在のツール==="supoito"){
                            スポイト追従座標=e;
                        }
                    }else{
                        if (e.touches.length === 2) {
                            e.preventDefault();
                            撒き戻しやり直し判定=2;
                            
                            前回指間座標 = 指間座標計算(e);
                            動かし前指間距離 = 指間距離計算(e.touches);
                        } else if (e.touches.length ===3) {
                            e.preventDefault();
                            撒き戻しやり直し判定=3;
                        }
                        //さっきのちょん押しって誤爆だから巻き戻す。
                        if(スマホ誤動作判定結果フラグ){
                            スマホ誤動作判定結果フラグ=false;
                            //document.getElementById("デバッグ用").textContent =スマホ誤動作判定タイマー;
                            すみません今描いてるやつってなかったことにできませんか();
                        }
                    }

                });

                真ん中分割.addEventListener("touchmove", function(e) {                    
                    moveカウント+=1;

                    if (e.touches.length === 2) {
                        if( 撒き戻しやり直し判定!=3){
                            撒き戻しやり直し判定=2;
                        }
                        drawing=false;
                        スポイト追従座標=null;
                        e.preventDefault();
                        //拡大操作
                        var 指間距離 = 指間距離計算(e.touches);
                        var 変動率 = 指間距離 / 動かし前指間距離;
                        動かし前指間距離 = 指間距離;
                        キャンバス拡大((変動率-1)*キャンバス拡大率,指間座標計算(e)[0] , 指間座標計算(e)[1]);
                        //移動操作
                        //合計移動量が少ないなら移動しない…は実装せんでええか
                        真ん中分割.scrollLeft += (前回指間座標[0] - 指間座標計算(e)[0]);//拡大してても影響ないよ～～ん
                        真ん中分割.scrollTop += (前回指間座標[1] - 指間座標計算(e)[1]);
                        前回指間座標 = 指間座標計算(e);

                        //さっきのちゃん押しって誤爆だから巻き戻すか。履歴にゴミのこるけど（笑）
                        if(スマホ誤動作判定結果フラグ){
                            スマホ誤動作判定結果フラグ=false;
                            //document.getElementById("デバッグ用").textContent =スマホ誤動作判定タイマー;
                            すみません今描いてるやつってなかったことにできませんか();
                        }
                    } else if (e.touches.length ===3) {
                        撒き戻しやり直し判定=3;
                        drawing=false;
                        スポイト追従座標=null;
                        e.preventDefault();
                    } else if (e.touches.length > 3) {
                        // 指が4本以上の場合は反応しない
                    }else{
                        e.preventDefault();//画面スクロールとか無効にしちゃうよ～ん
                        
                        if(優先ツール==="色参照スポイト"){
                            スポイト追従座標=e;
                            色参照スポイトの色表示(e.touches[0].clientX, e.touches[0].clientY);
                            return;
                        }

                        if(現在のツール==="pen"){
                            描き途中(e);
                        }else if(現在のツール==="baketu"){
                            //判定はこの関数の上のほうでやってるので。
                        }else if(現在のツール==="supoito"){
                            スポイト追従座標=e;
                            スポイト端っこ表示(スポイト追従座標);
                        }else if(現在のツール=="move"){
                            四隅拡大縮小移動(e);
                        }
                    }
                });

                真ん中分割.addEventListener("touchend", function(e) {
                    e.preventDefault();//画面スクロールとか無効にしちゃうよ～ん

                    if(優先ツール==="色参照スポイト"){
                        if(スポイト追従座標){
                            色参照スポイト反映(スポイト追従座標);
                        }
                    }else{
                        if(現在のツール==="pen"){
                            描き終わり();
                        }else if(現在のツール==="baketu"){
                            if(moveカウント<2){
                                バケツ(バケツ位置保存);
                            }
                        }else if(現在のツール==="supoito"){
                            if(スポイト追従座標){
                                スポイト反映(スポイト追従座標);
                            }
                            
                        }else if(現在のツール=="move"){
                            四隅拡大縮小終了();
                        }
                    }
                    

                    if(撒き戻しやり直し判定===2){
                        if(moveカウント<5){//指が動きすぎてたらまあ、別の操作だろう…
                            描き戻し();
                        }
                    }else if(撒き戻しやり直し判定===3){
                        //こっちはmoveカウントなくていいんじゃね？暴発しないだろうし…
                        やり直し();
                    }
                    撒き戻しやり直し判定=0;
                });

                document.addEventListener("keydown", function(e) {

                    if (e.ctrlKey && e.key === "z") {
                        e.preventDefault(); // デフォルトの動作を無効化
                        描き戻し();
                    } else if (e.ctrlKey && e.key === "y") {
                        e.preventDefault(); // デフォルトの動作を無効化
                        やり直し();
                    } else if (e.key === "e") {
                        e.preventDefault(); // デフォルトの動作を無効化
                        //ツールをペンに変える
                        自動ツール選択("pen");
                        if(現在の色.layer!=0 || 現在の色.num!=0){//消しゴムじゃないな…
                            選択色変更("#FFFFFF","color_0_0");
                            var radio要素 = document.getElementById("color_radio_0_0");
                            radio要素.checked = true;
                        }else{
                            選択色変更(最後の色.rgb,"color_" + 最後の色.layer + "_" + 最後の色.num);
                            var radio要素 = document.getElementById("color_radio_" + 現在の色.layer + "_" + 現在の色.num);
                            radio要素.checked = true;
                        }
                    } else if (Number.isInteger(Number(e.key))) {
                        var color_0_div = document.getElementById("color_0");
                        var radio_0 = color_0_div.querySelectorAll(".radio_div");
                        var color_1_div = document.getElementById("color_1");
                        var radio_1 = color_1_div.querySelectorAll(".radio_div");
                        var キーボード入力値=Number(e.key)-1;
                        //console.log(キーボード入力値);
                        if(キーボード入力値<0){
                            キーボード入力値=0;
                        }else if(radio_0.length+radio_1.length<=キーボード入力値){
                            キーボード入力値=radio_0.length+radio_1.length-1;
                        }
           
                        if(radio_0.length>キーボード入力値){
                            var 色箱 = document.getElementById("color_pick_" + 0 + "_" + キーボード入力値);
                            色箱.parentElement.parentElement.querySelector(".radio").checked = true;
                            選択色変更(色箱.value,"color_" +0 + "_" +キーボード入力値);

                        }else{
                            キーボード入力値-=radio_0.length;
                            var 色箱 = document.getElementById("color_pick_" + 1 + "_" + キーボード入力値);
                            色箱.parentElement.parentElement.querySelector(".radio").checked = true;
                            選択色変更(色箱.value,"color_" +1+ "_" +キーボード入力値);

                        }
                    }
                });

                
                document.getElementById("描き戻しボタン").addEventListener("click", function() {
                    描き戻し();
                });

                document.getElementById("やり直しボタン").addEventListener("click", function() {
                    やり直し();
                });


                document.getElementById("コピーボタン").addEventListener("click", function() {
                    //テキストもコピーできるかな～て思ったけど、できるけどできないみたい。
                    var 合成キャンバス=new OffscreenCanvas(canvas_0.width, canvas_0.height);
                    var 合成結果=合成キャンバス.getContext("2d");
                    合成結果.drawImage(canvas_1,0,0);
                    合成結果.drawImage(canvas_0,0,0);
                    合成キャンバス.convertToBlob().then(function(blob) {
                        const item = new ClipboardItem({ "image/png": blob });//HTTPSかhttp://127.0.0.1/じゃないとうごかない、らしいね。
                        navigator.clipboard.write([item]).then(function() {
                        }).catch(function(err) {
                            console.error("クリップボードへのコピーに失敗しました:", err);
                        });
                        Canvas保存();
                    });
                });

                document.getElementById("保存").addEventListener("click", function() {
                    var 合成キャンバス=new OffscreenCanvas(canvas_0.width, canvas_0.height);
                    var 合成結果=合成キャンバス.getContext("2d");
                    合成結果.drawImage(canvas_1,0,0);
                    合成結果.drawImage(canvas_0,0,0);
                    合成キャンバス.convertToBlob().then(function(blob) {//HTTPSかhttp://127.0.0.1/じゃないとうごかない、らしいね。
                        var link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        const date = new Date();
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, '0');  // 月は0から始まるので+1
                        const day = String(date.getDate()).padStart(2, '0');
                        const hours = String(date.getHours()).padStart(2, '0');
                        const minutes = String(date.getMinutes()).padStart(2, '0');
                        const seconds = String(date.getSeconds()).padStart(2, '0');
                        link.download = year+month+day+hours+minutes+seconds+"_deyukaki.png";//ファイル名決めてる
                        link.click();//強制クリック
                        Canvas保存();
                    });
                });

                document.getElementById("白紙").addEventListener("click", function() {
                    キャンバスを白で塗りつぶす();
                    履歴残し();
                    
                });

                //ここからはカラーピッカーの実装ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

                function hsvからRgb(h, s, v) {//引数は0~1
                    let r, g, b;
                    const i = Math.floor(h * 6);//角度から、rgbのどの領域なのかを選択
                    const f = h * 6 - i;
                    const p = v * (1 - s);
                    const q = v * (1 - f * s);
                    const t = v * (1 - (1 - f) * s);

                    switch (i % 6) {
                        case 0: r = v; g = t; b = p; break;
                        case 1: r = q; g = v; b = p; break;
                        case 2: r = p; g = v; b = t; break;
                        case 3: r = p; g = q; b = v; break;
                        case 4: r = t; g = p; b = v; break;
                        case 5: r = v; g = p; b = q; break;
                    }
                    return [
                        Math.round(r * 255),
                        Math.round(g * 255),
                        Math.round(b * 255)
                    ];
                }

                function rgbからhsv(r,g,b){
                    r /= 255;
                    g /= 255;
                    b /= 255;
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    let h, s, v = max;

                    const d = max - min;
                    s = max === 0 ? 0 : d / max;//最大値が0の場合は黒色なので彩度の計算ができないのをカバー

                    if (max === min) {
                        h = 0; // achromatic
                    } else {
                        switch (max) {
                            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                            case g: h = (b - r) / d + 2; break;
                            case b: h = (r - g) / d + 4; break;
                        }
                        h /= 6;
                    }
                    return [h,s,v];
                }

                var 今の色表示=document.getElementById("今の色表示");

                var 色相バー=document.getElementById("色相選択");
                var 色相選択=色相バー.getContext("2d");
                var 色相選択の画像データ = 色相選択.createImageData(360, 1);
                var 今の色相=document.getElementById("今の色相");
                
                var 彩度表示 = document.getElementById("彩度選択");
                var 彩度選択 = 彩度表示.getContext("2d");
                var 彩度選択の画像データ = 彩度選択.createImageData(256, 256);
                var 今の彩度=document.getElementById("今の彩度");

                var 色参照スポイト=document.getElementById("色参照スポイト");
                var 採用ボタン_color=document.getElementById("採用ボタン_color");
                var 破棄ボタン_color=document.getElementById("破棄ボタン_color");

                var 選択色文字列="#000000";
                var 選択された色相 = 0;
                var 選択された彩度 = 0;
                var 選択された明度 = 0;

                for (let i = 0; i < 360; i++) {
                    var [r, g, b] = hsvからRgb(i / 360, 1,1);
                    色相選択の画像データ.data[i*4] = r;
                    色相選択の画像データ.data[i*4 + 1] = g;
                    色相選択の画像データ.data[i*4 + 2] = b;
                    色相選択の画像データ.data[i*4 + 3] = 255;
                }
                色相選択.putImageData(色相選択の画像データ, 0, 0);



                function 彩度エリアの表示(角度) {
                    for (let y = 0; y < 256; y++) {
                        for (let x = 0; x < 256; x++) {
                            const s = x / 255;
                            const v = 1 - y / 255;
                            const [r, g, b] = hsvからRgb(角度, s, v);
                            const index = (y * 256 + x) * 4;
                            彩度選択の画像データ.data[index] = r;
                            彩度選択の画像データ.data[index + 1] = g;
                            彩度選択の画像データ.data[index + 2] = b;
                            彩度選択の画像データ.data[index + 3] = 255;
                        }
                    }
                    彩度選択.putImageData(彩度選択の画像データ, 0, 0);
                    今の彩度.style.backgroundColor=選択色文字列;
                    今の色表示.style.backgroundColor=選択色文字列;
                    
                }
                彩度エリアの表示(0);

                

                function 色相変更(e){
                    if(isNaN(e.offsetX)){//NaNだったら拒否
                        return;
                    }
                    var キャンバスでかさ = 色相バー.getBoundingClientRect();
                    var CSSでかさ=getComputedStyle(色相バー);
                    //borderがクリック範囲に入ってやがるので計算で消す。
                    選択された色相 = Math.floor(e.offsetX/(キャンバスでかさ.width-parseFloat(CSSでかさ.borderLeftWidth)*2)*360);
                    選択された色相 =Math.min(Math.max(選択された色相 , 0), 359)/360;
                    var [r, g, b] = hsvからRgb(選択された色相, 1, 1);
                    var 選択色文字列_色相= "#"+[r, g, b].map(n => n.toString(16).padStart(2, '0')).join('');//各要素に対して、16進数にしたあとに2桁未満なら0を付けて、文字列結合する
                    今の色相.style.backgroundColor=選択色文字列_色相;
                    今の色相.style.left = 選択された色相*(キャンバスでかさ.width-parseFloat(CSSでかさ.borderLeftWidth)*2)+"px";//あってんの？まあいいけど

                    [r, g, b] = hsvからRgb(選択された色相, 選択された彩度, 選択された明度);
                    選択色文字列 = "#"+[r, g, b].map(n => n.toString(16).padStart(2, '0')).join('');//各要素に対して、16進数にしたあとに2桁未満なら0を付けて、文字列結合する
                    彩度エリアの表示(選択された色相);
                    
                }
                function 彩度変更(e){
                    if(isNaN(e.offsetX) || isNaN(e.offsetY)){//NaNだったら拒否
                        return;
                    }
                    var キャンバスでかさ = 彩度表示.getBoundingClientRect();
                    var CSSでかさ=getComputedStyle(彩度表示);
                    var x = Math.floor(e.offsetX/(キャンバスでかさ.width-parseFloat(CSSでかさ.borderLeftWidth)*2)*256);
                    var y = Math.floor(e.offsetY/(キャンバスでかさ.height-parseFloat(CSSでかさ.borderBottomWidth)*2)*256);
                    x=Math.min(Math.max(x , 0), 255);
                    y=Math.min(Math.max(y , 0), 255);
                    選択された彩度 = x / 255;
                    選択された明度 = 1 - y / 255;
                    var [r, g, b] = hsvからRgb(選択された色相, 選択された彩度, 選択された明度);
                    選択色文字列 = "#"+[r, g, b].map(n => n.toString(16).padStart(2, '0')).join('');//各要素に対して、16進数にしたあとに2桁未満なら0を付けて、文字列結合する
                    今の彩度.style.backgroundColor=選択色文字列;
                    今の色表示.style.backgroundColor=選択色文字列;
                    今の彩度.style.top = (1-選択された明度)*(キャンバスでかさ.height-parseFloat(CSSでかさ.borderBottomWidth)*2)+"px";
                    今の彩度.style.left = 選択された彩度*(キャンバスでかさ.width-parseFloat(CSSでかさ.borderLeftWidth)*2)+"px";
                }

                色参照スポイト.addEventListener("click",function(){
                    優先ツール="色参照スポイト";
                    色参照スポイト.classList.add("色参照スポイト_clicked");
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/supoito16.png),default"; // カスタムカーソルを適用
                })

                採用ボタン_color.addEventListener("click",function(){
                    カラーピッカー.style.display="none";
                    優先ツール="";
                    色参照スポイト.classList.remove("色参照スポイト_clicked");
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+現在のツール+"16.png),default"; // カスタムカーソルを適用
                    //数字に変換できるレイヤーなら通常色変更として処理
                    if(!isNaN(変更する色.layer)){
                        //作成した色に、変更する
                        選択色変更(選択色文字列, "color_" + 変更する色.layer + "_" + 変更する色.num);
                        //表示も合わせる
                        var radio_div要素 = document.getElementById("color_" + 現在の色.layer + "_" + 現在の色.num);
                        radio_div要素.querySelector(".radio").checked = true;
                        var input要素 = radio_div要素.querySelector(".色箱_input");
                        input要素.value =選択色文字列;
                        input要素.dispatchEvent(new Event("input"));//inputが変更されたことにすることができる
                    }else{
                        //まあ特殊な箱を選択してるんだろう
                        var div要素 = document.getElementById("color_" + 変更する色.layer + "_" + 変更する色.num);
                        var input要素 = div要素.querySelector(".色箱_input");
                        input要素.value =選択色文字列;
                        input要素.dispatchEvent(new Event("input"));//inputが変更されたことにすることができる
                    }
                    
                })

                破棄ボタン_color.addEventListener("click",function(){
                    カラーピッカー.style.display="none";
                    優先ツール="";                    
                    色参照スポイト.classList.remove("色参照スポイト_clicked");
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+現在のツール+"16.png),default"; // カスタムカーソルを適用
                })

                var カラーピッカー = document.getElementById("カラーピッカー");
                var クリックされたよ=false;
                カラーピッカー.addEventListener("pointerdown", function(e){
                    e.preventDefault();
                    クリックされたよ=true;
                });
                カラーピッカー.addEventListener("pointerup", function(e){
                    e.preventDefault();
                    クリックされたよ=false;
                });
                カラーピッカー.addEventListener("pointerleave", function(e){
                    e.preventDefault();
                    クリックされたよ=false;
                });
                
                色相バー.addEventListener("pointerdown", function(e){
                    e.preventDefault();
                    色相変更(e);   
                });
                色相バー.addEventListener("pointermove", function(e){
                    e.preventDefault();
                    if(クリックされたよ){
                        色相変更(e);
                    }
                });
                色相バー.addEventListener("touchmove", function(e) {
                    e.preventDefault();
                    色相変更(e);
                });

                彩度表示.addEventListener("pointerdown", function(e){
                    e.preventDefault();
                    彩度変更(e);   
                });
                彩度表示.addEventListener("pointermove", function(e){
                    e.preventDefault();
                    if(クリックされたよ){
                        彩度変更(e);
                    }
                });
                彩度表示.addEventListener("touchmove", function(e) {
                    e.preventDefault();
                    彩度変更(e);
                });

                //ここから色置換の実装ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
                var スワップメニュー=document.getElementById("スワップメニュー");
                var 採用ボタン_swap=document.getElementById("採用ボタン_swap");
                var 破棄ボタン_swap=document.getElementById("破棄ボタン_swap");

                var 置換される色_input=document.getElementById("color_pick_swap_0");
                var 置換する色_input=document.getElementById("color_pick_swap_1");

                function キャンバス色置換(){
                    //仮置きしてる場合があるので打ち消す。え？メニュー開いてから描いた絵はどうなるかって？そんなもんは消え去る。
                    ctx_0.putImageData(一時保存用キャンバス_0, 0, 0);
                    ctx_1.putImageData(一時保存用キャンバス_1, 0, 0);

                    var 置換する色={
                        r:parseInt(置換する色_input.value.slice(1,3),16),
                        g:parseInt(置換する色_input.value.slice(3,5),16),
                        b:parseInt(置換する色_input.value.slice(5,7),16)
                    };
                    var 置換される色={
                        r:parseInt(置換される色_input.value.slice(1,3),16),
                        g:parseInt(置換される色_input.value.slice(3,5),16),
                        b:parseInt(置換される色_input.value.slice(5,7),16)
                    };
                    //canvas_0とcanvas_1の色を置換する
                    var canvas_0_imgData = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    var canvas_1_imgData = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                    var data_0 = canvas_0_imgData.data;
                    var data_1 = canvas_1_imgData.data;
                    for (var i = 0; i < data_0.length; i += 4) {
                        //レイヤー0は透明だったら無視
                        if (data_0[i + 3] != 0) {
                            if (data_0[i] === 置換される色.r && data_0[i + 1] === 置換される色.g && data_0[i + 2] === 置換される色.b) {
                                data_0[i] = 置換する色.r;
                                data_0[i + 1] = 置換する色.g;
                                data_0[i + 2] = 置換する色.b;
                                
                            }
                        }
                        if (data_1[i] === 置換される色.r && data_1[i + 1] === 置換される色.g && data_1[i + 2] === 置換される色.b) {
                            data_1[i] = 置換する色.r;
                            data_1[i + 1] = 置換する色.g;
                            data_1[i + 2] = 置換する色.b;
                        }
                    }
                    ctx_0.putImageData(canvas_0_imgData, 0, 0);
                    ctx_1.putImageData(canvas_1_imgData, 0, 0);
                }

                採用ボタン_swap.addEventListener("click",function(){
                    スワップメニュー.style.display="none";              
                    キャンバス色置換();
                    履歴残し();
                    //このあと同じ色の色箱も色を変えようか考えたけど、まあそれが嫌な時もあるしいいかとしました。
                })

                仮置ボタン_swap.addEventListener("click",function(){
                    キャンバス色置換();
                })

                破棄ボタン_swap.addEventListener("click",function(){
                    スワップメニュー.style.display="none";
                })

                //ここからパレットチェンジの実装ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
                var パレットメニュー=document.getElementById("パレットメニュー");
                var 閉じる_paretto=document.getElementById("閉じる_paretto");

                //パレットは4セットでいいか…
                var パレットセット=[
                    ["#ffffff","#000000","#00FFFF","#ffffff","#FF5558","#FFF6EF"],
                    ["#ffffff","#4fafd0","#df4040","#c0ffff","#7fdfff","#ffcfcf"],
                    ["#ffffff","#2e8b57","#8b4513" , "#c1f0d1","#66cdaa" , "#deb887"],
                    ["#ffffff","#B22222","#228B22","#1E90FF","#FFD700","#DA70D6"]
                ];

                function パレット色反映(){
                    for (let area = 0; area < 4; area++) {
                        const colors = パレットセット[area];
                        for (let row = 0; row < 2; row++) {
                            for (let col = 0; col < 3; col++) {
                                const box = document.getElementById(`paretto_${area}_${row}_${col}`);

                                box.style.backgroundColor = colors[row * 3 + col];
                                
                            }
                        }
                    }
                }
                //いったん動かすけど、ロード時にも動かすよん
                パレット色反映();
                //パレットメニュー.style.display="flex";

                var パレット採用=document.querySelectorAll('.パレット採用');
                パレット採用.forEach(function(ボタン){
                    ボタン.addEventListener('click', function() {
                        const oldLayer = 現在の色.layer;
                        const oldNum   = 現在の色.num;
                        const area = Number(ボタン.getAttribute('エリア'));
                        const colors = パレットセット[area];
                        // レイヤー0
                        for (let i = 0; i < 3; i++) {
                            const input = document.getElementById(`color_pick_0_${i}`);
                            input.value = colors[i];
                            input.dispatchEvent(new Event("input"));
                            
                        }
                        // レイヤー1
                        for (let i = 0; i < 3; i++) {
                            const input = document.getElementById(`color_pick_1_${i}`);
                            input.value = colors[i + 3];
                            input.dispatchEvent(new Event("input"));
                        }
                        //選択してた場所をもどすよ！え？雑？そういうこともあるさ
                        document.getElementById(`color_pick_${oldLayer}_${oldNum}`).dispatchEvent(new Event("input"));
                        パレットメニュー.style.display="none";
                    });
                })

                var パレット保存=document.querySelectorAll('.パレット保存');
                パレット保存.forEach(function(ボタン){
                    ボタン.addEventListener('click', function() {
                        const oldLayer = 現在の色.layer;
                        const oldNum   = 現在の色.num;
                        const area = Number(ボタン.getAttribute('エリア'));
                        const colors = パレットセット[area];
                        // レイヤー0
                        for (let i = 0; i < 3; i++) {
                            const input = document.getElementById(`color_pick_0_${i}`);
                            colors[i]=input.value;
                            
                        }
                        // レイヤー1
                        for (let i = 0; i < 3; i++) {
                            const input = document.getElementById(`color_pick_1_${i}`);
                            colors[i + 3]=input.value;
                        }
                        パレット色反映();
                        パレット全保存();
                    });
                })


                閉じる_paretto.addEventListener("click",function(){
                    パレットメニュー.style.display="none";
                });

                //ここから絵の移動・拡大縮小ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
                let 四隅クリック中 = false;
                let 移動クリック中 = false;
                let 変形終わったらツール戻してください = false;
                let corner = "";
                let クリック開始位置_move = { x: 0, y: 0 };

                // 大きさ変更できる四隅にイベントリスナーを追加
                ["左上", "右上", "左下", "右下"].forEach(cornerName => {
                    const handle = document.getElementById("移動UI_大きさ_"+cornerName );
                    handle.addEventListener("pointerdown", function(e){
                        e.preventDefault();
                        四隅クリック中 = true;
                        corner = cornerName;
                    });
                });

                var 移動UI_大きさ = document.getElementById("移動UI_大きさ");
                移動UI_大きさ.addEventListener("pointerdown", function(e) {
                    e.preventDefault();
                    移動クリック中 = true;
                    if (e.touches) {//これ指じゃね？
                        クリック開始位置_move = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }else {//マウスだわ
                        クリック開始位置_move = { x: e.clientX, y: e.clientY };
                    }
                    
                });
                


                function 四隅拡大縮小移動(e){
                    let rect_UI_大きさ = window.getComputedStyle(移動UI_大きさ);
                    var mx,my,dx,dy;
                    if (e.touches) {//これ指じゃね？
                        mx = e.touches[0].clientX;
                        my = e.touches[0].clientY;
                    }else {//マウスだわ
                        mx = e.clientX;
                        my = e.clientY;
                    }
                    //document.getElementById("デバッグ用").textContent =[dx,dy];
                
                    if(四隅クリック中){                       
                        let rect;
                        if(corner === "左上") {
                            rect = document.getElementById("移動UI_大きさ_左上").getBoundingClientRect();
                        } else if(corner === "右上") {
                            rect = document.getElementById("移動UI_大きさ_右上").getBoundingClientRect();
                        } else if(corner === "左下") {
                            rect = document.getElementById("移動UI_大きさ_左下").getBoundingClientRect();
                        } else if(corner === "右下") {
                            rect = document.getElementById("移動UI_大きさ_右下").getBoundingClientRect();
                        }

                        let 中心_x = rect.left + rect.width / 2;
                        let 中心_y = rect.top + rect.height / 2;
                        if(corner === "左上") {
                            dx = mx-中心_x ;
                            dy = my-中心_y ;
                        } else if(corner === "右上") {
                            dx = -mx+中心_x ;
                            dy = my-中心_y ;
                        } else if(corner === "左下") {
                            dx = mx-中心_x ;
                            dy = -my+中心_y ;
                        } else if(corner === "右下") {
                            dx = -mx+中心_x ;
                            dy = -my+中心_y ;
                        }
                        //console.log("四隅拡大縮小移動", corner, dx,dy )
                        
                        //あんまり小さいときは小さくなり過ぎないようにする
                        if (parseFloat(rect_UI_大きさ.width)- dx*2 < 50) {
                            dx = parseFloat(rect_UI_大きさ.width) / 2 - 25; // 最小幅を50pxに設定
                        }
                        if (parseFloat(rect_UI_大きさ.height)- dy*2 < 50) {
                            dy = parseFloat(rect_UI_大きさ.height) / 2 - 25; // 最小高さを50pxに設定
                        }
                        
                        移動UI_大きさ.style.width =(parseFloat(rect_UI_大きさ.width)- dx*2)+ "px";
                        移動UI_大きさ.style.height =(parseFloat(rect_UI_大きさ.height)- dy*2) + "px";

                        移動UI_大きさ.style.left = (parseFloat(rect_UI_大きさ.left)+dx) + "px";
                        移動UI_大きさ.style.top = (parseFloat(rect_UI_大きさ.top)+dy)  + "px";

                    }else if(移動クリック中){
                        dx=mx-クリック開始位置_move.x;
                        dy=my-クリック開始位置_move.y;
                        クリック開始位置_move = { x: mx, y: my };//クリック位置を更新
                        移動UI_大きさ.style.left = (parseFloat(rect_UI_大きさ.left)+dx) + "px";
                        移動UI_大きさ.style.top = (parseFloat(rect_UI_大きさ.top)+dy)  + "px";
                    }
                    rect_UI_大きさ = window.getComputedStyle(移動UI_大きさ);
                    //console.log("四隅拡大縮小移動",rect_UI_大きさ.left, rect_UI_大きさ.top, rect_UI_大きさ.width, rect_UI_大きさ.height);
                    キャンバス絵を変形({ dx:parseFloat(rect_UI_大きさ.left), dy: parseFloat(rect_UI_大きさ.top), width: parseFloat(rect_UI_大きさ.width), height: parseFloat(rect_UI_大きさ.height), rotate:0, layer: 0 });
                    キャンバス絵を変形({ dx:parseFloat(rect_UI_大きさ.left), dy: parseFloat(rect_UI_大きさ.top), width: parseFloat(rect_UI_大きさ.width), height: parseFloat(rect_UI_大きさ.height), rotate:0, layer: 1 });
                }

                function キャンバス絵を変形({ dx = 0, dy = 0, width = 100,height=100, rotate = 0, layer = 0 }) {
                    const canvas = (layer === 0) ? canvas_0 : canvas_1;
                    const ctx = canvas.getContext("2d");
                    ctx.imageSmoothingEnabled = false;//アンチ　アンチエイリアス

                    // 一時保存用キャンバスから画像データを取得
                    const imgData = (layer === 0) ? 一時保存用キャンバス_0 : 一時保存用キャンバス_1;

                    // 一時キャンバスを作成し、imgDataを描画
                    const tmpCanvas = document.createElement("canvas");
                    tmpCanvas.width = canvas.width;
                    tmpCanvas.height = canvas.height;
                    const tmpCtx = tmpCanvas.getContext("2d");
                    tmpCtx.imageSmoothingEnabled = false;//アンチ　アンチエイリアス
                    tmpCtx.putImageData(imgData, 0, 0);

                    // レイヤーごとにクリア方法を変える
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (layer === 1) {
                        ctx.save();
                        ctx.fillStyle = document.getElementById("color_pick_1_0").value;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();
                    }

                    // 変形して描画
                    ctx.save();//ペンの色とか保存する
                    ctx.translate(canvas.width / 2, canvas.height / 2 );//操作をキャンパス中心に指定。…回転するし
                    // 回転→拡大縮小→移動の順
                    ctx.rotate(rotate); // ラジアン単位

                    ctx.translate(-canvas.width / 2, -canvas.height / 2 );//操作をキャンパス左上に指定。…移動するし

                    //もと画像から 0,0,tmpCanvas.width,tmpCanvas.height,　で切り出して
                    //置く場所、置く大きさを指定。
                    ctx.drawImage(
                        tmpCanvas,  
                        0,0,tmpCanvas.width,tmpCanvas.height,
                        Math.floor( +dx),  Math.floor( +dy),
                        Math.floor(width), Math.floor(height),
                    );

                    ctx.restore();//ペンの色とか呼び出す
                }

                function 四隅拡大縮小終了(){
                    四隅クリック中 = false;
                    移動クリック中 = false;
                    if (変形終わったらツール戻してください) {
                        変形終わったらツール戻してください = false;
                        //ペンに切り替えればいいか
                        自動ツール選択("pen");
                    }
                }

                var 採用ボタン_move=document.getElementById("採用ボタン_move");
                var 破棄ボタン_move=document.getElementById("破棄ボタン_move");

                //"click"イベントだと動かない。理由は知らん。こんな意味不明なプログラムを解析したくねえしな！ドン
                採用ボタン_move.addEventListener("pointerdown",function(){
                    履歴残し();
                    変形終わったらツール戻してください = true;
                });

                破棄ボタン_move.addEventListener("pointerdown",function(){
                    変形終わったらツール戻してください=true;
                    
                });

                //ここから保存とかーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

                //ページ下部のツイートボタンを上書き
                document.getElementById("foot_tweet_a").href=URL_tweet_text="https://twitter.com/intent/tweet?hashtags=deyukaki";           


                //canvasとか色箱を保存しようぜ！！！！！！！！！！！

                function IndexedDBを開くぞ() {
                    return new Promise((resolve, reject) => { //非同期で動くので、awaitできるようにしておく
                        const request = indexedDB.open("DeyukakiDB", 3);//バージョンnで開く、もしくは生成
                        
                        request.onupgradeneeded = function (event) {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains("canvasData")) {
                                db.createObjectStore("canvasData", { keyPath: "id" });//canvas
                            }
                            if (!db.objectStoreNames.contains("colorData")) {
                                db.createObjectStore("colorData", { keyPath: "id" });//色箱
                            }
                            if (!db.objectStoreNames.contains("hutosaData")) {
                                db.createObjectStore("hutosaData", { keyPath: "id" });//太さ
                            }
                            if (!db.objectStoreNames.contains("parettoData")) {
                                db.createObjectStore("parettoData", { keyPath: "id" });//パレットセット
                            }
                        };
                        request.onsuccess = function (event) {
                            resolve(event.target.result); // データベースを返す
                        };

                        request.onerror = function (event) {
                            resolve(event.target.result); // データベースを返す…失敗してるけどな！
                        };
                    });
                }

                async function Canvas保存() {
                    const db = await IndexedDBを開くぞ();
                    const transaction = db.transaction("canvasData", "readwrite");
                    const store = transaction.objectStore("canvasData");

                    const canvas0Data = canvas_0.toDataURL();
                    const canvas1Data = canvas_1.toDataURL();

                    store.put({ id: "canvas_0", data: canvas0Data });
                    store.put({ id: "canvas_1", data: canvas1Data });
                    console.log("キャンバス保存完了");
                }

                async function 色箱保存(保存要素名) {
                    const db = await IndexedDBを開くぞ();
                    const transaction = db.transaction("colorData", "readwrite");
                    const store = transaction.objectStore("colorData");

                    const colorInputs = document.querySelectorAll(".色箱_input");
                    colorInputs.forEach((input, index) => {
                        if(保存要素名==input.parentElement.parentElement.id){
                            store.put({ id: 保存要素名, value: input.value });
                            return;
                        }
                    });
                    //なんか余計なものまで保存されてないかだって？ハッハッハ、そうだぜ。
                }

                async function 太さ保存() {
                    const db = await IndexedDBを開くぞ();
                    const transaction = db.transaction("hutosaData", "readwrite");
                    const store = transaction.objectStore("hutosaData");

                    store.put({ id: "消しゴム太さ", data: 消しゴム太さ });
                    store.put({ id: "筆太さ", data: 筆太さ });
                }

                async function パレット全保存() {
                    const db = await IndexedDBを開くぞ();
                    const transaction = db.transaction("parettoData", "readwrite");
                    const store = transaction.objectStore("parettoData");

                    パレットセット.forEach((colors, area) => {
                        store.put({ id: area, data: パレットセット[area] });                        
                    });
                }

                async function 読み込み() {
                    const db = await IndexedDBを開くぞ();

                    const canvasTransaction = db.transaction("canvasData", "readonly");
                    const canvasStore = canvasTransaction.objectStore("canvasData");

                    const canvas0Promise = new Promise((resolve) => {
                        const canvas0Request = canvasStore.get("canvas_0");
                        canvas0Request.onsuccess = function () {
                            if (canvas0Request.result) {
                                const img = new Image();
                                img.onload = function () {
                                    ctx_0.drawImage(img, 0, 0);
                                    resolve(); // ロード完了を通知
                                };
                                img.src = canvas0Request.result.data;
                            } else {
                                resolve(); // データがなくても完了を通知
                            }
                        };
                    });

                    const canvas1Promise = new Promise((resolve) => {
                        const canvas1Request = canvasStore.get("canvas_1");
                        canvas1Request.onsuccess = function () {
                            if (canvas1Request.result) {
                                const img = new Image();
                                img.onload = function () {
                                    ctx_1.drawImage(img, 0, 0);
                                    resolve(); // ロード完了を通知
                                };
                                img.src = canvas1Request.result.data;
                            } else {
                                resolve(); // データがなくても完了を通知
                            }
                        };
                    });

                    // 両方のキャンバスがロード完了したら履歴を残す
                    await Promise.all([canvas0Promise, canvas1Promise]);
                    履歴残し(true);//trueにしておけば保存までは動かない。

                    const hutosaTransaction = db.transaction("hutosaData", "readonly");
                    const hutosaStore = hutosaTransaction.objectStore("hutosaData");

                    const 消しゴム太さPromise = new Promise((resolve) => {   
                        const 消しゴム太さRequest=hutosaStore.get("消しゴム太さ");
                        消しゴム太さRequest.onsuccess = function () {
                            if (消しゴム太さRequest.result) {
                                消しゴム太さ = 消しゴム太さRequest.result.data;
                                resolve(); // ロード完了を通知
                            } else {
                                消しゴム太さ = 5; // デフォルト値
                                resolve(); // データがなくても完了を通知
                            }
                        };
                    });
                    
                    const 筆太さPromise = new Promise((resolve) => {   
                        const 筆太さRequest=hutosaStore.get("筆太さ");
                        筆太さRequest.onsuccess = function () {
                            if (筆太さRequest.result) {
                                筆太さ = 筆太さRequest.result.data;
                                太さ.value = 筆太さ;//0_1が常に選ばれるのでこれでいい。
                                resolve(); // ロード完了を通知
                            } else {
                                筆太さ = 5; // デフォルト値
                                太さ.value = 筆太さ;//0_1が常に選ばれるのでこれでいい。
                                resolve(); // データがなくても完了を通知
                            }
                        };
                    });
                    筆太さRequest=hutosaStore.get("筆太さ");

                    await Promise.all([消しゴム太さPromise, 筆太さPromise]);
                    太さからスライダー位置調整();//スライダー初期化。


                    const colorTransaction = db.transaction("colorData", "readonly");
                    const colorStore = colorTransaction.objectStore("colorData");

                    const colorInputs = document.querySelectorAll(".色箱_input");
                    colorInputs.forEach((input) => {
                        const request = colorStore.get(input.parentElement.parentElement.id);
                        request.onsuccess = function () {
                            if (request.result) {
                                input.value = request.result.value;
                                input.dispatchEvent(new Event("input")); // これでinputが変更されたことにできる
                            }
                        };
                    });

                    const parettoTransaction = db.transaction("parettoData", "readonly");
                    const parettoStore = parettoTransaction.objectStore("parettoData");

                    const parettoPromises = パレットセット.map((_, area) => {//読み込むものの数だけ非同期で動くので配列生成
                        return new Promise((resolve) => {
                            const request = parettoStore.get(area);
                            request.onsuccess = function () {
                                if (request.result && Array.isArray(request.result.data)) {
                                    パレットセット[area] = request.result.data;
                                }
                                resolve();//ロード完了を通知
                            };
                            request.onerror = function () {
                                resolve(); // エラーでも進める
                            };
                        });
                    });
                    await Promise.all(parettoPromises);
                    パレット色反映();

                }
                読み込み();

                /*
                //ページを閉じるときに保存…と思いきや、非同期処理は間に合わないとのこと。とほほ
                window.addEventListener("beforeunload", async function () {
                    await Canvas保存();
                    await 色箱保存();
                });
                */
                var 保存タイマー;
                function Canvas保存タイマー開始() {
                    if (保存タイマー) {
                        clearTimeout(保存タイマー); // タイマーがあればリセット
                    }
                    保存タイマー = setTimeout(() => {
                        Canvas保存();
                    }, 5000); // 最後の書き込みからn秒後に保存
                }
            }
        </script>
    </head>
    <body>
        <div id="top"></div>
        <header id="header">
            <button onclick="html_link_btn()" id="html_link_btn"></button>
            <nav id="html_link_nav">
                <ul id="html_link_ul"></ul>
            </nav>
            <a href="../index.html">
                <img id="go_home" src="../images/site/omotyabako_deka.png" alt="トップページへ" height="1px"><!--ここで高さを入れておかないと、クソでかい画像が一瞬読み込まれてボタンの大きさが暴走する-->
            </a>
            <h1 id="title_h1">
                JUN汁ｗおもちゃばこ。
            </h1>
        </header>
        <div id="mannaka">
            <div id="三分割くん">
                <div id="左分割" class="浮かせる">
                    <div id="左最小化領域">
                        <div id="色選択div">
                            <div id="color_0" class="color_行">
                                <div class="縦並べ">
                                    <img src="../images/omocha/deyukaki/layer16_0.png" alt="ここはレイヤー0の色選択" class="img_layer">
                                    <input type="checkbox" class="radio lockボタン ペンボタン" id="lock_0">
                                </div>
                                
                                <div class="radio_div" id="color_0_0">
                                    <input type="radio" class="radio" id="color_radio_0_0" name="color">
                                    <div class="色箱" id="color_div_0_0">
                                        <input class="色箱_input" type="color" id="color_pick_0_0" value="#ffffff" disabled style="visibility: hidden;"><!--色変え拒否-->
                                        <div class="色箱_cover 透明色だよ"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_0_1">
                                    <input type="radio" class="radio" id="color_radio_0_1" name="color" checked>
                                    <div class="色箱" id="color_div_0_1">
                                        <input class="色箱_input" type="color" id="color_pick_0_1" value="#000000">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_0_2">
                                    <input type="radio" class="radio" id="color_radio_0_2" name="color">
                                    <div class="色箱" id="color_div_0_2">
                                        <input class="色箱_input" type="color" id="color_pick_0_2" value="#00FFFF">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>
                            </div>

                            <div id="color_1" class="color_行">
                                
                                <div class="縦並べ">
                                    <img src="../images/omocha/deyukaki/layer16_1.png" alt="ここはレイヤー1の色選択" class="img_layer">
                                    <input type="checkbox" class="radio lockボタン ペンボタン" id="lock_1">
                                </div>
                                <div class="radio_div" id="color_1_0">
                                    <input type="radio" class="radio" id="color_radio_1_0" name="color">
                                    <div class="色箱" id="color_div_1_0">
                                        <input class="色箱_input" type="color" id="color_pick_1_0" value="#ffffff">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_1_1">
                                    <input type="radio" class="radio" id="color_radio_1_1" name="color">
                                    <div class="色箱" id="color_div_1_1">
                                        <input class="色箱_input" type="color" id="color_pick_1_1" value="#FF5558">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_1_2">
                                    <input type="radio" class="radio" id="color_radio_1_2" name="color">
                                    <div class="色箱" id="color_div_1_2">
                                        <input class="色箱_input" type="color" id="color_pick_1_2" value="#FFF6EF">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>

                            </div>
                        </div>
                        <div id="ツール系">
                            <div id="筆の太さ">
                                <div>
                                    <label for="太さ">太さ：</label>
                                    <input type="number" id="太さ" min="1" max="100" value="5">
                                    <button id="太さ減" class="太さボタン" type="button">-</button>
                                    <button id="太さ増" class="太さボタン" type="button">+</button>
                                </div>
                                <input type="range" id="slider太さ" min="1" max="100" value="12" step="1">
                                <!--12なんだけど計算すると5pxになる。まあここは初期化してるのでなんでもいいんですが…-->
                            </div>
                            <div id="ツール選択">
                                <label id="pen">
                                    <input type="radio" name="tool" class="tool_radio" id="ペン" value="pen" checked>
                                    <span class="ペンボタン" id="ペン_ボタン"></span>
                                </label>
                                <label id="baketu">
                                    <input type="radio" name="tool" class="tool_radio" id="バケツ" value="bucket">
                                    <span class="ペンボタン" id="バケツ_ボタン"></span>
                                </label>
                                <label id="supoito">
                                    <input type="radio" name="tool" class="tool_radio" id="スポイト" value="supoito">
                                    <span class="ペンボタン" id="スポイト_ボタン"></span>
                                </label>
                                <label id="move">
                                    <input type="radio" name="tool" class="tool_radio" id="移動" value="move">
                                    <span class="ペンボタン" id="移動_ボタン"></span>
                                </label>
                            </div>
                            <label id="swap">
                                <span class="ペンボタン" id="スワップ_ボタン"></span>
                            </label>
                            <label id="paretto">
                                <span class="ペンボタン" id="パレット_ボタン"></span>
                            </label>
                            
                        </div>
                    </div>
                    
                    <button id="左最小化"><</button>
                    
                </div>

                <div id="真ん中分割">
                    <div id="スクロールサイズ調整">    
                        <canvas id="cnvs_1" class="描画用" height="450px" width="600px"><!--styleのheigthは見た目の大きさを変えているにすぎない。表示領域はcssじゃない。-->
                        </canvas>      
                        <canvas id="cnvs_0" class="描画用" height="450px" width="600px"><!--styleのheigthは見た目の大きさを変えているにすぎない。表示領域はcssじゃない。-->
                        </canvas>       
                        <div id="移動UI">
                            <div id="移動UI_ボタン群">
                                <input id="採用ボタン_move" type="button" value="採用" class="色選択ボタン 採用ボタン">
                                <input id="破棄ボタン_move" type="button" value="破棄" class="色選択ボタン 破棄ボタン">
                            </div>
                            <div id="移動UI_大きさ">
                                <div class="resize-handle" id="移動UI_大きさ_左上"></div>
                                <div class="resize-handle" id="移動UI_大きさ_右上"></div>
                                <div class="resize-handle" id="移動UI_大きさ_左下"></div>
                                <div class="resize-handle" id="移動UI_大きさ_右下"></div>
                            </div>
                            
                        </div>   
                    </div>

                </div>
                
                
                <div id="右分割"class="浮かせる">
                    <div id="デバッグ用">test</div>
                    <button id="右最小化">></button>
                    <div id="右最小化領域">
                        <button id="描き戻しボタン" class="保存系ボタン">↶</button>
                        <button id="やり直しボタン" class="保存系ボタン">↷</button>
                        <button id="コピーボタン" class="保存系ボタン">コピー</button>
                        <button id="保存" class="保存系ボタン">保存</button>
                        <button id="白紙" class="保存系ボタン">左色で埋める</button>
                    </div>

                </div>

                <div id="カラーピッカー">
                    <div id="カラピカ上段">
                        <div id="今の色">
                            <div id="今の色表示"></div>
                            <input id="色参照スポイト" class="色選択ボタン">
                            <input id="採用ボタン_color" type="button" value="採用" class="色選択ボタン 採用ボタン">
                            <input id="破棄ボタン_color" type="button" value="破棄" class="色選択ボタン 破棄ボタン">
                        </div>
                        <div id="彩度選択div">
                            <canvas id="彩度選択" width="256px" height="256px"></canvas>
                            <div id="今の彩度" class="色選択ガイド"></div>
                        </div>
                    </div>
                    <div id="色相選択div">
                        <canvas id="色相選択" width="360px" height="1px"></canvas>
                        <div id="今の色相" class="色選択ガイド"></div>
                    </div>
                </div>

                <div id="スワップメニュー">
                    <div id="スワメニュ上段">
                        <div>
                            変更する色
                            <div class="radio_div" id="color_swap_0">
                                <div class="色箱" id="color_div_swap_0">
                                    <input class="色箱_input" type="color" id="color_pick_swap_0" value="#ff0000">
                                    <div class="色箱_cover"></div>
                                </div>
                            </div>
                        </div>
                        <div>
                            →→→
                        </div>
                        <div>
                            置換先
                            <div class="radio_div" id="color_swap_1">
                                <div class="色箱" id="color_div_swap_1">
                                    <input class="色箱_input" type="color" id="color_pick_swap_1" value="#00ff00">
                                    <div class="色箱_cover"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="スワメニュ下段">
                        <input id="採用ボタン_swap" type="button" value="置換" class="色選択ボタン 採用ボタン">
                        <input id="破棄ボタン_swap" type="button" value="破棄" class="色選択ボタン 破棄ボタン">
                        <input id="仮置ボタン_swap" type="button" value="仮置" class="色選択ボタン その他ボタン">
                    </div>
                </div>

                <div id="パレットメニュー">
                    <!--パレットを4セット、上下左右に配置-->
                    <div class ="パレットエリア_上下">
                        <div class="パレットエリア">
                            <div class="パレットエリア_段">
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover 透明色だよ paretto色箱" id="paretto_0_0_0"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_0_0_1"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_0_0_2"></div>
                                </div>
                            </div>
                            <div class="パレットエリア_段">
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_0_1_0"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_0_1_1"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_0_1_2"></div>
                                </div>
                            </div>
                            <div class="パレットエリア_段">
                                <input type="button" エリア=0 value="使う" class="色選択ボタン 採用ボタン パレット採用">
                                <input type="button" エリア=0 value="保存" class="色選択ボタン 破棄ボタン パレット保存">
                            </div>

                        </div>
                        <div class="パレットエリア">
                            <div class="パレットエリア_段">
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover 透明色だよ paretto色箱" id="paretto_1_0_0"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_1_0_1"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_1_0_2"></div>
                                </div>
                            </div>
                            <div class="パレットエリア_段">
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_1_1_0"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_1_1_1"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_1_1_2"></div>
                                </div>
                            </div>
                            <div class="パレットエリア_段">
                                <input type="button" エリア=1 value="使う" class="色選択ボタン 採用ボタン パレット採用">
                                <input type="button" エリア=1 value="保存" class="色選択ボタン 破棄ボタン パレット保存">
                            </div>
                        </div>
                    </div>
                    <div class ="パレットエリア_上下">
                        <div class="パレットエリア">
                            <div class="パレットエリア_段">
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover 透明色だよ paretto色箱" id="paretto_2_0_0"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_2_0_1"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_2_0_2"></div>
                                </div>
                            </div>
                            <div class="パレットエリア_段">
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_2_1_0"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_2_1_1"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_2_1_2"></div>
                                </div>
                            </div>
                            <div class="パレットエリア_段">
                                <input type="button" エリア=2 value="使う" class="色選択ボタン 採用ボタン パレット採用">
                                <input type="button" エリア=2 value="保存" class="色選択ボタン 破棄ボタン パレット保存">
                            </div>
                        </div>
                        <div class="パレットエリア">
                            <div class="パレットエリア_段">
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover 透明色だよ paretto色箱" id="paretto_3_0_0"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_3_0_1"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_3_0_2"></div>
                                </div>
                            </div>
                            <div class="パレットエリア_段">
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_3_1_0"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_3_1_1"></div>
                                </div>
                                <div class="中身のない色箱表示のための親">
                                    <div class="色箱_cover paretto色箱" id="paretto_3_1_2"></div>
                                </div>
                            </div>

                            <div class="パレットエリア_段">
                                <input type="button" エリア=3 value="使う" class="色選択ボタン 採用ボタン パレット採用">
                                <input type="button" エリア=3 value="保存" class="色選択ボタン 破棄ボタン パレット保存">
                            </div>    
                        </div> 
                        
                    </div>

                    <div id="パレメニュ下段">
                       <input id="閉じる_paretto" type="button" value="×" class="色選択ボタン 破棄ボタン">
                    </div>
                </div>

            </div>



            <footer>
                <ul id="footul">
                    <li id="foot_tweet_li">
                        <a href=""  target="_blank" rel="noopener noreferrer" id="foot_tweet_a"><!--onload_functions()でhrefを書き込んでるで！-->
                            <img src="../images/site/twitterbutton.gif" alt="ツイートボタン" id="tweet_img">
                        </a>
                    </li>
                    <li>
                        <a href="./deyukaki_setumeisyo.html" target="_blank">このツールの説明書はここにあるよー！（別タブ）</a>
                    </li>
                </ul>
            </footer>
            <div id="マウス追従" calss="マウス追従"></div>
        </div>
    </body>
</html>
