<!DOCTYPE html>
<html lang="ja">
    <head prefix="og: http://ogp.me/ns# website: http://ogp.me/ns/website#">
        <meta charset="UTF-8">
        <!--文字コードは上のほうにないとすべておしまいになるらしい-->
        <meta name="description" content="でゆっち用お絵描きソフトウェア #deyukaki">                                                                 <!--ページ説明　入力すること！-->
        <title>JUN汁ｗおもちゃばこ。/おもちゃ/でゆ描き</title>                                                         <!--タイトル　入力すること！-->
        <!--OGPとかいうの-->
        <meta property="og:site_name" content="JUN汁ｗおもちゃばこ。/omocha/deyukaki">                                <!--タイトル　入力すること！-->
        <meta property="og:title" content="でゆ描き">                                                               <!--タイトル　入力すること！-->
        <meta property="og:type" content="article"> <!--websiteはトップページ、articleが記事だってさ-->
        <meta property="og:url" content="https://junjiruw.github.io/DEYUTI/omocha/deyukaki.html">                   <!--リンク　入力すること！-->
        <meta property="og:image" content="https://github.com/junjiruw/DEYUTI/blob/master/images/site/junjiruw_bako.png?raw=true">
        <meta name="twitter:card" content="summary"><!--なにを表示するか-->
        <meta name="twitter:site" content="@junjiruw"><!--フッターに表示されるらしい…どこ？-->
        <meta name="viewport" content="width=device-width,initial-scale=1"><!--スマホで見てる人向けに表示領域の設定-->
        <link rel="stylesheet" href="../css/style.css">
        
        <link rel="icon" href="../images/site/favicon32.png">
        <style>
            header{
                position: static;/*fixedじゃなくするとpublic.js内の処理をスキップするよん*/
                
            }
            #html_link_nav{
                z-index: 20; /* 高い値を指定して上に表示 */
            }
            div#mannaka{
                width: 100%;
                margin: 0.5em 0px 0.5em 0px;
                border: 2px solid #ffffff;
                color: #ffffff;   
                font-size: 16px;    
            }
            #三分割くん {
                position: relative;
                height: 100%; /* 親要素の高さに合わせる */
            }

            #真ん中分割 {
                width: 100%;
                height: 100%; /* 親要素の高さに合わせる */
                text-align: center;
                overflow: scroll;
                cursor: url("../images/omocha/deyukaki/pen16.png"),default; /* カスタムカーソル画像 */
            }
            /* スクロールバーの幅を指定 */
            #真ん中分割::-webkit-scrollbar {
                width: 1em; /* 垂直スクロールバーの幅 */
                height: 1em; /* 水平スクロールバーの高さ */
            }
            #真ん中分割::-webkit-scrollbar-track {
                background: #757575;
            }
            #真ん中分割::-webkit-scrollbar-thumb {
                background: #dadada;
                border-radius: 6px;
            }
            #真ん中分割::-webkit-scrollbar-thumb:hover {
                background: #b4b4b4;
            }
            
            #スクロールサイズ調整 {
                position: relative;
                z-index: 1; /* 邪魔なので一番奥に。*/
            }

            canvas {
                position: absolute;
                transform-origin: top left; /* 拡大縮小の基準点を左上に設定 */
                top:0;
                left:0;
                background-clip: padding-box;/*背景色がborderまでいかないようになる*/
                image-rendering: pixelated;/* 画像の拡大縮小時にピクセルを強調する */
                
            }

            .浮かせる {
                position: absolute;
                top: 0;
                background: #555;
                color: #fff;
                
                display: flex;
                justify-content: center;/* 2分割くんの中身を真ん中によせる */
            }

            #左分割 {
                left: 0;
                z-index: 10; /* 高い値を指定して上に表示 */
            }

            #右分割 {
                right: 1em;
                z-index: 10; /* 高い値を指定して上に表示 */
            }

            #左最小化領域 {
                display: flex; /* 子要素を横並びにする */
            }
            .color_行{
                display: flex; /* 子要素を横並びにする */
            }
            #raido_0 {
                display: flex; /* 子要素を横並びにする */
            }
            .radio_div{
                display: flex;
                flex-direction: column; /* ラジオボタンとラベルを縦に並べる */
                align-items: center; /* 中央揃え */
            }

            .radio{
                display: inline-block;
                width: 1em;
                height: 1em;
                border: 2px solid #aaa;
                background-color: #fff;
                border-radius: 50%;
            }
            .radio:checked{
                background-color: rgb(80, 160, 255);
            }
            .色箱{
                position: relative;
                margin: 0.2em;
            }
            .色箱_input {
                position: relative;
                width: 1.5em;
                height: 1.5em;
            }
            .色箱_cover{
                position: absolute;
                pointer-events: none; /* クリックイベントを無効化 */
                cursor: pointer;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 255, 255 ); 
                border: 2px solid #c5c5c5;
            }
            .透明色だよ{
                border-radius: 50%;
                background: 
                    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%),
                    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%);
                background-size: 0.5em 0.5em;
                background-position: 0 0, 0.25em 0.25em;

            }
            #太さ{
                width: 3em;
                height: 1em;
            }
            #slider太さ{
                width: 8em;
            }
            #ツール選択 input{
                display: none; /* デフォルトのラジオボタンを非表示 */
            }
            .ペンボタン {
                display: inline-block;
                width: 3em; /* ボタンの幅 */
                height: 3em; /* ボタンの高さ */
                background-size: cover; /* 画像をボタン全体にフィットさせる */
                background-repeat: no-repeat; /* 画像を繰り返さない */
                cursor: pointer; /* マウスカーソルをポインターに変更 */
                image-rendering: pixelated; /* ピクセルを強調してぼやけを防ぐ */
                filter: brightness(40%) saturate(20%); /* 色味調整 */
                border: 2px solid #aaa; /* ボタンの枠線 */
            }
            input[type="radio"]:checked + .ペンボタン {
                background-color: #007bff; /* 選択時の背景色（青） */
                filter: brightness(100%) saturate(100%); /* 色味調整 */
            }

            #ペン_ボタン {
                background-image: url("../images/omocha/deyukaki/pen16.png"); 
            }

            #バケツ_ボタン {
                background-image: url("../images/omocha/deyukaki/baketu16.png"); 
            }

            #スポイト_ボタン {
                background-image: url("../images/omocha/deyukaki/supoito16.png");
            }



            .保存系ボタン{
                margin: 0.1em;
                cursor: pointer;
            }
            .保存系ボタン:hover {
                background-color: #ccc;
            }
            .保存系ボタン:active {
                background-color: #aaa;
            }
            #マウス追従{
                display: none; /* デフォルトで非表示 */
                position: absolute;
                background-color: rgb(174, 238, 46);
                border-radius: 50%;
                border: #3b3b3b 2px solid;
                box-shadow: inset 0 0 0 1px white;
                width: 2em;
                height: 2em;
                pointer-events: none; /* マウスイベントを無効化 */
                z-index: 5; /* canvasよりは、高い値を指定して上に表示 */
            }

            /* 横幅が40em未満の場合 */
            @media (max-width: 40em) {
                #右分割 {
                    bottom: 1em; /* 下に配置 */
                    top: auto; /* 上の位置をリセット */
                }
                .radio{
                    width: 2em;
                    height: 2em;
                }
                .色箱_input {
                    position: relative;
                    width: 3em;
                    height: 3em;
                }
                #太さ{
                width: 3em;
                height: 1.5em;
                }
                #slider太さ{
                    width: 10em;
                }
                #マウス追従{
                width: 5em;
                height: 5em;
            }
            }

        </style>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-1MB5XLN4LW"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-1MB5XLN4LW');
        </script>
        <!-- Google tag (gtag.js) -->

        <script src="../js/public.js"></script>
        <script>
            /*
            作りたい機能リスト
            ・色置き換え
            ・右クリックからスポイト
            ・キーボードで色選択
            ・プレビュー表示
            ・撒き戻しとかのUIボタン
            ・色選択をデフォルトのやつじゃなくて自作
            ・移動とか拡大縮小
            ・色ごとに筆の大きさかえる
            ・ブラウザ閉じてもいくらか覚えておく
            ・筆の大きさ、20~100はもっと離散的でいいんじゃね？
            ・バケツの範囲は上のレイヤーも参照すべきである
            ・move判定をちょっと遅延させた影響でカクカクになってることを解消し忘れてるよねぇ！？
     
            多すぎ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
            */
            onload = function(){
                onload_functions();

                document.getElementById("左最小化").addEventListener("click", function() {
                    var container = document.getElementById("左最小化領域");
                    if (container.style.display === "none") {
                        container.style.display = "flex";//要検討
                        this.textContent = "<";
                    } else {
                        container.style.display = "none";
                        this.textContent = ">";
                    }
                });
                document.getElementById("右最小化").addEventListener("click", function() {
                    var container = document.getElementById("右最小化領域");
                    if (container.style.display === "none") {
                        container.style.display = "block";//要検討
                        this.textContent = ">";
                    } else {
                        container.style.display = "none";
                        this.textContent = "<";
                    }
                });

                function 真ん中高さ調整() {
                    var 上下padding= parseFloat(getComputedStyle(document.getElementById("mannaka")).marginTop)+parseFloat(getComputedStyle(document.getElementById("mannaka")).marginBottom);
                    var mannaka_height = window.innerHeight-document.getElementById("header").offsetHeight -上下padding;
                    document.getElementById("mannaka").style.height = mannaka_height + "px";
                    document.getElementById("三分割くん").style.height = mannaka_height-document.querySelector("footer").offsetHeight+ "px";
                    //document.getElementById("デバッグ用").textContent = 上下padding;
                }
                真ん中高さ調整();
                window.addEventListener("resize", 真ん中高さ調整);

                var canvas_0 = document.getElementById("cnvs_0");
                var canvas_1 = document.getElementById("cnvs_1");
                var canvas_border = document.getElementById("canvas_border");
                var キャンバス拡大率 = 1;
                var border_width = 0;
                var border_height = 0;
                
                function キャンバスボーダー設定() {                    
                    var 三分割くん=document.getElementById("三分割くん");
                    var スクロールサイズ調整=document.getElementById("スクロールサイズ調整");

                    スクロールサイズ調整.style.width = canvas_0.width*キャンバス拡大率 + "px";
                    スクロールサイズ調整.style.height = canvas_0.height*キャンバス拡大率 + "px";
                    スクロールサイズ調整.style.borderLeftWidth = 三分割くん.offsetWidth + "px";
                    スクロールサイズ調整.style.borderRightWidth = 三分割くん.offsetWidth + "px";
                    スクロールサイズ調整.style.borderTopWidth = 三分割くん.offsetHeight + "px"; 
                    スクロールサイズ調整.style.borderBottomWidth = 三分割くん.offsetHeight + "px";
                    スクロールサイズ調整.style.borderStyle = "solid";
                    スクロールサイズ調整.style.borderColor = "rgba(0, 0, 0, 0)";//透明化
                }
                
                キャンバスボーダー設定();
                window.addEventListener("resize", キャンバスボーダー設定);

                var 真ん中分割=document.getElementById("真ん中分割");
                function キャンバススクロール中央() {
                    真ん中分割.scrollLeft = (真ん中分割.scrollWidth-真ん中分割.clientWidth) / 2;
                    真ん中分割.scrollTop = (真ん中分割.scrollHeight-真ん中分割.clientHeight) / 2;
                }
                キャンバススクロール中央();
            
                //ここからおえかき機能
                var ctx_0 = canvas_0.getContext("2d");
                var ctx_1 = canvas_1.getContext("2d");
                var drawing = false;
                var スマホチョン押し保存;
                var スポイト追従座標;
                var 撒き戻しやり直し判定=0;
                var moveカウント=0;//n本指の即時タッチだったのかを判定するためにカウンターを用意したよ
                var バケツ判定=false;//上の奴と似たようなことをするよ
                var 撒き戻し_0=[];
                var 撒き戻し_1=[];
                var やりなおし_0=[];
                var やりなおし_1=[];
                var 履歴最大数=100;//やり直し最大数はなくてもいい。はず。
                var 一時保存用キャンバス_0;//初期化はあとでね
                var 一時保存用キャンバス_1;//初期化はあとでね
                var 現在キャンバス_0 = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                var 現在キャンバス_1 = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                var 現在キャンバス_データ部分 = 現在キャンバス_0.data;//こっちは0も1も使う感じなので1つあればいいかな
                var slider太さ = document.getElementById("slider太さ");
                var 太さ = document.getElementById("太さ");
                
                var 現在の色={r:0,g:0,b:0,a:255,layer:0,num:1,rgb:"#000000"};

                function 色選択関数を適用(親要素名称){
                    var 親要素 = document.getElementById(親要素名称);
                    var radio要素 = 親要素.querySelector(".radio");
                    radio要素.addEventListener("change", function (e) {
                        if(e.target.checked) {
                            選択色変更(input要素.value,親要素名称);
                        }
                    });
                    var input要素 = 親要素.querySelector(".色箱_input");
                    input要素.addEventListener("input", function () {
                        親要素.querySelector(".色箱_cover").style.backgroundColor = this.value; // 色を適用
                        選択色変更(this.value,親要素名称);
                        radio要素.checked = true; 
                    });
                    //ついでに背景色を初期化しておくか
                    親要素.querySelector(".色箱_cover").style.backgroundColor = input要素.value;

                }
                function 選択色変更(色文字列,親要素名称){
                    var 現在の色_文字列=色文字列;
                    現在の色_文字列=現在の色_文字列.replace("#", "");
                    現在の色.r = parseInt(現在の色_文字列.slice(0, 2), 16);
                    現在の色.g = parseInt(現在の色_文字列.slice(2, 4), 16);
                    現在の色.b = parseInt(現在の色_文字列.slice(4, 6), 16);
                    if(親要素名称=="color_0_0"){
                        現在の色.a=0;//なんかすごい実装だけど、まあいいか…
                    }else{
                        現在の色.a=255;
                    }
                    現在の色.rgb = 色文字列;
                    現在の色.layer = parseInt(親要素名称.split("_")[1], 10);
                    現在の色.num = parseInt(親要素名称.split("_")[2], 10);
                }
                色選択関数を適用("color_0_0");
                色選択関数を適用("color_0_1");
                色選択関数を適用("color_0_2");

                色選択関数を適用("color_1_0");
                色選択関数を適用("color_1_1");
                色選択関数を適用("color_1_2");
                
                var 現在のツール="pen";
                function ペン選択関数を適用(親要素名称){
                    var 親要素 = document.getElementById(親要素名称);
                    var radio要素 = 親要素.querySelector(".tool_radio");

                    radio要素.addEventListener("change", function (e) {
                        if(e.target.checked) {
                            現在のツール=親要素名称;
                            真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+親要素名称+"16.png),default"; // カスタムカーソルを適用
                            var マウス追従 = document.getElementById("マウス追従");
                            マウス追従.style.display = "none"; // マウス追従を非表示…なくてもいいけどね
                        }
                    });
                    

                }
                ペン選択関数を適用("pen");
                ペン選択関数を適用("baketu");
                ペン選択関数を適用("supoito");
                
                function キャンバスを白で塗りつぶす() {
                    ctx_0.clearRect(0, 0, canvas_0.width, canvas_0.height); // 上のキャンバスはクリア
                    ctx_1.fillStyle = document.getElementById("color_pick_1_0").value; // 塗りつぶしの色を0_0に設定
                    ctx_1.fillRect(0, 0, canvas_1.width, canvas_1.height); // キャンバス全体を塗りつぶす
                }
                キャンバスを白で塗りつぶす();
                一時保存用キャンバス_0=ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                一時保存用キャンバス_1=ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);

                function キャンバス比較(data1,data2){
                    for (let i = 0; i < data1.length; i++) {
                        if (data1[i] !== data2[i]) {
                            return false;
                        }
                    }
                    return true;
                }
                function キャンバス最新保持(){
                    //次に履歴を残すために今を一時保存するやつ
                    一時保存用キャンバス_0=ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    一時保存用キャンバス_1=ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                }
                function 履歴残し(){
                    if(キャンバス比較(ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height).data,一時保存用キャンバス_0.data) &&
                       キャンバス比較(ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height).data,一時保存用キャンバス_1.data)){
                        return;//履歴が変わってないから保存しない
                    }
                    if(撒き戻し_0.length>=履歴最大数){//はみ出るから消すね
                        撒き戻し_0.shift();
                        撒き戻し_1.shift();
                    }
                    撒き戻し_0.push(一時保存用キャンバス_0);
                    撒き戻し_1.push(一時保存用キャンバス_1);
                    やりなおし_0=[];//履歴が残ったってことは次のアクションが消えるべきってわけだ！
                    やりなおし_1=[];//履歴が残ったってことは次のアクションが消えるべきってわけだ！
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ
                }
                function 描き戻し(){
                    if(撒き戻し_0.length==0){
                        return;
                    }
                    やりなおし_0.push(ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height));
                    やりなおし_1.push(ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height));
                    ctx_0.putImageData(撒き戻し_0.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    ctx_1.putImageData(撒き戻し_1.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ

                }
                function やり直し(){
                    if(やりなおし_0.length==0){
                        return;
                    }
                    撒き戻し_0.push(ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height));
                    撒き戻し_1.push(ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height));
                    ctx_0.putImageData(やりなおし_0.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    ctx_1.putImageData(やりなおし_1.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ
                }

                var 円周マスク=[];//半径をいれるとその辺の点がわかるやつ
                var 前の直径=-1;
                function 円マスク作成(直径){
                    if(直径==前の直径){
                        return;//サボっておｋ
                    }
                    前の直径=直径;
                    円周マスク=[];
                    var 半径 =Math.floor(直径/2);
                    var 半径の二乗 = 直径*直径/4;
                    for (var i = 0; i <= 半径+10; i++) {
                        円周マスク.push([]);//空配列で初期化しとくね
                    }
                    for (var i = -半径; i <= 半径; i++) {
                        for (var j = -半径; j <= 半径; j++) {//正方形領域に対して
                            if (i * i + j * j <= 半径の二乗) {//半径に収まっていれば
                                var 距離 = Math.floor(Math.sqrt(i * i + j * j));
                                円周マスク[距離].push([i, j]);
                            }
                        }
                    }
                }

                slider太さ.addEventListener("input", function() {
                    //太さは1~10で調整しやすいようにして、10~はおおざっぱな選択にする
                    var 本質太さ=1;
                    if(this.value<=50){
                        //1~50は1~20に変換する
                        本質太さ= Math.round(this.value*20/50);
                    }else{
                        ////50~100は20~100に変換する
                        本質太さ= Math.round(this.value*80/50)-60;
                    }
                    太さ.value = 本質太さ;
                });
                function 太さからスライダー位置調整(){
                    //太さは1~10で調整しやすいようにして、10~はおおざっぱな選択にする
                    var slider位置=1;
                    if(太さ.value<=20){
                        //1~20は1~50に変換する
                        slider位置 = Math.floor(太さ.value*50/20);
                    }else{
                        //20~100は50~100に変換する
                        slider位置 = Math.floor(太さ.value*50/80)+38;
                    }
                    slider太さ.value = slider位置;
                }
                太さ.addEventListener("input", 太さからスライダー位置調整);
                太さからスライダー位置調整();//初期化。太さを保存するようにしたら使えるね！

                var 前回のマウス = {
                    x: 0,
                    y: 0
                };
                function 描き始め(e) {
                    drawing = true;

                    //現在の画像を取得しておく。moveで取得するとクソ遅いからね
                    現在キャンバス_0 = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    現在キャンバス_1 = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                    if(現在の色.layer==0){
                        現在キャンバス_データ部分 = 現在キャンバス_0.data;
                    }else if(現在の色.layer==1){
                        現在キャンバス_データ部分 = 現在キャンバス_1.data;
                    }
                    

                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    if (e.touches) {//これ指じゃね？
                        前回のマウス.x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        前回のマウス.x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    スマホチョン押し保存=e;
                    //描き初めで点を描くのをやめた（二本指指スクロールで暴発するので）
                    //→でもそれだと点をちょん押しで描けないじゃん
                    //→じゃあ移動じゃなかったと後から判断して後で描くか→描き終わり()                    
                }

                function 描き途中(e) {
                    if (!drawing){//そんなことあるか？
                        return;
                    }
                    if(スマホチョン押し保存){
                        スマホチョン押し保存=null;//無効にしないと、描き終わりで暴発する。
                    }

                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var x, y;

                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    
                    //アンチエイリアスが嫌なので、1ピクセルずつ.fillRect()で描く
                    //前回のマウスの座標から、現在のマスウの座標までの移動距離だけループする
                    var dx = x - 前回のマウス.x;
                    var dy = y - 前回のマウス.y;
                    if(Math.abs(dx)>Math.abs(dy)){
                        var ループ回数 = Math.abs(dx)+1;
                    }else{
                        var ループ回数 = Math.abs(dy)+1;
                    }
                    //太さ決定。ここでいいのか…？
                    /*
                    //俺のペンタブ、ブラウザで筆圧検知できねえわ（笑）
                    console.log(e.pressure);
                    if(e.pressure){
                        var 圧力直径=Math.floor(太さ.value*e.pressure);//筆圧で太さを変える
                    }else{
                        var 圧力直径=太さ.value;
                    }
                    */
                    var 圧力直径=太さ.value;
                    円マスク作成(圧力直径);
                    var 円データ = [];
                    for (var i = 0; i < ループ回数; i++) {
                        var ループx = Math.floor(前回のマウス.x + (dx / ループ回数) * i);
                        var ループy = Math.floor(前回のマウス.y + (dy / ループ回数) * i);
                        円データ.push([ループx, ループy, 圧力直径]);
                    }
                    for (const [ループx, ループy, 直径] of 円データ) {
                        円を描く(ループx, ループy, 直径,true);//ガワだけ描くよ
                    }
                    円を描く(x,y,圧力直径,false);
                    
                    if(現在の色.layer==0){
                        ctx_0.putImageData(現在キャンバス_0, 0, 0);//渡すのはデータ部ではない。
                        //ここで塗ることで時短。筆圧で変化するようにしたらアレになるかも？
                        //残りはもう直接塗っちゃえばよくね？
                        ctx_0.fillStyle = 現在の色.rgb;
                        ctx_0.beginPath();
                        ctx_0.arc(x+0.5, y+0.5, Math.max(0,Math.floor(圧力直径/2)-1), 0, Math.PI * 2);//ちょっとちっちゃめにしとこうぜ
                        //+0.5は、円周の表示と比べて中心位置がちょいずれてるから入れた
                        //ctx_0.fill();
                    }else if(現在の色.layer==1){
                        ctx_1.putImageData(現在キャンバス_1, 0, 0);//渡すのはデータ部ではない。
                        //ここで塗ることで時短。筆圧で変化するようにしたらアレになるかも？
                        //残りはもう直接塗っちゃえばよくね？
                        ctx_1.fillStyle = 現在の色.rgb;
                        ctx_1.beginPath();
                        ctx_1.arc(x+0.5, y+0.5, Math.max(0,Math.floor(圧力直径/2)-1), 0, Math.PI * 2);//ちょっとちっちゃめにしとこうぜ
                        //+0.5は、円周の表示と比べて中心位置がちょいずれてるから入れた
                        //ctx_1.fill();
                    }


                    //次回の始点を更新更新！
                    if (e.touches) {//これ指じゃね？
                        前回のマウス.x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        前回のマウス.x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                }


                function 円を描く(x, y, 直径,ガワだけ) {
                    //円周部分だけはしっかりと3ピクセルくらいだけ描いて、真ん中はまあ適当にって感じ
                    var 半径 =Math.floor(直径/2);
                    var 半径の二乗 = 直径*直径/4;

                    //レイヤー分けは不要だよね（だよねだよね）

                    if(ガワだけ){
                        var 描き初め=Math.max(0, 半径-2); //マイナスの値ってなにが適切なんだろうね           
                    }else{
                        var 描き初め=0;    
                    }
                    for(var r=描き初め; r<=半径; r++){//ちゃんと描く。
                        for (const [i, j] of 円周マスク[r]) {
                            if(i+x<0 || i+x>=canvas_0.width || j+y<0 || j+y>=canvas_0.height){
                                continue;//キャンバス外は無視
                            }
                            if (i * i + j * j <= 半径の二乗) {//半径に収まっていれば
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4] = 現在の色.r;//直接色変える
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4+1] = 現在の色.g;//直接色変える
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4+2] = 現在の色.b;//直接色変える
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4+3] = 現在の色.a;//直接色変える
                            }
                        }
                    }    
                     
                }
                
                function 描き終わり() {
                    if(スマホチョン押し保存){//二本指タップ時にスマホチョン押し保存を破壊してる。
                        描き途中(スマホチョン押し保存);
                    }
                    drawing = false;
                    履歴残し();
                    
                }

                function バケツ(e){
                    現在キャンバス_0 = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    現在キャンバス_1 = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                    if(現在の色.layer==0){
                        現在キャンバス_データ部分 = 現在キャンバス_0.data;
                    }else if(現在の色.layer==1){
                        現在キャンバス_データ部分 = 現在キャンバス_1.data;
                    }

                    var キャンバス位置 = canvas_0.getBoundingClientRect();//まあこれはどっちでもいいよね
                    var x, y;

                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    //マウス位置の色を取得
                    if(現在の色.layer==0){
                        var 塗られる色 = ctx_0.getImageData(x, y, 1, 1).data;
                    }else if(現在の色.layer==1){    
                        var 塗られる色 = ctx_1.getImageData(x, y, 1, 1).data;
                    }
                    //塗られる色と、今から塗る色が同じだと意味ないし無限ループ入るから終了する。
                    if (塗られる色[0] === 現在の色.r && 塗られる色[1] === 現在の色.g && 塗られる色[2] === 現在の色.b && 塗られる色[3] === 現在の色.a) {
                        return;
                    }
                    var キュー = [[x, y]];

                    //キューが無くなるまでループして、色を判定→周囲をキューに入れる→自分を塗って削除を繰り返す
                    while (キュー.length > 0) {
                        var [キューx, キューy] = キュー.pop();//キューの先頭を取り出す
                        //キャンバス外は無視
                        if (キューx < 0 || キューx >= canvas_0.width || キューy < 0 || キューy >= canvas_0.height) {
                            continue;
                        }
                        //すでに塗られている色は無視
                        if (現在キャンバス_データ部分[(キューy * canvas_0.width + キューx) * 4] === 塗られる色[0] 
                        && 現在キャンバス_データ部分[(キューy * canvas_0.width + キューx) * 4+1] === 塗られる色[1] 
                        && 現在キャンバス_データ部分[(キューy * canvas_0.width + キューx) * 4+2] === 塗られる色[2] 
                        && 現在キャンバス_データ部分[(キューy * canvas_0.width + キューx) * 4+3] === 塗られる色[3]) {
                            //お前の色はバケツ対象だから、周囲をキューにぶち込む
                            キュー.push([キューx + 1, キューy]);
                            キュー.push([キューx - 1, キューy]);
                            キュー.push([キューx, キューy + 1]);
                            キュー.push([キューx, キューy - 1]);

                            //塗る
                            現在キャンバス_データ部分[(キューy * canvas_0.width + キューx) * 4] = 現在の色.r;//直接色変える
                            現在キャンバス_データ部分[(キューy * canvas_0.width + キューx) * 4 + 1] = 現在の色.g;//直接色変える  
                            現在キャンバス_データ部分[(キューy * canvas_0.width + キューx) * 4 + 2] = 現在の色.b;//直接色変える
                            現在キャンバス_データ部分[(キューy * canvas_0.width + キューx) * 4 + 3] = 現在の色.a;//直接色変える
                        }
                    }
                    //画像をcanvasへ反映
                    if(現在の色.layer==0){
                        ctx_0.putImageData(現在キャンバス_0, 0, 0);//渡すのはデータ部ではない。
                    }else if(現在の色.layer==1){
                        ctx_1.putImageData(現在キャンバス_1, 0, 0);//渡すのはデータ部ではない。
                    }
                    //document.getElementById("デバッグ用").textContent ="終";
                    履歴残し();
                }

                function スポイトの色表示(x,y){
                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.left = x+10+"px";
                    マウス追従.style.top =  y+10+"px";

                    var canv_x, canv_y;
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    canv_x = Math.floor((x - キャンバス位置.left )/キャンバス拡大率);
                    canv_y = Math.floor((y - キャンバス位置.top )/キャンバス拡大率);
                    
                    マウス追従.style.display = "block"; // マウス追従を表示

                    //色縫っていく
                    var そこの色 = ctx_0.getImageData(canv_x, canv_y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        そこの色=ctx_1.getImageData(canv_x, canv_y, 1, 1).data;
                    }
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    マウス追従.style.backgroundColor = 色文字列; // 色を適用
                    
                }

                function スポイト端っこ表示(e){
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var x, y;
                    
                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }

                    //範囲外なら無視
                    if (x < 0 || x >= canvas_0.width || y < 0 || y >= canvas_0.height) {
                        return;
                    }

                    var マウス追従 = document.getElementById("マウス追従");
                    //ここでは画面の左下に表示
                    マウス追従.style.left = 0 + "px";
                    マウス追従.style.top =真ん中分割.clientHeight+"px";

                    マウス追従.style.display = "block"; // マウス追従を表示
                    
                    //色縫っていく
                    var そこの色 = ctx_0.getImageData(x,y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        そこの色=ctx_1.getImageData(x, y, 1, 1).data;
                    }
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    マウス追従.style.backgroundColor = 色文字列; // 色を適用

                }

                function スポイト反映(e){
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var x, y;
                    
                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    
                    //範囲外なら無視
                    if (x < 0 || x >= canvas_0.width || y < 0 || y >= canvas_0.height) {
                        return;
                    }

                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.display = "none"; // マウス追従を非表示

                    現在のツール="pen";//スポイトの後はペンに戻す
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/pen16.png),default"; // カスタムカーソルを適用
                    //radioもペンにする
                    var radio_div要素 = document.getElementById("pen");
                    var radio要素 = radio_div要素.querySelector(".tool_radio");
                    radio要素.checked = true; // ペンを選択

                    //マウス位置の色を取得
                    var そこの色 = ctx_0.getImageData(x, y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        そこの色=ctx_1.getImageData(x, y, 1, 1).data;
                    }
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    //radio_divに同じ色のやつがないか探す
                    var 色箱一覧 = document.querySelectorAll(".色箱_input");

                    for (var i = 0; i < 色箱一覧.length; i++) {
                        var 色箱 = 色箱一覧[i];
                        if (色箱.value.toLowerCase() === 色文字列.toLowerCase()) {//.toLowerCase()は小文字にするやつ
                            // 同じ色が見つかった場合、その色を選択
                            色箱.parentElement.parentElement.querySelector(".radio").checked = true;
                            選択色変更(色箱.value, 色箱.parentElement.parentElement.id);
                            return;
                        }
                    }
                    //同じ色がいなかったら今選択されているradioの色をこいつに変える
                    //これ、場合によっては下のレイヤーの色を上のレイヤーとして取得しちゃうな…まあいいか！（まあいいかでゆっちであった。）
                    var radio_div要素 = document.getElementById("color_" + 現在の色.layer + "_" + 現在の色.num);
                    var input要素 = radio_div要素.querySelector(".色箱_input");
                    input要素.value =色文字列;
                    選択色変更(input要素.value,"color_" + 現在の色.layer + "_" + 現在の色.num);
                    radio_div要素.querySelector(".色箱_cover").style.backgroundColor = input要素.value;
                }
                function スポイト非表示(){
                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.display = "none"; // マウス追従を非表示
                }

                var 動かし前指間距離 = 0;
                var 前回指間座標 = [0, 0];

                function 指間距離計算(touches) {
                    var dx = touches[0].clientX - touches[1].clientX;
                    var dy = touches[0].clientY - touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }

                function 指間座標計算(e) {
                    return [(e.touches[0].clientX + e.touches[1].clientX) / 2, (e.touches[0].clientY + e.touches[1].clientY) / 2];
                }
                真ん中分割.addEventListener("pointerdown", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    // 右クリックは無視
                    if (e.button === 2) {
                        return;
                    }
                    // スクロールバー上でのクリックを無視
                    if (e.clientX > 真ん中分割.clientWidth || e.clientY > 真ん中分割.clientHeight) {
                        return;
                    }
                    真ん中分割.setPointerCapture(e.pointerId);//ポインターを追跡する。どっか行ってもキャンセルを監視できる
                    if(現在のツール==="pen"){
                        描き始め(e);
                    }else if(現在のツール==="baketu"){
                        バケツ(e);
                    }else if(現在のツール==="supoito"){
                        スポイト反映(e);
                    }
                });
                真ん中分割.addEventListener("pointermove", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    if(現在のツール==="pen"){
                        描き途中(e);
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                    }
                    
                });
                canvas_0.addEventListener("pointermove", function(e){
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    if(現在のツール==="pen"){

                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                        スポイトの色表示(e.x, e.y);
                    }

                });
                canvas_0.addEventListener("pointerleave", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    if(現在のツール==="pen"){
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                        スポイト非表示();
                    }
                });

                真ん中分割.addEventListener("pointerup", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    if(現在のツール==="pen"){
                        描き終わり();
                    }else if(現在のツール==="baketu"){
                        
                    }else if(現在のツール==="supoito"){

                    }
                    
                });
                真ん中分割.addEventListener("pointercancel", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    if(現在のツール==="pen"){
                        描き終わり();
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){

                    }
                });

                真ん中分割.addEventListener("wheel", function(e) {
                    //スクロールバーの上でのホイール操作を無視
                    console.log(e.clientX, e.clientY, 真ん中分割.clientWidth, 真ん中分割.clientHeight);
                    if (e.clientX < 真ん中分割.clientWidth && e.clientY < 真ん中分割.clientHeight) {
                        e.preventDefault();
                        キャンバス拡大(e.deltaY > 0 ? -0.1 : 0.1, e.clientX, e.clientY);
                    }else if(e.clientY > 真ん中分割.clientHeight){//なんか、ここバグってるんだけど意味わかんないんだよね
                        e.preventDefault();
                        //上下スクロールでキャンバスの横向きの位置を調整する.カクカクするけど、いいよね！
                        真ん中分割.scrollLeft += e.deltaY/2;
                    }
                }); 

                function キャンバス拡大(拡大率, 中心x, 中心y){                    
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var 変動前位置x=(中心x - キャンバス位置.left )/キャンバス拡大率;
                    var 変動前位置y=(中心y - キャンバス位置.top )/キャンバス拡大率;

                    var 前拡大率 = キャンバス拡大率;
                    キャンバス拡大率 += 拡大率;
                    キャンバス拡大率 = Math.max(0.1, キャンバス拡大率);
                    キャンバス拡大率 = Math.min(10, キャンバス拡大率);

                    //キャンバスの位置を調整する
                    真ん中分割.scrollLeft +=  (中心x - キャンバス位置.left )*(キャンバス拡大率/前拡大率-1);
                    真ん中分割.scrollTop += (中心y - キャンバス位置.top )*(キャンバス拡大率/前拡大率-1);
                 

                    //キャンバスを拡大（ズラす→拡大の順番じゃないとどうやら非同期処理で計算狂うっぽい）
                    canvas_0.style.transform = "scale("+キャンバス拡大率+")";
                    canvas_1.style.transform = "scale("+キャンバス拡大率+")";
                    キャンバスボーダー設定();
                    //ま、それでもちょっとずれてるけどね

                }

                真ん中分割.addEventListener("touchstart", function(e) {
                    if (e.touches.length === 2) {
                        動かし前指間距離 = 指間距離計算(e.touches);
                        e.preventDefault();
                        前回指間座標 = 指間座標計算(e);
                        撒き戻しやり直し判定=2;
                        moveカウント=0;
                    } else if (e.touches.length ===3) {
                        e.preventDefault();
                        撒き戻しやり直し判定=3;
                        moveカウント=0;
                    } else if (e.touches.length > 3) {
                        // 指が4本以上の場合は反応しない
                    }else{
                        e.preventDefault();
                        if(現在のツール==="pen"){
                            描き始め(e);
                        }else if(現在のツール==="baketu"){
                            moveカウント=0;
                            スマホチョン押し保存=e;//ここで保存しないと、指を離したときにはどっかいってる。
                        }else if(現在のツール==="supoito"){
                            スポイト追従座標=e;
                        }
                    }
                });

                真ん中分割.addEventListener("touchmove", function(e) {
                    if(moveカウント>10){
                        撒き戻しやり直し判定=0;//まあちょっと動いたし無効化…って判定シビアじゃない？
                        スマホチョン押し保存=null;//無効にしないと、バケツで暴発する。
                        document.getElementById("デバッグ用").textContent ="poe";
                    }else{
                        moveカウント+=1;
                        
                        if (e.touches.length === 2 & 撒き戻しやり直し判定!=3) {
                            撒き戻しやり直し判定=2;
                            スマホチョン押し保存=null;//なんか違うよね、君
                        }else if (e.touches.length === 3) {
                            撒き戻しやり直し判定=3;
                            スマホチョン押し保存=null;//なんか違うよね、君
                        }
                        document.getElementById("デバッグ用").textContent =撒き戻しやり直し判定;
                        return;//動いてないとする。1pxくらい動くと反応するかな
                    }
                    
                    if (e.touches.length === 2) {
                        drawing=false;
                        スマホチョン押し保存=null;//無効にしないと、描き終わりで暴発する。描き途中()の中でdrawing殺してるんだからわざわざやらんでもいいんだけどね
                        スポイト追従座標=null;
                        e.preventDefault();
                        //拡大操作
                        var 指間距離 = 指間距離計算(e.touches);
                        var 変動率 = 指間距離 / 動かし前指間距離;
                        動かし前指間距離 = 指間距離;
                        キャンバス拡大((変動率-1)*キャンバス拡大率,指間座標計算(e)[0] , 指間座標計算(e)[1]);
                        //移動操作
                        //合計移動量が少ないなら移動しない…は実装せんでええか
                        真ん中分割.scrollLeft += (前回指間座標[0] - 指間座標計算(e)[0]);//拡大してても影響ないよ～～ん
                        真ん中分割.scrollTop += (前回指間座標[1] - 指間座標計算(e)[1]);
                        前回指間座標 = 指間座標計算(e);
                    } else if (e.touches.length ===3) {
                        drawing=false;
                        スマホチョン押し保存=null;//無効にしないと、描き終わりで暴発する。描き途中()の中でdrawing殺してるんだからわざわざやらんでもいいんだけどね
                        スポイト追従座標=null;
                        e.preventDefault();
                    } else if (e.touches.length > 3) {
                        // 指が4本以上の場合は反応しない
                    }else{
                        e.preventDefault();//画面スクロールとか無効にしちゃうよ～ん
                        if(現在のツール==="pen"){
                            描き途中(e);
                            
                        }else if(現在のツール==="baketu"){
                            //判定はこの関数の上のほうでやってるので。
                        }else if(現在のツール==="supoito"){
                            スポイト追従座標=e;
                            スポイト端っこ表示(スポイト追従座標);
                        }
                    }
                });

                真ん中分割.addEventListener("touchend", function(e) {
                    e.preventDefault();//画面スクロールとか無効にしちゃうよ～ん
                    if(現在のツール==="pen"){
                        描き終わり();
                    }else if(現在のツール==="baketu"){
                        if(スマホチョン押し保存){
                            バケツ(スマホチョン押し保存);
                            スマホチョン押し保存=null;
                        }
                    }else if(現在のツール==="supoito"){
                        if(スポイト追従座標){
                            スポイト反映(スポイト追従座標);
                        }
                        
                    }
                    

                    if(撒き戻しやり直し判定===2){
                        描き戻し();
                    }else if(撒き戻しやり直し判定===3){
                        やり直し();
                    }
                    撒き戻しやり直し判定=0;
                });

                document.addEventListener("keydown", function(e) {
                    if (e.ctrlKey && e.key === "z") {
                        e.preventDefault(); // デフォルトの動作を無効化
                        描き戻し();
                    } else if (e.ctrlKey && e.key === "y") {
                        e.preventDefault(); // デフォルトの動作を無効化
                        やり直し();
                    }
                });

                document.getElementById("コピーボタン").addEventListener("click", function() {
                    //テキストもコピーできるかな～て思ったけど、できるけどできないみたい。
                    var 合成キャンバス=new OffscreenCanvas(canvas_0.width, canvas_0.height);
                    var 合成結果=合成キャンバス.getContext("2d");
                    合成結果.drawImage(canvas_1,0,0);
                    合成結果.drawImage(canvas_0,0,0);
                    合成キャンバス.convertToBlob().then(function(blob) {
                        const item = new ClipboardItem({ "image/png": blob });//HTTPSかhttp://127.0.0.1/じゃないとうごかない、らしいね。
                        navigator.clipboard.write([item]).then(function() {
                        }).catch(function(err) {
                            console.error("クリップボードへのコピーに失敗しました:", err);
                        });
                    });
                });

                document.getElementById("保存").addEventListener("click", function() {
                    var 合成キャンバス=new OffscreenCanvas(canvas_0.width, canvas_0.height);
                    var 合成結果=合成キャンバス.getContext("2d");
                    合成結果.drawImage(canvas_1,0,0);
                    合成結果.drawImage(canvas_0,0,0);
                    合成キャンバス.convertToBlob().then(function(blob) {
                        var link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        const date = new Date();
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, '0');  // 月は0から始まるので+1
                        const day = String(date.getDate()).padStart(2, '0');
                        const hours = String(date.getHours()).padStart(2, '0');
                        const minutes = String(date.getMinutes()).padStart(2, '0');
                        const seconds = String(date.getSeconds()).padStart(2, '0');
                        link.download = year+""+month+""+day+"_"+hours+""+minutes+""+seconds+"_deyukaki.png";//ファイル名決めてる
                        link.click();//強制クリック
                    });
                });

                document.getElementById("白紙").addEventListener("click", function() {
                    キャンバスを白で塗りつぶす();
                    履歴残し();
                    
                });

                //ページ下部のツイートボタンを上書き
                document.getElementById("foot_tweet_a").href=URL_tweet_text="https://twitter.com/intent/tweet?hashtags=deyukaki";           

            }
        </script>
    </head>
    <body>
        <div id="top"></div>
        <header id="header">
            <button onclick="html_link_btn()" id="html_link_btn"></button>
            <nav id="html_link_nav">
                <ul id="html_link_ul"></ul>
            </nav>
            <a href="../index.html">
                <img id="go_home" src="../images/site/omotyabako_deka.png" alt="トップページへ" height="1px"><!--ここで高さを入れておかないと、クソでかい画像が一瞬読み込まれてボタンの大きさが暴走する-->
            </a>
            <h1 id="title_h1">
                JUN汁ｗおもちゃばこ。
            </h1>
        </header>
        <div id="mannaka">
            <div id="三分割くん">
                <div id="左分割" class="浮かせる">
                    <div id="左最小化領域">
                        <div id="色選択div">
                            <div id="color_0" class="color_行">

                                <div class="radio_div" id="color_0_0">
                                    <input type="radio" class="radio" id="color_radio_0_0" name="color">
                                    <div class="色箱" id="color_div_0_0">
                                        <input class="色箱_input" type="color" id="color_pick_0_0" value="#ffffff" disabled style="visibility: hidden;"><!--色変え拒否-->
                                        <div class="色箱_cover 透明色だよ"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_0_1">
                                    <input type="radio" class="radio" id="color_radio_0_1" name="color" checked>
                                    <div class="色箱" id="color_div_0_1">
                                        <input class="色箱_input" type="color" id="color_pick_0_1" value="#000000">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_0_2">
                                    <input type="radio" class="radio" id="color_radio_0_2" name="color">
                                    <div class="色箱" id="color_div_0_2">
                                        <input class="色箱_input" type="color" id="color_pick_0_2" value="#FFF6EF">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>
                                
                            </div>

                            <div id="color_1" class="color_行">

                                <div class="radio_div" id="color_1_0">
                                    <input type="radio" class="radio" id="color_radio_1_0" name="color">
                                    <div class="色箱" id="color_div_1_0">
                                        <input class="色箱_input" type="color" id="color_pick_1_0" value="#ffffff">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_1_1">
                                    <input type="radio" class="radio" id="color_radio_1_1" name="color">
                                    <div class="色箱" id="color_div_1_1">
                                        <input class="色箱_input" type="color" id="color_pick_1_1" value="#aaffaa">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_1_2">
                                    <input type="radio" class="radio" id="color_radio_1_2" name="color">
                                    <div class="色箱" id="color_div_1_2">
                                        <input class="色箱_input" type="color" id="color_pick_1_2" value="#FF5558">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="ツール系">
                            <div id="筆の太さ">
                                <div>
                                    <label for="太さ">太さ：</label>
                                    <input type="number" id="太さ" min="1" max="100" value="5">
                                </div>
                                <input type="range" id="slider太さ" min="1" max="100" value="12" step="1">
                                <!--デフォルトは12なんだけど計算すると5pxになる。まあここは初期化してるのでなんでもいいんですが…-->
                            </div>
                            <div id="ツール選択">
                                <label id="pen">
                                    <input type="radio" name="tool" class="tool_radio" id="ペン" value="pen" checked>
                                    <span class="ペンボタン" id="ペン_ボタン"></span>
                                </label>
                                <label id="baketu">
                                    <input type="radio" name="tool" class="tool_radio" id="バケツ" value="bucket">
                                    <span class="ペンボタン" id="バケツ_ボタン"></span>
                                </label>
                                <label id="supoito">
                                    <input type="radio" name="tool" class="tool_radio" id="スポイト" value="supoito">
                                    <span class="ペンボタン" id="スポイト_ボタン"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <button id="左最小化"><</button>
                    <div id="デバッグ用">test</div>
                </div>

                <div id="真ん中分割">
                    <div id="スクロールサイズ調整">    
                        <canvas id="cnvs_1" height="450px" width="600px"><!--styleのheigthは見た目の大きさを変えているにすぎない。表示領域はcssじゃない。-->
                        </canvas>      
                        <canvas id="cnvs_0" height="450px" width="600px"><!--styleのheigthは見た目の大きさを変えているにすぎない。表示領域はcssじゃない。-->
                        </canvas>          
                              
                    </div>
                </div>
                
                
                <div id="右分割"class="浮かせる">
                    <button id="右最小化">></button>
                    <div id="右最小化領域">
                        <button id="コピーボタン" class="保存系ボタン">コピー</button>
                        <button id="保存" class="保存系ボタン">保存</button>
                        <button id="白紙" class="保存系ボタン">左色で埋める</button>
                    </div>

                </div>
            </div>

            <footer>
                <ul id="footul">
                    <li id="foot_tweet_li">
                        <a href=""  target="_blank" rel="noopener noreferrer" id="foot_tweet_a"><!--onload_functions()でhrefを書き込んでるで！-->
                            <img src="../images/site/twitterbutton.gif" alt="ツイートボタン" id="tweet_img">
                        </a>
                    </li>
                    <li>
                        <a href="#top" id="totop"> 
                            ページ上部に移動
                        </a>
                    </li>
                </ul>
            </footer>
            <div id="マウス追従" calss="マウス追従"></div>
        </div>
    </body>
</html>
