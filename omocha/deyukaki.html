<!DOCTYPE html>
<html lang="ja">
    <head prefix="og: http://ogp.me/ns# website: http://ogp.me/ns/website#">
        <meta charset="UTF-8">
        <!--文字コードは上のほうにないとすべておしまいになるらしい-->
        <meta name="description" content="でゆっち用お絵描きソフトウェア #deyukaki">                                                                 <!--ページ説明　入力すること！-->
        <title>JUN汁ｗおもちゃばこ。/おもちゃ/でゆ描き</title>                                                         <!--タイトル　入力すること！-->
        <!--OGPとかいうの-->
        <meta property="og:site_name" content="JUN汁ｗおもちゃばこ。/omocha/deyukaki">                                <!--タイトル　入力すること！-->
        <meta property="og:title" content="でゆ描き">                                                               <!--タイトル　入力すること！-->
        <meta property="og:type" content="article"> <!--websiteはトップページ、articleが記事だってさ-->
        <meta property="og:url" content="https://junjiruw.github.io/DEYUTI/omocha/deyukaki.html">                   <!--リンク　入力すること！-->
        <meta property="og:image" content="https://github.com/junjiruw/DEYUTI/blob/master/images/site/junjiruw_bako.png?raw=true">
        <meta name="twitter:card" content="summary"><!--なにを表示するか-->
        <meta name="twitter:site" content="@junjiruw"><!--フッターに表示されるらしい…どこ？-->
        <meta name="viewport" content="width=device-width,initial-scale=1"><!--スマホで見てる人向けに表示領域の設定-->
        <link rel="stylesheet" href="../css/style.css">
        
        <link rel="icon" href="../images/site/favicon32.png">
        <style>
            header{
                position: static;/*fixedじゃなくするとpublic.js内の処理をスキップするよん*/
                
            }
            #html_link_nav{
                z-index: 20; /* 高い値を指定して上に表示 */
            }
            div#mannaka{
                width: 100%;
                margin: 0.5em 0px 0.5em 0px;
                border: 2px solid #ffffff;
                color: #ffffff;   
                font-size: 16px;    
            }
            #三分割くん {
                position: relative;
                height: 100%; /* 親要素の高さに合わせる */
            }

            #真ん中分割 {
                width: 100%;
                height: 100%; /* 親要素の高さに合わせる */
                text-align: center;
                overflow: scroll;
                cursor: url("../images/omocha/deyukaki/pen16.png"),default; /* カスタムカーソル画像 */
            }
            /* スクロールバーの幅を指定 */
            #真ん中分割::-webkit-scrollbar {
                width: 1em; /* 垂直スクロールバーの幅 */
                height: 1em; /* 水平スクロールバーの高さ */
            }
            #真ん中分割::-webkit-scrollbar-track {
                background: #757575;
            }
            #真ん中分割::-webkit-scrollbar-thumb {
                background: #dadada;
                border-radius: 6px;
            }
            #真ん中分割::-webkit-scrollbar-thumb:hover {
                background: #b4b4b4;
            }
            
            #スクロールサイズ調整 {
                position: relative;
                z-index: 1; /* 邪魔なので一番奥に。*/
            }

            .描画用 {
                position: absolute;
                transform-origin: top left; /* 拡大縮小の基準点を左上に設定 */
                top:0;
                left:0;
                background-clip: padding-box;/*背景色がborderまでいかないようになる*/
                image-rendering: pixelated;/* 画像の拡大縮小時にピクセルを強調する */
                
            }

            .浮かせる {
                position: absolute;
                top: 0;
                background: #555;
                color: #fff;
                
                display: flex;
                justify-content: center;/* 2分割くんの中身を真ん中によせる */
            }

            #左分割 {
                left: 0;
                z-index: 10; /* 高い値を指定して上に表示 */
            }

            #右分割 {
                right: 1em;
                z-index: 10; /* 高い値を指定して上に表示 */
            }

            #左最小化領域 {
                display: flex; /* 子要素を横並びにする */
            }
            .color_行{
                display: flex; /* 子要素を横並びにする */
                border: 2px solid #aaa;
                padding: 2px;
                margin: 2px;
            }
            .img_layer{
                image-rendering: pixelated; /* ピクセルを強調してぼやけを防ぐ */
                width: 1.5em;
                height: 1.5em;

            }
            .radio_div{
                display: flex;
                flex-direction: column; /* ラジオボタンとラベルを縦に並べる */
                align-items: center; /* 中央揃え */
            }

            .radio{
                display: inline-block;
                width: 1em;
                height: 1em;
                border: 2px solid #aaa;
                background-color: #fff;
                border-radius: 50%;
            }
            .radio:checked{
                background-color: rgb(80, 160, 255);
            }
            .色箱{
                position: relative;
                margin: 0.2em;
            }
            .色箱_input {
                position: relative;
                width: 1.5em;
                height: 1.5em;
            }
            .色箱_cover{
                position: absolute;
                /*pointer-events: none; /* クリックイベントを無効化 してたのを無効化！！！！！*/
                cursor: pointer;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 255, 255 ); 
                border: 2px solid #c5c5c5;
            }
            .透明色だよ{
                border-radius: 50%;
                background: 
                    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%),
                    linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%);
                background-size: 0.5em 0.5em;
                background-position: 0 0, 0.25em 0.25em;

            }
            #太さ{
                width: 3em;
                height: 1em;
            }
            #slider太さ{
                width: 10em;
            }
            #ツール選択 input{
                display: none; /* デフォルトのラジオボタンを非表示 */
            }
            .ペンボタン {
                display: inline-block;
                width: 3em; /* ボタンの幅 */
                height: 3em; /* ボタンの高さ */
                background-size: cover; /* 画像をボタン全体にフィットさせる */
                background-repeat: no-repeat; /* 画像を繰り返さない */
                cursor: pointer; /* マウスカーソルをポインターに変更 */
                image-rendering: pixelated; /* ピクセルを強調してぼやけを防ぐ */
                filter: brightness(40%) saturate(20%); /* 色味調整 */
                border: 2px solid #aaa; /* ボタンの枠線 */
            }
            input[type="radio"]:checked + .ペンボタン {
                background-color: #007bff; /* 選択時の背景色（青） */
                filter: brightness(100%) saturate(100%); /* 色味調整 */
            }

            #ペン_ボタン {
                background-image: url("../images/omocha/deyukaki/pen16.png"); 
            }

            #バケツ_ボタン {
                background-image: url("../images/omocha/deyukaki/baketu16.png"); 
            }

            #スポイト_ボタン {
                background-image: url("../images/omocha/deyukaki/supoito16.png");
            }

            #スワップ_ボタン {
                background-image: url("../images/omocha/deyukaki/swap16.png");
                filter: brightness(80%) saturate(100%); /* 色味調整 */
            }


            .保存系ボタン{
                margin: 0.1em;
                cursor: pointer;
            }
            .保存系ボタン:hover {
                background-color: #ccc;
            }
            .保存系ボタン:active {
                background-color: #aaa;
            }
            #マウス追従{
                display: none; /* デフォルトで非表示 */
                position: absolute;
                background-color: rgb(174, 238, 46);
                border-radius: 50%;
                border: #3b3b3b 2px solid;
                box-shadow: inset 0 0 0 1px white;
                width: 2em;
                height: 2em;
                pointer-events: none; /* マウスイベントを無効化 */
                z-index: 5; /* canvasよりは、高い値を指定して上に表示 */
            }

            #カラーピッカー{
                position : absolute;
                top: 0;
                left: 0;
                width: 30%;
                height: 50%;
                background-color: rgba(0, 0, 0, 0.5); /* 半透明の黒 */
                border: 2px solid #ffffff;
                z-index: 100;/*とにかく上へ*/
                display : none;

                flex-direction: column; /*縦に*/
                align-items: center; /*左右中央に*/
                justify-content: center;/*上下中央に*/
            }

            #カラピカ上段{
                position: relative;
                display: flex;
                width: 95%;
                height: 80%;
            }

            #今の色{
                display : flex;
                flex-direction: column; /*縦に*/
                align-items: center; /*左右中央に*/
                justify-content: space-evenly;/*余白をいい感じにする。*/
                width: 15%;
                height: 100%;
            }

            #今の色表示{
                width: 80%;
                aspect-ratio: 1 / 1; /* 幅 = 高さ */
                border: 2px solid #ffffff;
            }

            #色参照スポイト{
                width: 60%;
                aspect-ratio: 1 / 1; /* 幅 = 高さ */
                border: 2px solid #ffffff;
                background-image: url("../images/omocha/deyukaki/supoito16.png");
                
                background-size: cover; /* 画像をボタン全体にフィットさせる */
                background-repeat: no-repeat; /* 画像を繰り返さない */
                cursor: pointer; /* マウスカーソルをポインターに変更 */
                image-rendering: pixelated; /* ピクセルを強調してぼやけを防ぐ */
            }

            .色参照スポイト_clicked{
                background-color: #007bff !important;
            }

            .色選択ボタン{
                width: 3em;
                padding: 0px;
                background-color: rgb(255, 255, 255);
            }

            .色選択ボタン:hover {
                filter: brightness(0.8);
            }

            .色選択ボタン:active {
                filter: brightness(0.6);
            }

            .採用ボタン{
                background-color: rgb(255, 202, 202);
            }

            .破棄ボタン{
                background-color: rgb(200, 235, 255);
            }


            #彩度選択div{
                position:relative;
                height: 70%;
                width: 95%;
                margin : 0.3em
            }

            #彩度選択{
                height: 100%;
                width: 100%;
                border: #FFF 2px solid;
            }

            #色相選択div{
                position:relative;
                height: 5%;
                width: 85%;
                margin: 0.3em;

            }

            #色相選択{
                height: 100%;
                width: 100%;
                border: #FFF 3px solid;
            }

            .色選択ガイド{
                position : absolute;
                top: 0;
                left: 0;
                border-radius: 50%;
                border: 3px solid #ffffff;
                
                aspect-ratio: 1 / 1; /* 幅 = 高さ */
                pointer-events: none; /* マウスイベントを無効化 */
            }

            #今の彩度{
                height: 5%;
                transform: translateX(-50%) translateY(-50%);
            }

            #今の色相{
                height: 100%;
                transform: translateX(-50%);
            }

            
            #スワップメニュー{
                position : absolute;
                top: 0;
                left: 0;
                width: 20em;
                height: 30%;
                background-color: rgba(0, 0, 0, 0.7); /* 半透明の黒 */
                border: 2px solid #ffffff;
                z-index: 90;/*それなりに上へ*/
                display : none;

                flex-direction: column; /*縦に*/
                align-items: center; /*左右中央に*/
                justify-content: center;/*上下中央に*/
            }
            #スワメニュ上段{
                width: 15em;
                display : flex;
                align-items: center; /*左右中央に*/
                justify-content: center;/*上下中央に*/
                text-align: center;
                margin: 1em;
            }
            #スワメニュ上段 div{
                flex: 1; /* 幅を均等に */
            }
            #スワメニュ下段{
                display : flex;
                justify-content: space-evenly;
                width: 50%;
            }


            /* 横幅が40em未満の場合 */
            @media (max-width: 40em) {
                #右分割 {
                    bottom: 1em; /* 下に配置 */
                    top: auto; /* 上の位置をリセット */
                }
                .radio{
                    width: 2em;
                    height: 2em;
                }
                .色箱_input {
                    position: relative;
                    width: 2.5em;
                    height: 2.5em;
                }
                #太さ{
                width: 3em;
                height: 1.5em;
                }
                #マウス追従{
                    width: 5em;
                    height: 5em;
                }
                #カラーピッカー{
                    width: 60%;
                }
                #カラピカ上段{
                    /*縦にならべるね*/
                    flex-direction: column; /*縦に*/
                    width: 100%;
                    height: 70%;
                }
                #今の色{
                    /*こっちは横に*/
                    flex-direction: row; 
                    width: 100%;
                    height: 20%;
                }
                #今の色表示{
                    height: 100%;
                    width:auto;
                }
                #色参照スポイト{
                    width:2em;
                }
            }

        </style>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-1MB5XLN4LW"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-1MB5XLN4LW');
        </script>
        <!-- Google tag (gtag.js) -->

        <script src="../js/public.js"></script>
        <script>
            /*
            作りたい機能リスト
            ・プレビュー表示
            ・移動とか拡大縮小
            ・alert()のOK押さなくていいバージョンがあると、きもちいいよね。
            ・移動時のチョン押し暴発さ、暴発を防ぐんじゃなくて、暴発を巻き戻す方針のほうがいいんじゃない？

            多すぎ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
            */
            onload = function(){
                onload_functions();

                document.getElementById("左最小化").addEventListener("click", function() {
                    var container = document.getElementById("左最小化領域");
                    if (container.style.display === "none") {
                        container.style.display = "flex";//要検討
                        this.textContent = "<";
                    } else {
                        container.style.display = "none";
                        this.textContent = ">";
                    }
                });
                document.getElementById("右最小化").addEventListener("click", function() {
                    var container = document.getElementById("右最小化領域");
                    if (container.style.display === "none") {
                        container.style.display = "block";//要検討
                        this.textContent = ">";
                    } else {
                        container.style.display = "none";
                        this.textContent = "<";
                    }
                });

                function 真ん中高さ調整() {
                    var 上下padding= parseFloat(getComputedStyle(document.getElementById("mannaka")).marginTop)+parseFloat(getComputedStyle(document.getElementById("mannaka")).marginBottom);
                    var mannaka_height = window.innerHeight-document.getElementById("header").offsetHeight -上下padding;
                    document.getElementById("mannaka").style.height = mannaka_height + "px";
                    document.getElementById("三分割くん").style.height = mannaka_height-document.querySelector("footer").offsetHeight+ "px";
                    //document.getElementById("デバッグ用").textContent = 上下padding;
                }
                真ん中高さ調整();
                window.addEventListener("resize", 真ん中高さ調整);

                var canvas_0 = document.getElementById("cnvs_0");
                var canvas_1 = document.getElementById("cnvs_1");
                var canvas_border = document.getElementById("canvas_border");
                var キャンバス拡大率 = 1;
                var border_width = 0;
                var border_height = 0;
                
                function キャンバスボーダー設定() {                    
                    var 三分割くん=document.getElementById("三分割くん");
                    var スクロールサイズ調整=document.getElementById("スクロールサイズ調整");

                    スクロールサイズ調整.style.width = canvas_0.width*キャンバス拡大率 + "px";
                    スクロールサイズ調整.style.height = canvas_0.height*キャンバス拡大率 + "px";
                    スクロールサイズ調整.style.borderLeftWidth = 三分割くん.offsetWidth + "px";
                    スクロールサイズ調整.style.borderRightWidth = 三分割くん.offsetWidth + "px";
                    スクロールサイズ調整.style.borderTopWidth = 三分割くん.offsetHeight + "px"; 
                    スクロールサイズ調整.style.borderBottomWidth = 三分割くん.offsetHeight + "px";
                    スクロールサイズ調整.style.borderStyle = "solid";
                    スクロールサイズ調整.style.borderColor = "rgba(0, 0, 0, 0)";//透明化
                }
                
                キャンバスボーダー設定();
                window.addEventListener("resize", キャンバスボーダー設定);

                var 真ん中分割=document.getElementById("真ん中分割");
                function キャンバススクロール中央() {
                    真ん中分割.scrollLeft = (真ん中分割.scrollWidth-真ん中分割.clientWidth) / 2;
                    真ん中分割.scrollTop = (真ん中分割.scrollHeight-真ん中分割.clientHeight) / 2;
                }
                キャンバススクロール中央();
            
                //ここからおえかき機能
                var ctx_0 = canvas_0.getContext("2d");
                var ctx_1 = canvas_1.getContext("2d");
                var drawing = false;
                var スマホチョン押し保存;
                var スポイト追従座標;
                var 撒き戻しやり直し判定=0;
                var moveカウント=0;//n本指の即時タッチだったのかを判定するためにカウンターを用意したよ
                var バケツ判定=false;//上の奴と似たようなことをするよ
                var 撒き戻し_0=[];
                var 撒き戻し_1=[];
                var やりなおし_0=[];
                var やりなおし_1=[];
                var 履歴最大数=100;//やり直し最大数はなくてもいい。はず。
                var 一時保存用キャンバス_0;//初期化はあとでね
                var 一時保存用キャンバス_1;//初期化はあとでね
                var 現在キャンバス_0 = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                var 現在キャンバス_1 = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                var 現在キャンバス_データ部分 = 現在キャンバス_0.data;//こっちは0も1も使う感じなので1つあればいいかな
                var slider太さ = document.getElementById("slider太さ");
                var 太さ = document.getElementById("太さ");
                var 筆ごとの太さ=[];
                
                var 現在の色={r:0,g:0,b:0,a:255,layer:0,num:1,rgb:"#000000"};
                var 最後の色=JSON.parse(JSON.stringify(現在の色));//参照切りしながら渡す
                var 変更する色={layer:0,num:0}

                function 色選択関数を適用(親要素名称){
                    var 親要素 = document.getElementById(親要素名称);
                    var これ数字レイヤーか=!isNaN(親要素名称.split("_")[1]);
                    if(これ数字レイヤーか){
                        var radio要素 = 親要素.querySelector(".radio");
                        radio要素.addEventListener("change", function (e) {
                            if(e.target.checked) {
                                選択色変更(input要素.value,親要素名称);
                            }
                        });
                    }
                    var input要素 = 親要素.querySelector(".色箱_input");
                    input要素.addEventListener("input", function () {
                        親要素.querySelector(".色箱_cover").style.backgroundColor = this.value; // 色を適用
                        if(これ数字レイヤーか){
                            選択色変更(this.value,親要素名称);
                            radio要素.checked = true; 
                        }
                        色箱保存(親要素名称);
                    });
                    親要素.querySelector(".色箱_cover").addEventListener("click", function () {
                        //自作カラーピッカーを表示したいと思いませんか？
                        カラーピッカー.style.display = "flex";
                        if(これ数字レイヤーか){
                            変更する色.layer = parseInt(親要素名称.split("_")[1], 10);
                        }else{
                            変更する色.layer = 親要素名称.split("_")[1];
                        }
                        変更する色.num = parseInt(親要素名称.split("_")[2], 10);

                        色参照の色更新(parseInt(input要素.value.slice(1, 3), 16),parseInt(input要素.value.slice(3, 5), 16),parseInt(input要素.value.slice(5, 7), 16),input要素.value);
                        
                    });
                    //ついでに背景色を初期化しておくか
                    親要素.querySelector(".色箱_cover").style.backgroundColor = input要素.value;

                }
                function 選択色変更(色文字列,親要素名称){
                    var 現在の色_文字列=色文字列;
                    現在の色_文字列=現在の色_文字列.replace("#", "");
                    現在の色.r = parseInt(現在の色_文字列.slice(0, 2), 16);
                    現在の色.g = parseInt(現在の色_文字列.slice(2, 4), 16);
                    現在の色.b = parseInt(現在の色_文字列.slice(4, 6), 16);
                    if(親要素名称=="color_0_0"){
                        現在の色.a=0;//なんかすごい実装だけど、まあいいか…
                    }else{
                        現在の色.a=255;
                    }
                    現在の色.rgb = 色文字列;
                    現在の色.layer = parseInt(親要素名称.split("_")[1], 10);
                    現在の色.num = parseInt(親要素名称.split("_")[2], 10);

                    //消しゴムじゃないなら色更新
                    if(現在の色.layer!=0 || 現在の色.num!=0){
                        最後の色=JSON.parse(JSON.stringify(現在の色));//参照切りしながら渡す
                    }

                    太さ.value=筆ごとの太さ[現在の色.layer][現在の色.num];
                    太さからスライダー位置調整()
                }
                色選択関数を適用("color_0_0");
                色選択関数を適用("color_0_1");
                色選択関数を適用("color_0_2");

                色選択関数を適用("color_1_0");
                色選択関数を適用("color_1_1");
                色選択関数を適用("color_1_2");
                
                var 現在のツール="pen";
                var 優先ツール="";
                function ペン選択関数を適用(親要素名称){
                    var 親要素 = document.getElementById(親要素名称);
                    var radio要素 = 親要素.querySelector(".tool_radio");

                    radio要素.addEventListener("change", function (e) {
                        if(e.target.checked) {
                            現在のツール=親要素名称;
                            if(優先ツール==""){
                                真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+親要素名称+"16.png),default"; // カスタムカーソルを適用
                                var マウス追従 = document.getElementById("マウス追従");
                                マウス追従.style.display = "none"; // マウス追従を非表示…なくてもいいけどね
                            }
                        }
                    });
                    

                }
                ペン選択関数を適用("pen");
                ペン選択関数を適用("baketu");
                ペン選択関数を適用("supoito");
                function 自動ツール選択(ツール名){
                    現在のツール=ツール名;
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+ツール名+"16.png),default"; // カスタムカーソルを適用
                    //radioも変更にする
                    var radio_div要素 = document.getElementById(ツール名);
                    var radio要素 = radio_div要素.querySelector(".tool_radio");
                    radio要素.checked = true; 
                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.display = "none"; // マウス追従を非表示…なくてもいいけどね
                }

                function 色スワップ表示(){
                    スワップメニュー.style.display = "flex";
                }
                var スワップボタン = document.getElementById("スワップ_ボタン");
                スワップボタン.addEventListener("click",色スワップ表示);
                色選択関数を適用("color_swap_0");
                色選択関数を適用("color_swap_1");

                
                function キャンバスを白で塗りつぶす() {
                    ctx_0.clearRect(0, 0, canvas_0.width, canvas_0.height); // 上のキャンバスはクリア
                    ctx_1.fillStyle = document.getElementById("color_pick_1_0").value; // 塗りつぶしの色を0_0に設定
                    ctx_1.fillRect(0, 0, canvas_1.width, canvas_1.height); // キャンバス全体を塗りつぶす
                }
                キャンバスを白で塗りつぶす();
                一時保存用キャンバス_0=ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                一時保存用キャンバス_1=ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);

                function キャンバス比較(data1,data2){
                    for (let i = 0; i < data1.length; i++) {
                        if (data1[i] !== data2[i]) {
                            return false;
                        }
                    }
                    return true;
                }
                function キャンバス最新保持(){
                    //次に履歴を残すために今を一時保存するやつ
                    一時保存用キャンバス_0=ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    一時保存用キャンバス_1=ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                    
                    //ここで保存しておけばいいか？
                    Canvas保存タイマー開始();
                }
                function 履歴残し(){
                    if(キャンバス比較(ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height).data,一時保存用キャンバス_0.data) &&
                       キャンバス比較(ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height).data,一時保存用キャンバス_1.data)){
                        return;//履歴が変わってないから保存しない
                    }
                    if(撒き戻し_0.length>=履歴最大数){//はみ出るから消すね
                        撒き戻し_0.shift();
                        撒き戻し_1.shift();
                    }
                    撒き戻し_0.push(一時保存用キャンバス_0);
                    撒き戻し_1.push(一時保存用キャンバス_1);
                    やりなおし_0=[];//履歴が残ったってことは次のアクションが消えるべきってわけだ！
                    やりなおし_1=[];//履歴が残ったってことは次のアクションが消えるべきってわけだ！
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ
                }
                function 描き戻し(){
                    if(撒き戻し_0.length==0){
                        return;
                    }
                    やりなおし_0.push(ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height));
                    やりなおし_1.push(ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height));
                    ctx_0.putImageData(撒き戻し_0.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    ctx_1.putImageData(撒き戻し_1.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ

                }
                function やり直し(){
                    if(やりなおし_0.length==0){
                        return;
                    }
                    撒き戻し_0.push(ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height));
                    撒き戻し_1.push(ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height));
                    ctx_0.putImageData(やりなおし_0.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    ctx_1.putImageData(やりなおし_1.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ
                }

                var 円周マスク=[];//半径をいれるとその辺の点がわかるやつ
                var 前の直径=-1;
                function 円マスク作成(直径){
                    if(直径==前の直径){
                        return;//サボっておｋ
                    }
                    前の直径=直径;
                    円周マスク=[];
                    var 半径 =Math.floor(直径/2);
                    var 半径の二乗 = 直径*直径/4;
                    for (var i = 0; i <= 半径+10; i++) {
                        円周マスク.push([]);//空配列で初期化しとくね
                    }
                    for (var i = -半径; i <= 半径; i++) {
                        for (var j = -半径; j <= 半径; j++) {//正方形領域に対して
                            if (i * i + j * j <= 半径の二乗) {//半径に収まっていれば
                                var 距離 = Math.floor(Math.sqrt(i * i + j * j));
                                円周マスク[距離].push([i, j]);
                            }
                        }
                    }
                }

                slider太さ.addEventListener("input", function() {
                    //太さは1~20で調整しやすいようにして、20~はおおざっぱな選択にする
                    var 本質太さ=1;
                    if(this.value<=80){
                        //1~80は1~20に変換する
                        本質太さ= Math.ceil(this.value*20/80);
                    }else{
                        ////80~100は20~100に変換する
                        本質太さ= Math.ceil(Math.round((this.value-80)*80/20+20)/10)*10;
                    }
                    太さ.value = 本質太さ;
                    筆ごとの太さ[現在の色.layer][現在の色.num]=太さ.value;
                });
                function 太さからスライダー位置調整(){
                    //太さは1~20で調整しやすいようにして、20~はおおざっぱな選択にする
                    var slider位置=1;
                    if(太さ.value<=20){
                        //1~80は1~50に変換する
                        slider位置 = Math.floor(太さ.value*80/20);
                    }else{
                        //20~100は80~100に変換する
                        slider位置 = Math.floor((太さ.value-20)*20/80)+80;
                    }
                    slider太さ.value = slider位置;
                    筆ごとの太さ[現在の色.layer][現在の色.num]=太さ.value;
                }

                太さ.addEventListener("input", 太さからスライダー位置調整);
                

                function 改行来たから終わるね(e){
                    //改行が着たら、選択から外すという親切心
                    if (e.key === "Enter") {
                        e.target.blur();
                    }
                }
                太さ.addEventListener("keydown", 改行来たから終わるね);

                //筆ごとの太さを初期化
                var 色箱一覧 = document.querySelectorAll(".色箱_input");
                for (var i = 0; i < 色箱一覧.length; i++) {
                    var 色箱 = 色箱一覧[i];
                    var 番号切り出し=色箱.id.slice(-3);//n_m
                    var n=parseInt(色箱.id.split('_')[2], 10);
                    var m=parseInt(色箱.id.split('_')[3], 10);
                    //console.log(n,m);
                    if (!筆ごとの太さ[n]) {//ないならつくる。
                        筆ごとの太さ[n] = [];
                    }
                    筆ごとの太さ[n][m]=5;//ここで全ての筆の初期値が決まってしまってるってワケさ
                }

                太さからスライダー位置調整();//初期化。太さを保存するようにしたら使いまわしてね！

                var 前回のマウス = {
                    x: 0,
                    y: 0
                };
                function 描き始め(e) {
                    drawing = true;

                    //現在の画像を取得しておく。moveで取得するとクソ遅いからね
                    現在キャンバス_0 = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    現在キャンバス_1 = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                    if(現在の色.layer==0){
                        現在キャンバス_データ部分 = 現在キャンバス_0.data;
                    }else if(現在の色.layer==1){
                        現在キャンバス_データ部分 = 現在キャンバス_1.data;
                    }
                    

                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    if (e.touches) {//これ指じゃね？
                        前回のマウス.x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        前回のマウス.x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    スマホチョン押し保存=e;
                    //描き初めで点を描くのをやめた（二本指指スクロールで暴発するので）
                    //→でもそれだと点をちょん押しで描けないじゃん
                    //→じゃあ移動じゃなかったと後から判断して後で描くか→描き終わり()                    
                }

                function 描き途中(e) {
                    if (!drawing){//そんなことあるか？
                        return;
                    }
                    if(スマホチョン押し保存){
                        スマホチョン押し保存=null;//無効にしないと、描き終わりで暴発する。
                    }

                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var x, y;

                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    
                    //アンチエイリアスが嫌なので、1ピクセルずつ.fillRect()で描く
                    //前回のマウスの座標から、現在のマスウの座標までの移動距離だけループする
                    var dx = x - 前回のマウス.x;
                    var dy = y - 前回のマウス.y;
                    if(Math.abs(dx)>Math.abs(dy)){
                        var ループ回数 = Math.abs(dx)+1;
                    }else{
                        var ループ回数 = Math.abs(dy)+1;
                    }
                    //太さ決定。ここでいいのか…？
                    /*
                    //俺のペンタブ、ブラウザで筆圧検知できねえわ（笑）
                    console.log(e.pressure);
                    if(e.pressure){
                        var 圧力直径=Math.floor(太さ.value*e.pressure);//筆圧で太さを変える
                    }else{
                        var 圧力直径=太さ.value;
                    }
                    */
                    var 圧力直径=筆ごとの太さ[現在の色.layer][現在の色.num];
                    円マスク作成(圧力直径);
                    var 円データ = [];
                    for (var i = 0; i < ループ回数; i++) {
                        var ループx = Math.floor(前回のマウス.x + (dx / ループ回数) * i);
                        var ループy = Math.floor(前回のマウス.y + (dy / ループ回数) * i);
                        円データ.push([ループx, ループy, 圧力直径]);
                    }
                    for (const [ループx, ループy, 直径] of 円データ) {
                        円を描く(ループx, ループy, 直径,true);//ガワだけ描くよ
                    }
                    円を描く(x,y,圧力直径,false);
                    
                    if(現在の色.layer==0){
                        ctx_0.putImageData(現在キャンバス_0, 0, 0);//渡すのはデータ部ではない。
                        /*
                        //ここで塗ることで時短。筆圧で変化するようにしたらアレになるかも？
                        //残りはもう直接塗っちゃえばよくね？
                        ctx_0.fillStyle = 現在の色.rgb;
                        ctx_0.beginPath();
                        ctx_0.arc(x+0.5, y+0.5, Math.max(0,Math.floor(圧力直径/2)-1), 0, Math.PI * 2);//ちょっとちっちゃめにしとこうぜ
                        //+0.5は、円周の表示と比べて中心位置がちょいずれてるから入れた
                        ctx_0.fill();
                        */
                    }else if(現在の色.layer==1){
                        ctx_1.putImageData(現在キャンバス_1, 0, 0);//渡すのはデータ部ではない。
                        /*
                        //ここで塗ることで時短。筆圧で変化するようにしたらアレになるかも？
                        //残りはもう直接塗っちゃえばよくね？
                        ctx_1.fillStyle = 現在の色.rgb;
                        ctx_1.beginPath();
                        ctx_1.arc(x+0.5, y+0.5, Math.max(0,Math.floor(圧力直径/2)-1), 0, Math.PI * 2);//ちょっとちっちゃめにしとこうぜ
                        //+0.5は、円周の表示と比べて中心位置がちょいずれてるから入れた
                        //ctx_1.fill();
                        */
                    }


                    //次回の始点を更新更新！
                    if (e.touches) {//これ指じゃね？
                        前回のマウス.x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        前回のマウス.x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                }


                function 円を描く(x, y, 直径,ガワだけ) {
                    //円周部分だけはしっかりと3ピクセルくらいだけ描いて、真ん中はまあ適当にって感じ
                    var 半径 =Math.floor(直径/2);
                    var 半径の二乗 = 直径*直径/4;

                    //レイヤー分けは不要だよね（だよねだよね）

                    if(ガワだけ){
                        var 描き初め=Math.max(0, 半径-2); //マイナスの値ってなにが適切なんだろうね           
                    }else{
                        var 描き初め=0;    
                    }
                    for(var r=描き初め; r<=半径; r++){//ちゃんと描く。
                        for (const [i, j] of 円周マスク[r]) {
                            if(i+x<0 || i+x>=canvas_0.width || j+y<0 || j+y>=canvas_0.height){
                                continue;//キャンバス外は無視
                            }
                            if (i * i + j * j <= 半径の二乗) {//半径に収まっていれば
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4] = 現在の色.r;//直接色変える
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4+1] = 現在の色.g;//直接色変える
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4+2] = 現在の色.b;//直接色変える
                                現在キャンバス_データ部分[((y + j) * canvas_0.width + (x + i))*4+3] = 現在の色.a;//直接色変える
                            }
                        }
                    }    
                     
                }
                
                function 描き終わり() {
                    if(スマホチョン押し保存){//二本指タップ時にスマホチョン押し保存を破壊してる。
                        描き途中(スマホチョン押し保存);
                    }
                    drawing = false;
                    履歴残し();
                    
                }

                function バケツ(e){
                    現在キャンバス_0 = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    現在キャンバス_1 = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                    var 現在キャンバス_データ部分_0= 現在キャンバス_0.data;
                    var 現在キャンバス_データ部分_1= 現在キャンバス_1.data;

                    var キャンバス位置 = canvas_0.getBoundingClientRect();//まあこれはどっちでもいいよね
                    var x, y;

                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    //マウス位置の色を取得
                    //レイヤー0が透明だったらレイヤー1を参照
                    if(ctx_0.getImageData(x, y, 1, 1).data[3]!=0){
                        //透明じゃねえな
                        if(現在の色.layer==1){
                            //そこ、レイヤー0に色があるのでレイヤー1の色塗ろうとすると死にます。
                            return;
                        }
                        var 塗られる色 = ctx_0.getImageData(x, y, 1, 1).data;
                        var 参照レイヤー=0;
                    }else{    
                        if(現在の色.a==0){//いや、お前も透明色じゃねえか
                            return;
                        }
                        var 塗られる色 = ctx_1.getImageData(x, y, 1, 1).data;
                        var 参照レイヤー=1;
                    }
                    //塗られる色と、今から塗る色が同じだと意味ないし無限ループ入るから終了する。
                    if (塗られる色[0] === 現在の色.r && 塗られる色[1] === 現在の色.g && 塗られる色[2] === 現在の色.b && 塗られる色[3] === 現在の色.a) {
                        return;
                    }
                    var キュー = [[x, y]];

                    //キューが無くなるまでループして、色を判定→周囲をキューに入れる→自分を塗って削除を繰り返す
                    while (キュー.length > 0) {
                        var [キューx, キューy] = キュー.pop();//キューの先頭を取り出す
                        //キャンバス外は無視
                        if (キューx < 0 || キューx >= canvas_0.width || キューy < 0 || キューy >= canvas_0.height) {
                            continue;
                        }
                        if(参照レイヤー==0){
                            //すでに塗られている色は無視
                            if (現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4] === 塗られる色[0] 
                            && 現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4+1] === 塗られる色[1] 
                            && 現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4+2] === 塗られる色[2] 
                            && 現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4+3] === 塗られる色[3]) {
                                //お前の色はバケツ対象だから、周囲をキューにぶち込む
                                キュー.push([キューx + 1, キューy]);
                                キュー.push([キューx - 1, キューy]);
                                キュー.push([キューx, キューy + 1]);
                                キュー.push([キューx, キューy - 1]);

                                //塗る
                                現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4] = 現在の色.r;//直接色変える
                                現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 1] = 現在の色.g;//直接色変える  
                                現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 2] = 現在の色.b;//直接色変える
                                現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 3] = 現在の色.a;//直接色変える
                            }

                        }else{
                            //レイヤー0が透明だから…
                            if (現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4+3] == 0) {
                                if (現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4] === 塗られる色[0] 
                                && 現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4+1] === 塗られる色[1] 
                                && 現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4+2] === 塗られる色[2] 
                                && 現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4+3] === 塗られる色[3]) {
                                    //お前の色はバケツ対象だから、周囲をキューにぶち込む
                                    キュー.push([キューx + 1, キューy]);
                                    キュー.push([キューx - 1, キューy]);
                                    キュー.push([キューx, キューy + 1]);
                                    キュー.push([キューx, キューy - 1]);

                                    //塗る
                                    if(現在の色.layer==0){
                                        現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4] = 現在の色.r;//直接色変える
                                        現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 1] = 現在の色.g;//直接色変える  
                                        現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 2] = 現在の色.b;//直接色変える
                                        現在キャンバス_データ部分_0[(キューy * canvas_0.width + キューx) * 4 + 3] = 現在の色.a;//直接色変える
                                    }else{
                                        現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4] = 現在の色.r;//直接色変える
                                        現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4 + 1] = 現在の色.g;//直接色変える  
                                        現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4 + 2] = 現在の色.b;//直接色変える
                                        現在キャンバス_データ部分_1[(キューy * canvas_0.width + キューx) * 4 + 3] = 現在の色.a;//直接色変える
                                    }

                                }

                            }
                        }
                    }
                    //画像をcanvasへ反映
                    ctx_0.putImageData(現在キャンバス_0, 0, 0);//渡すのはデータ部ではない。
                    ctx_1.putImageData(現在キャンバス_1, 0, 0);//渡すのはデータ部ではない。
                    
                    //document.getElementById("デバッグ用").textContent ="終";
                    履歴残し();
                }

                function スポイトの色表示(x,y){
                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.left = x+10+"px";
                    マウス追従.style.top =  y+10+"px";

                    var canv_x, canv_y;
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    canv_x = Math.floor((x - キャンバス位置.left )/キャンバス拡大率);
                    canv_y = Math.floor((y - キャンバス位置.top )/キャンバス拡大率);
                    
                    マウス追従.style.display = "block"; // マウス追従を表示

                    //色もっていく
                    var そこの色 = ctx_0.getImageData(canv_x, canv_y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        そこの色=ctx_1.getImageData(canv_x, canv_y, 1, 1).data;
                    }
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    マウス追従.style.backgroundColor = 色文字列; // 色を適用
                    
                }

                function 色参照スポイトの色表示(x,y){

                    var canv_x, canv_y;
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    canv_x = Math.floor((x - キャンバス位置.left )/キャンバス拡大率);
                    canv_y = Math.floor((y - キャンバス位置.top )/キャンバス拡大率);
                    

                    //色もっていく
                    var そこの色 = ctx_0.getImageData(canv_x, canv_y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        そこの色=ctx_1.getImageData(canv_x, canv_y, 1, 1).data;
                    }
                    選択色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    //ここから色々やる
                    色参照の色更新(そこの色[0],そこの色[1],そこの色[2],選択色文字列);
                }

                function 色参照の色更新(r,g,b,rgb){
                    [選択された色相,選択された彩度,選択された明度]= rgbからhsv(r,g,b);
                    選択色文字列=rgb;

                    var キャンバスでかさ_色相 = 色相バー.getBoundingClientRect();
                    var キャンバスでかさ_彩度 = 彩度表示.getBoundingClientRect();
                    var CSSでかさ_色相=getComputedStyle(色相バー);
                    var CSSでかさ_彩度=getComputedStyle(彩度表示);
                    var [r, g, b] = hsvからRgb(選択された色相, 1, 1);//色相以外無視した色作る
                    var 選択色文字列_色相= "#"+[r, g, b].map(n => n.toString(16).padStart(2, '0')).join('');//各要素に対して、16進数にしたあとに2桁未満なら0を付けて、文字列結合する
                    今の色相.style.backgroundColor=選択色文字列_色相;
                    今の色相.style.left = 選択された色相*(キャンバスでかさ_色相.width-parseFloat(CSSでかさ_色相.borderLeftWidth)*2)+"px";//あってんの？まあいいけど
                    彩度エリアの表示(選択された色相);
                    今の彩度.style.backgroundColor=rgb;
                    今の色表示.style.backgroundColor=rgb;
                    今の彩度.style.top = (1-選択された明度)*(キャンバスでかさ_彩度.height-parseFloat(CSSでかさ_彩度.borderBottomWidth)*2)+"px";
                    今の彩度.style.left = 選択された彩度*(キャンバスでかさ_彩度.width-parseFloat(CSSでかさ_彩度.borderLeftWidth)*2)+"px";
                }

                function スポイト端っこ表示(e){
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var x, y;
                    
                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }

                    //範囲外なら無視
                    if (x < 0 || x >= canvas_0.width || y < 0 || y >= canvas_0.height) {
                        return;
                    }

                    var マウス追従 = document.getElementById("マウス追従");
                    //ここでは画面の左下に表示
                    マウス追従.style.left = 0 + "px";
                    マウス追従.style.top =真ん中分割.clientHeight+"px";

                    マウス追従.style.display = "block"; // マウス追従を表示
                    
                    //色縫っていく
                    var そこの色 = ctx_0.getImageData(x,y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        そこの色=ctx_1.getImageData(x, y, 1, 1).data;
                    }
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    マウス追従.style.backgroundColor = 色文字列; // 色を適用

                }

                function スポイト反映(e){
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var x, y;
                    
                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    
                    //範囲外なら無視
                    if (x < 0 || x >= canvas_0.width || y < 0 || y >= canvas_0.height) {
                        return;
                    }

                    

                    //マウス位置の色を取得
                    var そこの色 = ctx_0.getImageData(x, y, 1, 1).data;
                    //透明だったら
                    if(そこの色[3]==0){
                        そこの色=ctx_1.getImageData(x, y, 1, 1).data;
                    }
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    //radio_divに同じ色のやつがないか探す
                    var 色箱一覧 = document.querySelectorAll(".色箱_input");

                    for (var i = 1; i < 色箱一覧.length; i++) {//i=0は消しゴムなので無視。
                        var 色箱 = 色箱一覧[i];
                        //idが数字じゃないやつは無視
                        if (isNaN(色箱.id.split("_")[2])){
                            continue;
                        }
                        if (色箱.value.toLowerCase() === 色文字列.toLowerCase()) {//.toLowerCase()は小文字にするやつ
                            // 同じ色が見つかった場合、その色を選択
                            色箱.parentElement.parentElement.querySelector(".radio").checked = true;
                            選択色変更(色箱.value, 色箱.parentElement.parentElement.id);
                            自動ツール選択("pen");
                            return;
                        }
                    }
                    //同じ色がいなかったら今選択されているradioの色をこいつに変える
                    //まって！消しゴムレイヤーの色を変化させることは許されないわよ！
                    if(現在の色.layer==0 && 現在の色.num==0){
                        alert("消しゴムの色はかわらないよ～ん");//OK押すのがめんどくさいし、なんかちゃんとしたやつ作ったほうがいいのでは？と思いつつ…
                        return;
                    }
                    //これ、場合によっては下のレイヤーの色を上のレイヤーとして取得しちゃうな…まあいいか！（まあいいかでゆっちであった。）
                    var radio_div要素 = document.getElementById("color_" + 現在の色.layer + "_" + 現在の色.num);
                    var input要素 = radio_div要素.querySelector(".色箱_input");
                    input要素.value =色文字列;
                    input要素.dispatchEvent(new Event("input"));//inputが変更されたことにすることができる
                    選択色変更(input要素.value,"color_" + 現在の色.layer + "_" + 現在の色.num);
                    自動ツール選択("pen");
                }

                function 色参照スポイト反映(e){
                    if (e.touches) {//これ指じゃね？
                        色参照スポイトの色表示(e.touches[0].clientX, e.touches[0].clientY);
                    } else {//マウスだわ
                        色参照スポイトの色表示(e.clientX, e.clientY);
                    }
                    優先ツール="";                    
                    色参照スポイト.classList.remove("色参照スポイト_clicked");
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+現在のツール+"16.png),default"; // カスタムカーソルを適用
                    //以上！…ほんとに？
                }

                function スポイト非表示(){
                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.display = "none"; // マウス追従を非表示
                }

                var 動かし前指間距離 = 0;
                var 前回指間座標 = [0, 0];

                function 指間距離計算(touches) {
                    var dx = touches[0].clientX - touches[1].clientX;
                    var dy = touches[0].clientY - touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }

                function 指間座標計算(e) {
                    return [(e.touches[0].clientX + e.touches[1].clientX) / 2, (e.touches[0].clientY + e.touches[1].clientY) / 2];
                }
                真ん中分割.addEventListener("pointerdown", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    // スクロールバー上でのクリックを無視
                    if (e.clientX > 真ん中分割.clientWidth+真ん中分割.getBoundingClientRect().left || e.clientY > 真ん中分割.clientHeight+真ん中分割.getBoundingClientRect().top) {
                        return;
                    }
                    真ん中分割.setPointerCapture(e.pointerId);//ポインターを追跡する。どっか行ってもキャンセルを監視できる
                    
                    if(優先ツール==="色参照スポイト"){
                        return;
                    }

                    // 右クリックはスポイト
                    if (e.button === 2) {
                        自動ツール選択("supoito");
                        スポイトの色表示(e.x, e.y);
                        return;
                    }

                    if(現在のツール==="pen"){
                        描き始め(e);
                    }else if(現在のツール==="baketu"){
                        バケツ(e);
                    }else if(現在のツール==="supoito"){
                        
                    }
                });
                真ん中分割.addEventListener("pointermove", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    if(優先ツール==="色参照スポイト"){
                        return;
                    }

                    if(現在のツール==="pen"){
                        描き途中(e);
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                    }
                    
                });
                canvas_0.addEventListener("contextmenu", function(e){
                    e.preventDefault(); // 右クリックメニューを消す
                });
                canvas_0.addEventListener("pointermove", function(e){
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    if(優先ツール==="色参照スポイト"){
                        色参照スポイトの色表示(e.x, e.y);
                        return;
                    }

                    if(現在のツール==="pen"){

                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                        スポイトの色表示(e.x, e.y);
                    }

                });
                canvas_0.addEventListener("pointerleave", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    if(優先ツール==="色参照スポイト"){
                        return;
                    }

                    if(現在のツール==="pen"){
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                        スポイト非表示();
                    }
                });

                真ん中分割.addEventListener("pointerup", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    if(優先ツール==="色参照スポイト"){
                        色参照スポイト反映(e);
                        return;
                    }

                    if(現在のツール==="pen"){
                        描き終わり();
                    }else if(現在のツール==="baketu"){
                        
                    }else if(現在のツール==="supoito"){
                        スポイト反映(e);
                    }
                    
                });
                真ん中分割.addEventListener("pointercancel", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }

                    if(優先ツール==="色参照スポイト"){
                        return;
                    }

                    if(現在のツール==="pen"){
                        描き終わり();
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){

                    }
                });

                真ん中分割.addEventListener("wheel", function(e) {
                    //スクロールバーの上でのホイール操作を無視

                    if (e.clientX < 真ん中分割.clientWidth+真ん中分割.getBoundingClientRect().left && e.clientY < 真ん中分割.clientHeight+真ん中分割.getBoundingClientRect().top) {
                        e.preventDefault();
                        キャンバス拡大(e.deltaY > 0 ? -0.1 : 0.1, e.clientX, e.clientY);
                    }else if(e.clientY > 真ん中分割.clientHeight+真ん中分割.getBoundingClientRect().top){
                        e.preventDefault();
                        //上下スクロールでキャンバスの横向きの位置を調整する.カクカクするけど、いいよね！
                        真ん中分割.scrollLeft += e.deltaY/2;
                    }
                }); 

                function キャンバス拡大(拡大率, 中心x, 中心y){                    
                    var キャンバス位置 = canvas_0.getBoundingClientRect();
                    var 変動前位置x=(中心x - キャンバス位置.left )/キャンバス拡大率;
                    var 変動前位置y=(中心y - キャンバス位置.top )/キャンバス拡大率;

                    var 前拡大率 = キャンバス拡大率;
                    キャンバス拡大率 += 拡大率;
                    キャンバス拡大率 = Math.max(0.1, キャンバス拡大率);
                    キャンバス拡大率 = Math.min(10, キャンバス拡大率);

                    //キャンバスの位置を調整する
                    真ん中分割.scrollLeft +=  (中心x - キャンバス位置.left )*(キャンバス拡大率/前拡大率-1);
                    真ん中分割.scrollTop += (中心y - キャンバス位置.top )*(キャンバス拡大率/前拡大率-1);
                 

                    //キャンバスを拡大（ズラす→拡大の順番じゃないとどうやら非同期処理で計算狂うっぽい）
                    canvas_0.style.transform = "scale("+キャンバス拡大率+")";
                    canvas_1.style.transform = "scale("+キャンバス拡大率+")";
                    キャンバスボーダー設定();
                    //ま、それでもちょっとずれてるけどね

                }

                真ん中分割.addEventListener("touchstart", function(e) {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        撒き戻しやり直し判定=2;
                        moveカウント=0;
                    } else if (e.touches.length ===3) {
                        e.preventDefault();
                        撒き戻しやり直し判定=3;
                        moveカウント=0;
                    } else if (e.touches.length > 3) {
                        // 指が4本以上の場合は反応しない
                    }else{
                        e.preventDefault();
                        if(優先ツール==="色参照スポイト"){
                            スポイト追従座標=e;
                            return;
                        }
                        if(現在のツール==="pen"){
                            描き始め(e);
                        }else if(現在のツール==="baketu"){
                            moveカウント=0;
                            スマホチョン押し保存=e;//ここで保存しないと、指を離したときにはどっかいってる。
                        }else if(現在のツール==="supoito"){
                            スポイト追従座標=e;
                        }
                    }
                });

                真ん中分割.addEventListener("touchmove", function(e) {
                    if(moveカウント>5){
                        撒き戻しやり直し判定=0;//まあちょっと動いたし無効化…って判定シビアじゃない？
                        スマホチョン押し保存=null;//無効にしないと、バケツで暴発する。
                    }else{
                        moveカウント+=1;
                        if (e.touches.length === 2 & 撒き戻しやり直し判定!=3) {
                            撒き戻しやり直し判定=2;
                            スマホチョン押し保存=null;//なんか違うよね、君
                            前回指間座標 = 指間座標計算(e);
                            動かし前指間距離 = 指間距離計算(e.touches);
                        }else if (e.touches.length === 3) {
                            撒き戻しやり直し判定=3;
                            スマホチョン押し保存=null;//なんか違うよね、君
                        }
                        return;//動いてないとする。1pxくらい動くと反応するかな
                    }
                    
                    if (e.touches.length === 2) {
                        drawing=false;
                        スマホチョン押し保存=null;//無効にしないと、描き終わりで暴発する。描き途中()の中でdrawing殺してるんだからわざわざやらんでもいいんだけどね
                        スポイト追従座標=null;
                        e.preventDefault();
                        //拡大操作
                        var 指間距離 = 指間距離計算(e.touches);
                        var 変動率 = 指間距離 / 動かし前指間距離;
                        動かし前指間距離 = 指間距離;
                        キャンバス拡大((変動率-1)*キャンバス拡大率,指間座標計算(e)[0] , 指間座標計算(e)[1]);
                        //移動操作
                        //合計移動量が少ないなら移動しない…は実装せんでええか
                        真ん中分割.scrollLeft += (前回指間座標[0] - 指間座標計算(e)[0]);//拡大してても影響ないよ～～ん
                        真ん中分割.scrollTop += (前回指間座標[1] - 指間座標計算(e)[1]);
                        前回指間座標 = 指間座標計算(e);
                    } else if (e.touches.length ===3) {
                        drawing=false;
                        スマホチョン押し保存=null;//無効にしないと、描き終わりで暴発する。描き途中()の中でdrawing殺してるんだからわざわざやらんでもいいんだけどね
                        スポイト追従座標=null;
                        e.preventDefault();
                    } else if (e.touches.length > 3) {
                        // 指が4本以上の場合は反応しない
                    }else{
                        e.preventDefault();//画面スクロールとか無効にしちゃうよ～ん
                        
                        if(優先ツール==="色参照スポイト"){
                            スポイト追従座標=e;
                            色参照スポイトの色表示(e.touches[0].clientX, e.touches[0].clientY);
                            return;
                        }

                        if(現在のツール==="pen"){
                            描き途中(e);
                        }else if(現在のツール==="baketu"){
                            //判定はこの関数の上のほうでやってるので。
                        }else if(現在のツール==="supoito"){
                            スポイト追従座標=e;
                            スポイト端っこ表示(スポイト追従座標);
                        }
                    }
                });

                真ん中分割.addEventListener("touchend", function(e) {
                    e.preventDefault();//画面スクロールとか無効にしちゃうよ～ん

                    if(優先ツール==="色参照スポイト"){
                        if(スポイト追従座標){
                            色参照スポイト反映(スポイト追従座標);
                        }
                    }else{
                        if(現在のツール==="pen"){
                            描き終わり();
                        }else if(現在のツール==="baketu"){
                            if(スマホチョン押し保存){
                                バケツ(スマホチョン押し保存);
                                スマホチョン押し保存=null;
                            }
                        }else if(現在のツール==="supoito"){
                            if(スポイト追従座標){
                                スポイト反映(スポイト追従座標);
                            }
                            
                        }
                    }
                    

                    if(撒き戻しやり直し判定===2){
                        描き戻し();
                    }else if(撒き戻しやり直し判定===3){
                        やり直し();
                    }
                    撒き戻しやり直し判定=0;
                });

                document.addEventListener("keydown", function(e) {

                    if (e.ctrlKey && e.key === "z") {
                        e.preventDefault(); // デフォルトの動作を無効化
                        描き戻し();
                    } else if (e.ctrlKey && e.key === "y") {
                        e.preventDefault(); // デフォルトの動作を無効化
                        やり直し();
                    } else if (e.key === "e") {
                        e.preventDefault(); // デフォルトの動作を無効化
                        //ツールをペンに変える…はしなくていいか
                        if(現在の色.layer!=0 || 現在の色.num!=0){//消しゴムじゃないな…
                            console.log("moge1");
                            選択色変更("#FFFFFF","color_0_0");
                            var radio要素 = document.getElementById("color_radio_0_0");
                            radio要素.checked = true;
                        }else{
                            選択色変更(最後の色.rgb,"color_" + 最後の色.layer + "_" + 最後の色.num);
                            var radio要素 = document.getElementById("color_radio_" + 現在の色.layer + "_" + 現在の色.num);
                            radio要素.checked = true;
                        }
                    } else if (Number.isInteger(Number(e.key))) {
                        var color_0_div = document.getElementById("color_0");
                        var radio_0 = color_0_div.querySelectorAll(".radio_div");
                        var color_1_div = document.getElementById("color_1");
                        var radio_1 = color_1_div.querySelectorAll(".radio_div");
                        var キーボード入力値=Number(e.key)-1;
                        //console.log(キーボード入力値);
                        if(キーボード入力値<0){
                            キーボード入力値=0;
                        }else if(radio_0.length+radio_1.length<=キーボード入力値){
                            キーボード入力値=radio_0.length+radio_1.length-1;
                        }
           
                        if(radio_0.length>キーボード入力値){
                            var 色箱 = document.getElementById("color_pick_" + 0 + "_" + キーボード入力値);
                            色箱.parentElement.parentElement.querySelector(".radio").checked = true;
                            選択色変更(色箱.value,"color_" +0 + "_" +キーボード入力値);

                        }else{
                            キーボード入力値-=radio_0.length;
                            var 色箱 = document.getElementById("color_pick_" + 1 + "_" + キーボード入力値);
                            色箱.parentElement.parentElement.querySelector(".radio").checked = true;
                            選択色変更(色箱.value,"color_" +1+ "_" +キーボード入力値);

                        }
                    }
                });

                
                document.getElementById("描き戻しボタン").addEventListener("click", function() {
                    描き戻し();
                });

                document.getElementById("やり直しボタン").addEventListener("click", function() {
                    やり直し();
                });


                document.getElementById("コピーボタン").addEventListener("click", function() {
                    //テキストもコピーできるかな～て思ったけど、できるけどできないみたい。
                    var 合成キャンバス=new OffscreenCanvas(canvas_0.width, canvas_0.height);
                    var 合成結果=合成キャンバス.getContext("2d");
                    合成結果.drawImage(canvas_1,0,0);
                    合成結果.drawImage(canvas_0,0,0);
                    合成キャンバス.convertToBlob().then(function(blob) {
                        const item = new ClipboardItem({ "image/png": blob });//HTTPSかhttp://127.0.0.1/じゃないとうごかない、らしいね。
                        navigator.clipboard.write([item]).then(function() {
                        }).catch(function(err) {
                            console.error("クリップボードへのコピーに失敗しました:", err);
                        });
                        Canvas保存();
                    });
                });

                document.getElementById("保存").addEventListener("click", function() {
                    var 合成キャンバス=new OffscreenCanvas(canvas_0.width, canvas_0.height);
                    var 合成結果=合成キャンバス.getContext("2d");
                    合成結果.drawImage(canvas_1,0,0);
                    合成結果.drawImage(canvas_0,0,0);
                    合成キャンバス.convertToBlob().then(function(blob) {//HTTPSかhttp://127.0.0.1/じゃないとうごかない、らしいね。
                        var link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        const date = new Date();
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, '0');  // 月は0から始まるので+1
                        const day = String(date.getDate()).padStart(2, '0');
                        const hours = String(date.getHours()).padStart(2, '0');
                        const minutes = String(date.getMinutes()).padStart(2, '0');
                        const seconds = String(date.getSeconds()).padStart(2, '0');
                        link.download = year+month+day+hours+minutes+seconds+"_deyukaki.png";//ファイル名決めてる
                        link.click();//強制クリック
                        Canvas保存();
                    });
                });

                document.getElementById("白紙").addEventListener("click", function() {
                    キャンバスを白で塗りつぶす();
                    履歴残し();
                    
                });

                //ここからはカラーピッカーの実装ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

                function hsvからRgb(h, s, v) {//引数は0~1
                    let r, g, b;
                    const i = Math.floor(h * 6);//角度から、rgbのどの領域なのかを選択
                    const f = h * 6 - i;
                    const p = v * (1 - s);
                    const q = v * (1 - f * s);
                    const t = v * (1 - (1 - f) * s);

                    switch (i % 6) {
                        case 0: r = v; g = t; b = p; break;
                        case 1: r = q; g = v; b = p; break;
                        case 2: r = p; g = v; b = t; break;
                        case 3: r = p; g = q; b = v; break;
                        case 4: r = t; g = p; b = v; break;
                        case 5: r = v; g = p; b = q; break;
                    }
                    return [
                        Math.round(r * 255),
                        Math.round(g * 255),
                        Math.round(b * 255)
                    ];
                }

                function rgbからhsv(r,g,b){
                    r /= 255;
                    g /= 255;
                    b /= 255;
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    let h, s, v = max;

                    const d = max - min;
                    s = max === 0 ? 0 : d / max;//最大値が0の場合は黒色なので彩度の計算ができないのをカバー

                    if (max === min) {
                        h = 0; // achromatic
                    } else {
                        switch (max) {
                            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                            case g: h = (b - r) / d + 2; break;
                            case b: h = (r - g) / d + 4; break;
                        }
                        h /= 6;
                    }
                    return [h,s,v];
                }

                var 今の色表示=document.getElementById("今の色表示");

                var 色相バー=document.getElementById("色相選択");
                var 色相選択=色相バー.getContext("2d");
                var 色相選択の画像データ = 色相選択.createImageData(360, 1);
                var 今の色相=document.getElementById("今の色相");
                
                var 彩度表示 = document.getElementById("彩度選択");
                var 彩度選択 = 彩度表示.getContext("2d");
                var 彩度選択の画像データ = 彩度選択.createImageData(256, 256);
                var 今の彩度=document.getElementById("今の彩度");

                var 色参照スポイト=document.getElementById("色参照スポイト");
                var 採用ボタン_color=document.getElementById("採用ボタン_color");
                var 破棄ボタン_color=document.getElementById("破棄ボタン_color");

                var 選択色文字列="#000000";
                var 選択された色相 = 0;
                var 選択された彩度 = 0;
                var 選択された明度 = 0;

                for (let i = 0; i < 360; i++) {
                    var [r, g, b] = hsvからRgb(i / 360, 1,1);
                    色相選択の画像データ.data[i*4] = r;
                    色相選択の画像データ.data[i*4 + 1] = g;
                    色相選択の画像データ.data[i*4 + 2] = b;
                    色相選択の画像データ.data[i*4 + 3] = 255;
                }
                色相選択.putImageData(色相選択の画像データ, 0, 0);



                function 彩度エリアの表示(角度) {
                    for (let y = 0; y < 256; y++) {
                        for (let x = 0; x < 256; x++) {
                            const s = x / 255;
                            const v = 1 - y / 255;
                            const [r, g, b] = hsvからRgb(角度, s, v);
                            const index = (y * 256 + x) * 4;
                            彩度選択の画像データ.data[index] = r;
                            彩度選択の画像データ.data[index + 1] = g;
                            彩度選択の画像データ.data[index + 2] = b;
                            彩度選択の画像データ.data[index + 3] = 255;
                        }
                    }
                    彩度選択.putImageData(彩度選択の画像データ, 0, 0);
                    今の彩度.style.backgroundColor=選択色文字列;
                    今の色表示.style.backgroundColor=選択色文字列;
                    
                }
                彩度エリアの表示(0);

                

                function 色相変更(e){
                    if(isNaN(e.offsetX)){//NaNだったら拒否
                        return;
                    }
                    var キャンバスでかさ = 色相バー.getBoundingClientRect();
                    var CSSでかさ=getComputedStyle(色相バー);
                    //borderがクリック範囲に入ってやがるので計算で消す。
                    選択された色相 = Math.floor(e.offsetX/(キャンバスでかさ.width-parseFloat(CSSでかさ.borderLeftWidth)*2)*360);
                    選択された色相 =Math.min(Math.max(選択された色相 , 0), 359)/360;
                    var [r, g, b] = hsvからRgb(選択された色相, 1, 1);
                    var 選択色文字列_色相= "#"+[r, g, b].map(n => n.toString(16).padStart(2, '0')).join('');//各要素に対して、16進数にしたあとに2桁未満なら0を付けて、文字列結合する
                    今の色相.style.backgroundColor=選択色文字列_色相;
                    今の色相.style.left = 選択された色相*(キャンバスでかさ.width-parseFloat(CSSでかさ.borderLeftWidth)*2)+"px";//あってんの？まあいいけど

                    [r, g, b] = hsvからRgb(選択された色相, 選択された彩度, 選択された明度);
                    選択色文字列 = "#"+[r, g, b].map(n => n.toString(16).padStart(2, '0')).join('');//各要素に対して、16進数にしたあとに2桁未満なら0を付けて、文字列結合する
                    彩度エリアの表示(選択された色相);
                    
                }
                function 彩度変更(e){
                    if(isNaN(e.offsetX) || isNaN(e.offsetY)){//NaNだったら拒否
                        return;
                    }
                    var キャンバスでかさ = 彩度表示.getBoundingClientRect();
                    var CSSでかさ=getComputedStyle(彩度表示);
                    var x = Math.floor(e.offsetX/(キャンバスでかさ.width-parseFloat(CSSでかさ.borderLeftWidth)*2)*256);
                    var y = Math.floor(e.offsetY/(キャンバスでかさ.height-parseFloat(CSSでかさ.borderBottomWidth)*2)*256);
                    x=Math.min(Math.max(x , 0), 255);
                    y=Math.min(Math.max(y , 0), 255);
                    選択された彩度 = x / 255;
                    選択された明度 = 1 - y / 255;
                    var [r, g, b] = hsvからRgb(選択された色相, 選択された彩度, 選択された明度);
                    選択色文字列 = "#"+[r, g, b].map(n => n.toString(16).padStart(2, '0')).join('');//各要素に対して、16進数にしたあとに2桁未満なら0を付けて、文字列結合する
                    今の彩度.style.backgroundColor=選択色文字列;
                    今の色表示.style.backgroundColor=選択色文字列;
                    今の彩度.style.top = (1-選択された明度)*(キャンバスでかさ.height-parseFloat(CSSでかさ.borderBottomWidth)*2)+"px";
                    今の彩度.style.left = 選択された彩度*(キャンバスでかさ.width-parseFloat(CSSでかさ.borderLeftWidth)*2)+"px";
                }

                色参照スポイト.addEventListener("click",function(){
                    優先ツール="色参照スポイト";
                    色参照スポイト.classList.add("色参照スポイト_clicked");
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/supoito16.png),default"; // カスタムカーソルを適用
                })

                採用ボタン_color.addEventListener("click",function(){
                    カラーピッカー.style.display="none";
                    優先ツール="";
                    色参照スポイト.classList.remove("色参照スポイト_clicked");
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+現在のツール+"16.png),default"; // カスタムカーソルを適用
                    //数字に変換できるレイヤーなら通常色変更として処理
                    if(!isNaN(変更する色.layer)){
                        //作成した色に、変更する
                        選択色変更(選択色文字列, "color_" + 変更する色.layer + "_" + 変更する色.num);
                        //表示も合わせる
                        var radio_div要素 = document.getElementById("color_" + 現在の色.layer + "_" + 現在の色.num);
                        radio_div要素.querySelector(".radio").checked = true;
                        var input要素 = radio_div要素.querySelector(".色箱_input");
                        input要素.value =選択色文字列;
                        input要素.dispatchEvent(new Event("input"));//inputが変更されたことにすることができる
                    }else{
                        //まあ特殊な箱を選択してるんだろう
                        var div要素 = document.getElementById("color_" + 変更する色.layer + "_" + 変更する色.num);
                        var input要素 = div要素.querySelector(".色箱_input");
                        input要素.value =選択色文字列;
                        input要素.dispatchEvent(new Event("input"));//inputが変更されたことにすることができる
                    }
                    
                })

                破棄ボタン_color.addEventListener("click",function(){
                    カラーピッカー.style.display="none";
                    優先ツール="";                    
                    色参照スポイト.classList.remove("色参照スポイト_clicked");
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+現在のツール+"16.png),default"; // カスタムカーソルを適用
                })

                var カラーピッカー = document.getElementById("カラーピッカー");
                var クリックされたよ=false;
                カラーピッカー.addEventListener("pointerdown", function(e){
                    e.preventDefault();
                    クリックされたよ=true;
                });
                カラーピッカー.addEventListener("pointerup", function(e){
                    e.preventDefault();
                    クリックされたよ=false;
                });
                カラーピッカー.addEventListener("pointerleave", function(e){
                    e.preventDefault();
                    クリックされたよ=false;
                });
                
                色相バー.addEventListener("pointerdown", function(e){
                    e.preventDefault();
                    色相変更(e);   
                });
                色相バー.addEventListener("pointermove", function(e){
                    e.preventDefault();
                    if(クリックされたよ){
                        色相変更(e);
                    }
                });
                色相バー.addEventListener("touchmove", function(e) {
                    e.preventDefault();
                    色相変更(e);
                });

                彩度表示.addEventListener("pointerdown", function(e){
                    e.preventDefault();
                    彩度変更(e);   
                });
                彩度表示.addEventListener("pointermove", function(e){
                    e.preventDefault();
                    if(クリックされたよ){
                        彩度変更(e);
                    }
                });
                彩度表示.addEventListener("touchmove", function(e) {
                    e.preventDefault();
                    彩度変更(e);
                });

                //ここから色置換の実装ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
                var スワップメニュー=document.getElementById("スワップメニュー");
                var 採用ボタン_swap=document.getElementById("採用ボタン_swap");
                var 破棄ボタン_swap=document.getElementById("破棄ボタン_swap");

                var 置換される色_input=document.getElementById("color_pick_swap_0");
                var 置換する色_input=document.getElementById("color_pick_swap_1");

                採用ボタン_swap.addEventListener("click",function(){
                    スワップメニュー.style.display="none";              
                    var 置換する色={
                        r:parseInt(置換する色_input.value.slice(1,3),16),
                        g:parseInt(置換する色_input.value.slice(3,5),16),
                        b:parseInt(置換する色_input.value.slice(5,7),16)
                    };
                    var 置換される色={
                        r:parseInt(置換される色_input.value.slice(1,3),16),
                        g:parseInt(置換される色_input.value.slice(3,5),16),
                        b:parseInt(置換される色_input.value.slice(5,7),16)
                    };
                    //canvas_0とcanvas_1の色を置換する
                    var canvas_0_imgData = ctx_0.getImageData(0, 0, canvas_0.width, canvas_0.height);
                    var canvas_1_imgData = ctx_1.getImageData(0, 0, canvas_1.width, canvas_1.height);
                    var data_0 = canvas_0_imgData.data;
                    var data_1 = canvas_1_imgData.data;
                    for (var i = 0; i < data_0.length; i += 4) {
                        //レイヤー0は透明だったら無視
                        if (data_0[i + 3] != 0) {
                            if (data_0[i] === 置換される色.r && data_0[i + 1] === 置換される色.g && data_0[i + 2] === 置換される色.b) {
                                data_0[i] = 置換する色.r;
                                data_0[i + 1] = 置換する色.g;
                                data_0[i + 2] = 置換する色.b;
                                
                            }
                        }
                        if (data_1[i] === 置換される色.r && data_1[i + 1] === 置換される色.g && data_1[i + 2] === 置換される色.b) {
                            data_1[i] = 置換する色.r;
                            data_1[i + 1] = 置換する色.g;
                            data_1[i + 2] = 置換する色.b;
                        }
                    }
                    ctx_0.putImageData(canvas_0_imgData, 0, 0);
                    ctx_1.putImageData(canvas_1_imgData, 0, 0);
                    履歴残し();
                    //このあと同じ色の色箱も色を変えようか考えたけど、まあそれが嫌な時もあるしいいかとしました。
                })

                破棄ボタン_swap.addEventListener("click",function(){
                    スワップメニュー.style.display="none";
                })


                //ページ下部のツイートボタンを上書き
                document.getElementById("foot_tweet_a").href=URL_tweet_text="https://twitter.com/intent/tweet?hashtags=deyukaki";           


                //canvasとか色箱を保存しようぜ！！！！！！！！！！！

                function IndexedDBを開くぞ() {
                    return new Promise((resolve, reject) => { //非同期で動くので、awaitできるようにしておく
                        const request = indexedDB.open("DeyukakiDB", 1);//バージョン1で開く、もしくは生成
                        
                        request.onupgradeneeded = function (event) {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains("canvasData")) {
                                db.createObjectStore("canvasData", { keyPath: "id" });//canvas
                            }
                            if (!db.objectStoreNames.contains("colorData")) {
                                db.createObjectStore("colorData", { keyPath: "id" });//色箱
                            }
                        };
                        request.onsuccess = function (event) {
                            resolve(event.target.result); // データベースを返す
                        };

                        request.onerror = function (event) {
                            resolve(event.target.result); // データベースを返す…失敗してるけどな！
                        };
                    });
                }

                async function Canvas保存() {
                    const db = await IndexedDBを開くぞ();
                    const transaction = db.transaction("canvasData", "readwrite");
                    const store = transaction.objectStore("canvasData");

                    const canvas0Data = canvas_0.toDataURL();
                    const canvas1Data = canvas_1.toDataURL();

                    store.put({ id: "canvas_0", data: canvas0Data });
                    store.put({ id: "canvas_1", data: canvas1Data });

                    
                    console.log("canvas保存するよ");
                }

                async function 色箱保存(保存要素名) {
                    const db = await IndexedDBを開くぞ();
                    const transaction = db.transaction("colorData", "readwrite");
                    const store = transaction.objectStore("colorData");

                    const colorInputs = document.querySelectorAll(".色箱_input");
                    colorInputs.forEach((input, index) => {
                        if(保存要素名==input.parentElement.parentElement.id){
                            store.put({ id: 保存要素名, value: input.value });
                            return;
                        }
                    });
                    //なんか余計なものまで保存されてないかだって？ハッハッハ、そうだぜ。
                }

                async function 読み込み() {
                    const db = await IndexedDBを開くぞ();

                    var transaction = db.transaction("canvasData", "readonly");
                    var store = transaction.objectStore("canvasData");

                    const canvas0Request = store.get("canvas_0");
                    const canvas1Request = store.get("canvas_1");

                    canvas0Request.onsuccess = function () {
                        if (canvas0Request.result) {
                            const img = new Image();
                            img.onload = function () {
                                ctx_0.drawImage(img, 0, 0);
                            };
                            img.src = canvas0Request.result.data;
                        }
                    };

                    canvas1Request.onsuccess = function () {
                        if (canvas1Request.result) {
                            const img = new Image();
                            img.onload = function () {
                                ctx_1.drawImage(img, 0, 0);
                            };
                            img.src = canvas1Request.result.data;
                        }
                    };

                    transaction = db.transaction("colorData", "readonly");
                    store = transaction.objectStore("colorData");

                    const colorInputs = document.querySelectorAll(".色箱_input");
                    colorInputs.forEach((input, index) => {
                        const request = store.get(input.parentElement.parentElement.id);
                        request.onsuccess = function () {
                            if (request.result) {
                                input.value = request.result.value;
                                input.dispatchEvent(new Event("input")); // これでinputが変更されたことにできる
                            }
                        };
                    });
                }
                読み込み();

                /*
                //ページを閉じるときに保存…と思いきや、非同期処理は間に合わないとのこと。とほほ
                window.addEventListener("beforeunload", async function () {
                    await Canvas保存();
                    await 色箱保存();
                });
                */
                var 保存タイマー;
                function Canvas保存タイマー開始() {
                    if (保存タイマー) {
                        clearTimeout(保存タイマー); // タイマーがあればリセット
                    }
                    保存タイマー = setTimeout(() => {
                        Canvas保存();
                    }, 5000); // 最後の書き込みからn秒後に保存
                }
            }
        </script>
    </head>
    <body>
        <div id="top"></div>
        <header id="header">
            <button onclick="html_link_btn()" id="html_link_btn"></button>
            <nav id="html_link_nav">
                <ul id="html_link_ul"></ul>
            </nav>
            <a href="../index.html">
                <img id="go_home" src="../images/site/omotyabako_deka.png" alt="トップページへ" height="1px"><!--ここで高さを入れておかないと、クソでかい画像が一瞬読み込まれてボタンの大きさが暴走する-->
            </a>
            <h1 id="title_h1">
                JUN汁ｗおもちゃばこ。
            </h1>
        </header>
        <div id="mannaka">
            <div id="三分割くん">
                <div id="左分割" class="浮かせる">
                    <div id="左最小化領域">
                        <div id="色選択div">
                            <div id="color_0" class="color_行">
                                <img src="../images/omocha/deyukaki/layer16_0.png" alt="ここはレイヤー0の色選択" class="img_layer">
                                <div class="radio_div" id="color_0_0">
                                    <input type="radio" class="radio" id="color_radio_0_0" name="color">
                                    <div class="色箱" id="color_div_0_0">
                                        <input class="色箱_input" type="color" id="color_pick_0_0" value="#ffffff" disabled style="visibility: hidden;"><!--色変え拒否-->
                                        <div class="色箱_cover 透明色だよ"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_0_1">
                                    <input type="radio" class="radio" id="color_radio_0_1" name="color" checked>
                                    <div class="色箱" id="color_div_0_1">
                                        <input class="色箱_input" type="color" id="color_pick_0_1" value="#000000">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_0_2">
                                    <input type="radio" class="radio" id="color_radio_0_2" name="color">
                                    <div class="色箱" id="color_div_0_2">
                                        <input class="色箱_input" type="color" id="color_pick_0_2" value="#00FFFF">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>
                                
                            </div>

                            <div id="color_1" class="color_行">
                                <img src="../images/omocha/deyukaki/layer16_1.png" alt="ここはレイヤー1の色選択" class="img_layer">
                                <div class="radio_div" id="color_1_0">
                                    <input type="radio" class="radio" id="color_radio_1_0" name="color">
                                    <div class="色箱" id="color_div_1_0">
                                        <input class="色箱_input" type="color" id="color_pick_1_0" value="#ffffff">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_1_1">
                                    <input type="radio" class="radio" id="color_radio_1_1" name="color">
                                    <div class="色箱" id="color_div_1_1">
                                        <input class="色箱_input" type="color" id="color_pick_1_1" value="#FF5558">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>

                                <div class="radio_div" id="color_1_2">
                                    <input type="radio" class="radio" id="color_radio_1_2" name="color">
                                    <div class="色箱" id="color_div_1_2">
                                        <input class="色箱_input" type="color" id="color_pick_1_2" value="#FFF6EF">
                                        <div class="色箱_cover"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="ツール系">
                            <div id="筆の太さ">
                                <div>
                                    <label for="太さ">太さ：</label>
                                    <input type="number" id="太さ" min="1" max="100" value="5">
                                </div>
                                <input type="range" id="slider太さ" min="1" max="100" value="12" step="1">
                                <!--デフォルトは12なんだけど計算すると5pxになる。まあここは初期化してるのでなんでもいいんですが…-->
                            </div>
                            <div id="ツール選択">
                                <label id="pen">
                                    <input type="radio" name="tool" class="tool_radio" id="ペン" value="pen" checked>
                                    <span class="ペンボタン" id="ペン_ボタン"></span>
                                </label>
                                <label id="baketu">
                                    <input type="radio" name="tool" class="tool_radio" id="バケツ" value="bucket">
                                    <span class="ペンボタン" id="バケツ_ボタン"></span>
                                </label>
                                <label id="supoito">
                                    <input type="radio" name="tool" class="tool_radio" id="スポイト" value="supoito">
                                    <span class="ペンボタン" id="スポイト_ボタン"></span>
                                </label>
                            </div>
                            <label id="swap">
                                <span class="ペンボタン" id="スワップ_ボタン"></span>
                            </label>
                        </div>
                    </div>
                    
                    <button id="左最小化"><</button>
                    
                </div>

                <div id="真ん中分割">
                    <div id="スクロールサイズ調整">    
                        <canvas id="cnvs_1" class="描画用" height="450px" width="600px"><!--styleのheigthは見た目の大きさを変えているにすぎない。表示領域はcssじゃない。-->
                        </canvas>      
                        <canvas id="cnvs_0" class="描画用" height="450px" width="600px"><!--styleのheigthは見た目の大きさを変えているにすぎない。表示領域はcssじゃない。-->
                        </canvas>          
                              
                    </div>
                </div>
                
                
                <div id="右分割"class="浮かせる">
                    <div id="デバッグ用">test</div>
                    <button id="右最小化">></button>
                    <div id="右最小化領域">
                        <button id="描き戻しボタン" class="保存系ボタン">↶</button>
                        <button id="やり直しボタン" class="保存系ボタン">↷</button>
                        <button id="コピーボタン" class="保存系ボタン">コピー</button>
                        <button id="保存" class="保存系ボタン">保存</button>
                        <button id="白紙" class="保存系ボタン">左色で埋める</button>
                    </div>

                </div>

                <div id="カラーピッカー">
                    <div id="カラピカ上段">
                        <div id="今の色">
                            <div id="今の色表示"></div>
                            <input id="色参照スポイト" class="色選択ボタン">
                            <input id="採用ボタン_color" type="button" value="採用" class="色選択ボタン 採用ボタン">
                            <input id="破棄ボタン_color" type="button" value="破棄" class="色選択ボタン 破棄ボタン">
                        </div>
                        <div id="彩度選択div">
                            <canvas id="彩度選択" width="256px" height="256px"></canvas>
                            <div id="今の彩度" class="色選択ガイド"></div>
                        </div>
                    </div>
                    <div id="色相選択div">
                        <canvas id="色相選択" width="360px" height="1px"></canvas>
                        <div id="今の色相" class="色選択ガイド"></div>
                    </div>
                </div>

                <div id="スワップメニュー">
                    <div id="スワメニュ上段">
                        <div>
                            変更する色
                            <div class="radio_div" id="color_swap_0">
                                <div class="色箱" id="color_div_swap_0">
                                    <input class="色箱_input" type="color" id="color_pick_swap_0" value="#ff0000">
                                    <div class="色箱_cover"></div>
                                </div>
                            </div>
                        </div>
                        <div>
                            →→→
                        </div>
                        <div>
                            置換先
                            <div class="radio_div" id="color_swap_1">
                                <div class="色箱" id="color_div_swap_1">
                                    <input class="色箱_input" type="color" id="color_pick_swap_1" value="#00ff00">
                                    <div class="色箱_cover"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="スワメニュ下段">
                        <input id="採用ボタン_swap" type="button" value="置換" class="色選択ボタン 採用ボタン">
                        <input id="破棄ボタン_swap" type="button" value="破棄" class="色選択ボタン 破棄ボタン">
                    </div>
                </div>
                

            </div>



            <footer>
                <ul id="footul">
                    <li id="foot_tweet_li">
                        <a href=""  target="_blank" rel="noopener noreferrer" id="foot_tweet_a"><!--onload_functions()でhrefを書き込んでるで！-->
                            <img src="../images/site/twitterbutton.gif" alt="ツイートボタン" id="tweet_img">
                        </a>
                    </li>
                    <li>
                        <a href="./deyukaki_setumeisyo.html" target="_blank">このツールの説明書はここにあるよー！（別タブ）</a>
                    </li>
                </ul>
            </footer>
            <div id="マウス追従" calss="マウス追従"></div>
        </div>
    </body>
</html>
