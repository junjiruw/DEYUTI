<!DOCTYPE html>
<html lang="ja">
    <head prefix="og: http://ogp.me/ns# website: http://ogp.me/ns/website#">
        <meta charset="UTF-8">
        <!--文字コードは上のほうにないとすべておしまいになるらしい-->
        <meta name="description" content="でゆっち用お絵描きソフトウェア #deyukaki">                                                                 <!--ページ説明　入力すること！-->
        <title>JUN汁ｗおもちゃばこ。/おもちゃ/でゆ描き</title>                                                         <!--タイトル　入力すること！-->
        <!--OGPとかいうの-->
        <meta property="og:site_name" content="JUN汁ｗおもちゃばこ。/omocha/deyukaki">                                <!--タイトル　入力すること！-->
        <meta property="og:title" content="でゆ描き">                                                               <!--タイトル　入力すること！-->
        <meta property="og:type" content="article"> <!--websiteはトップページ、articleが記事だってさ-->
        <meta property="og:url" content="https://junjiruw.github.io/DEYUTI/omocha/deyukaki.html">                   <!--リンク　入力すること！-->
        <meta property="og:image" content="https://github.com/junjiruw/DEYUTI/blob/master/images/site/junjiruw_bako.png?raw=true">
        <meta name="twitter:card" content="summary"><!--なにを表示するか-->
        <meta name="twitter:site" content="@junjiruw"><!--フッターに表示されるらしい…どこ？-->
        <meta name="viewport" content="width=device-width,initial-scale=1"><!--スマホで見てる人向けに表示領域の設定-->
        <link rel="stylesheet" href="../css/style.css">
        
        <link rel="icon" href="../images/site/favicon32.png">
        <style>
            header{
                position: static;/*fixedじゃなくするとpublic.js内の処理をスキップするよん*/
                
            }
            #html_link_nav{
                z-index: 20; /* 高い値を指定して上に表示 */
            }
            div#mannaka{
                width: 100%;
                margin: 0.5em 0px 0.5em 0px;
                border: 2px solid #ffffff;
                color: #ffffff;   
                font-size: 16px;    
            }
            #三分割くん {
                position: relative;
                height: 100%; /* 親要素の高さに合わせる */
            }

            #真ん中分割 {
                width: 100%;
                height: 100%; /* 親要素の高さに合わせる */
                text-align: center;
                overflow: scroll;
                cursor: url("../images/omocha/deyukaki/pen16.png"),default; /* カスタムカーソル画像 */
            }
            /* スクロールバーの幅を指定 */
            #真ん中分割::-webkit-scrollbar {
                width: 1em; /* 垂直スクロールバーの幅 */
                height: 1em; /* 水平スクロールバーの高さ */
            }
            #真ん中分割::-webkit-scrollbar-track {
                background: #757575;
            }
            #真ん中分割::-webkit-scrollbar-thumb {
                background: #dadada;
                border-radius: 6px;
            }
            #真ん中分割::-webkit-scrollbar-thumb:hover {
                background: #b4b4b4;
            }
            
            #スクロールサイズ調整 {
                position: relative;
                z-index: 1; /* 邪魔なので一番奥に。*/
            }

            canvas {
                position: absolute;
                transform-origin: top left; /* 拡大縮小の基準点を左上に設定 */
                top:0;
                left:0;
                background-clip: padding-box;/*背景色がborderまでいかないようになる*/
                image-rendering: pixelated;/* 画像の拡大縮小時にピクセルを強調する */
                
            }

            .浮かせる {
                position: absolute;
                top: 0;
                background: #555;
                color: #fff;
                
                display: flex;
                justify-content: center;/* 2分割くんの中身を真ん中によせる */
            }

            #左分割 {
                left: 0;
                z-index: 10; /* 高い値を指定して上に表示 */
            }

            #右分割 {
                right: 1em;
                z-index: 10; /* 高い値を指定して上に表示 */
            }

            #左最小化領域 {
                display: flex; /* 子要素を横並びにする */
            }
            .color_行{
                display: flex; /* 子要素を横並びにする */
            }
            #raido_0 {
                display: flex; /* 子要素を横並びにする */
            }
            .radio_div{
                display: flex;
                flex-direction: column; /* ラジオボタンとラベルを縦に並べる */
                align-items: center; /* 中央揃え */
            }

            .radio{
                display: inline-block;
                width: 1em;
                height: 1em;
                border: 2px solid #aaa;
                background-color: #fff;
                border-radius: 50%;
            }
            .radio:checked{
                background-color: rgb(80, 160, 255);
            }
            .色箱{
                position: relative;
                margin: 0.2em;
            }
            .色箱_input {
                position: relative;
                width: 1.5em;
                height: 1.5em;
            }
            .色箱_cover{
                position: absolute;
                pointer-events: none; /* クリックイベントを無効化 */
                cursor: pointer;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 255, 255 ); 
                border: 2px solid #c5c5c5;
            }
            #太さ{
                width: 3em;
                height: 1em;
            }
            #slider太さ{
                width: 8em;
            }
            #ツール選択 input{
                display: none; /* デフォルトのラジオボタンを非表示 */
            }
            .ペンボタン {
                display: inline-block;
                width: 3em; /* ボタンの幅 */
                height: 3em; /* ボタンの高さ */
                background-size: cover; /* 画像をボタン全体にフィットさせる */
                background-repeat: no-repeat; /* 画像を繰り返さない */
                cursor: pointer; /* マウスカーソルをポインターに変更 */
                image-rendering: pixelated; /* ピクセルを強調してぼやけを防ぐ */
                filter: brightness(40%) saturate(20%); /* 色味調整 */
                border: 2px solid #aaa; /* ボタンの枠線 */
            }
            input[type="radio"]:checked + .ペンボタン {
                background-color: #007bff; /* 選択時の背景色（青） */
                filter: brightness(100%) saturate(100%); /* 色味調整 */
            }

            #ペン_ボタン {
                background-image: url("../images/omocha/deyukaki/pen16.png"); 
            }

            #バケツ_ボタン {
                background-image: url("../images/omocha/deyukaki/baketu16.png"); 
            }

            #スポイト_ボタン {
                background-image: url("../images/omocha/deyukaki/supoito16.png");
            }



            .保存系ボタン{
                margin: 0.1em;
                cursor: pointer;
            }
            .保存系ボタン:hover {
                background-color: #ccc;
            }
            .保存系ボタン:active {
                background-color: #aaa;
            }
            #マウス追従{
                display: none; /* デフォルトで非表示 */
                position: absolute;
                background-color: rgb(174, 238, 46);
                border-radius: 50%;
                border: #3b3b3b 2px solid;
                box-shadow: inset 0 0 0 1px white;
                width: 2em;
                height: 2em;
                pointer-events: none; /* マウスイベントを無効化 */
                z-index: 5; /* canvasよりは、高い値を指定して上に表示 */
            }

            /* 横幅が40em未満の場合 */
            @media (max-width: 40em) {
                #右分割 {
                    bottom: 1em; /* 下に配置 */
                    top: auto; /* 上の位置をリセット */
                }
                .radio{
                    width: 2em;
                    height: 2em;
                }
                .色箱_input {
                    position: relative;
                    width: 3em;
                    height: 3em;
                }
                #太さ{
                width: 3em;
                height: 1.5em;
                }
                #slider太さ{
                    width: 10em;
                }
                #マウス追従{
                width: 5em;
                height: 5em;
            }
            }

        </style>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-1MB5XLN4LW"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-1MB5XLN4LW');
        </script>
        <!-- Google tag (gtag.js) -->

        <script src="../js/public.js"></script>
        <script>
            onload = function(){
                onload_functions();

                document.getElementById("左最小化").addEventListener("click", function() {
                    var container = document.getElementById("左最小化領域");
                    if (container.style.display === "none") {
                        container.style.display = "flex";//要検討
                        this.textContent = "<";
                    } else {
                        container.style.display = "none";
                        this.textContent = ">";
                    }
                });
                document.getElementById("右最小化").addEventListener("click", function() {
                    var container = document.getElementById("右最小化領域");
                    if (container.style.display === "none") {
                        container.style.display = "block";//要検討
                        this.textContent = ">";
                    } else {
                        container.style.display = "none";
                        this.textContent = "<";
                    }
                });

                function 真ん中高さ調整() {
                    var 上下padding= parseFloat(getComputedStyle(document.getElementById("mannaka")).marginTop)+parseFloat(getComputedStyle(document.getElementById("mannaka")).marginBottom);
                    var mannaka_height = window.innerHeight-document.getElementById("header").offsetHeight -上下padding;
                    document.getElementById("mannaka").style.height = mannaka_height + "px";
                    document.getElementById("三分割くん").style.height = mannaka_height-document.querySelector("footer").offsetHeight+ "px";
                    //document.getElementById("デバッグ用").textContent = 上下padding;
                }
                真ん中高さ調整();
                window.addEventListener("resize", 真ん中高さ調整);

                var canvas = document.getElementById("cnvs");
                var canvas_border = document.getElementById("canvas_border");
                var キャンバス拡大率 = 1;
                var border_width = 0;
                var border_height = 0;
                
                function キャンバスボーダー設定() {                    
                    var 三分割くん=document.getElementById("三分割くん");
                    var スクロールサイズ調整=document.getElementById("スクロールサイズ調整");

                    スクロールサイズ調整.style.width = canvas.width*キャンバス拡大率 + "px";
                    スクロールサイズ調整.style.height = canvas.height*キャンバス拡大率 + "px";
                    スクロールサイズ調整.style.borderLeftWidth = 三分割くん.offsetWidth + "px";
                    スクロールサイズ調整.style.borderRightWidth = 三分割くん.offsetWidth + "px";
                    スクロールサイズ調整.style.borderTopWidth = 三分割くん.offsetHeight + "px"; 
                    スクロールサイズ調整.style.borderBottomWidth = 三分割くん.offsetHeight + "px";
                    スクロールサイズ調整.style.borderStyle = "solid";
                    スクロールサイズ調整.style.borderColor = "rgba(0, 0, 0, 0)";//透明化
                }
                
                キャンバスボーダー設定();
                window.addEventListener("resize", キャンバスボーダー設定);

                var 真ん中分割=document.getElementById("真ん中分割");
                function キャンバススクロール中央() {
                    真ん中分割.scrollLeft = (真ん中分割.scrollWidth-真ん中分割.clientWidth) / 2;
                    真ん中分割.scrollTop = (真ん中分割.scrollHeight-真ん中分割.clientHeight) / 2;
                }
                キャンバススクロール中央();
            
                //ここからおえかき機能
                var ctx = canvas.getContext("2d");
                var drawing = false;
                var スマホチョン押し保存;
                var スポイト追従座標;
                var 撒き戻しやり直し判定=0;
                var moveカウント=0;//n本指の即時タッチだったのかを判定するためにカウンターを用意したよ
                var バケツ判定=false;//上の奴と似たようなことをするよ
                var 撒き戻し=[];
                var やりなおし=[];
                var 履歴最大数=100;//やり直し最大数はなくてもいい。はず。
                var 一時保存用キャンバス;//初期化はあとでね
                var 現在キャンバス = ctx.getImageData(0, 0, canvas.width, canvas.height);
                var 現在キャンバス_データ部分 = 現在キャンバス.data;
                var 現在キャンバス_色番号=[];
                var slider太さ = document.getElementById("slider太さ");
                var 太さ = document.getElementById("太さ");
                
                var 現在の色={r:0,g:0,b:0,a:255,layer:0,num:1,rgb:"#000000"};

                function 色選択関数を適用(親要素名称){
                    var 親要素 = document.getElementById(親要素名称);
                    var radio要素 = 親要素.querySelector(".radio");
                    var input要素 = 親要素.querySelector(".色箱_input");
                    radio要素.addEventListener("change", function (e) {
                        if(e.target.checked) {
                            選択色変更(input要素.value,親要素名称);
                        }
                    });
                    input要素.addEventListener("input", function () {
                        親要素.querySelector(".色箱_cover").style.backgroundColor = this.value; // 色を適用
                        選択色変更(this.value,親要素名称);
                        radio要素.checked = true; 
                    });
                    //ついでに背景色を初期化しておくか
                    親要素.querySelector(".色箱_cover").style.backgroundColor = input要素.value;
                }
                function 選択色変更(色文字列,親要素名称){
                    var 現在の色_文字列=色文字列;
                    現在の色_文字列=現在の色_文字列.replace("#", "");
                    現在の色.r = parseInt(現在の色_文字列.slice(0, 2), 16);
                    現在の色.g = parseInt(現在の色_文字列.slice(2, 4), 16);
                    現在の色.b = parseInt(現在の色_文字列.slice(4, 6), 16);
                    現在の色.rgb = 色文字列;
                    現在の色.layer = parseInt(親要素名称.split("_")[1], 10);
                    現在の色.num = parseInt(親要素名称.split("_")[2], 10);
                }
                色選択関数を適用("color_0_0");
                色選択関数を適用("color_0_1");
                色選択関数を適用("color_0_2");
                
                var 現在のツール="pen";
                function ペン選択関数を適用(親要素名称){
                    var 親要素 = document.getElementById(親要素名称);
                    var radio要素 = 親要素.querySelector(".tool_radio");

                    radio要素.addEventListener("change", function (e) {
                        if(e.target.checked) {
                            現在のツール=親要素名称;
                            真ん中分割.style.cursor = "url(../images/omocha/deyukaki/"+親要素名称+"16.png),default"; // カスタムカーソルを適用
                            var マウス追従 = document.getElementById("マウス追従");
                            マウス追従.style.display = "none"; // マウス追従を非表示…なくてもいいけどね
                        }
                    });
                    

                }
                ペン選択関数を適用("pen");
                ペン選択関数を適用("baketu");
                ペン選択関数を適用("supoito");
                
                function キャンバスを白で塗りつぶす() {
                    ctx.fillStyle = document.getElementById("color_pick_"+"0_0").value; // 塗りつぶしの色を0_0に設定
                    ctx.fillRect(0, 0, canvas.width, canvas.height); // キャンバス全体を塗りつぶす
                }
                キャンバスを白で塗りつぶす();
                一時保存用キャンバス=ctx.getImageData(0, 0, canvas.width, canvas.height);

                function キャンバス比較(data1,data2){
                    for (let i = 0; i < data1.length; i++) {
                        if (data1[i] !== data2[i]) {
                            return false;
                        }
                    }
                    return true;
                }
                function キャンバス最新保持(){
                    //次に履歴を残すために今を一時保存するやつ
                    一時保存用キャンバス=ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
                function 履歴残し(){
                    if(キャンバス比較(ctx.getImageData(0, 0, canvas.width, canvas.height).data,一時保存用キャンバス.data)){
                        return;//履歴が変わってないから保存しない
                    }
                    if(撒き戻し.length>=履歴最大数){//はみ出るから消すね
                        撒き戻し.shift();
                    }
                    撒き戻し.push(一時保存用キャンバス);
                    やりなおし=[];//履歴が残ったってことは次のアクションが消えるべきってわけだ！
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ
                }
                function 描き戻し(){
                    if(撒き戻し.length==0){
                        return;
                    }
                    やりなおし.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
                    ctx.putImageData(撒き戻し.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ

                }
                function やり直し(){
                    if(やりなおし.length==0){
                        //document.getElementById("デバッグ用").textContent ="ないよ";
                        return;
                    }
                    撒き戻し.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
                    ctx.putImageData(やりなおし.pop(), 0, 0);//popくんはもとの配列から削除もするので、これでOK
                    キャンバス最新保持();//次に履歴を残すために今を一時保存するやつ
                }

                var 円周マスク=[];//半径をいれるとその辺の点がわかるやつ
                var 前の直径=-1;
                function 円マスク作成(直径){
                    if(直径==前の直径){
                        return;//サボっておｋ
                    }
                    前の直径=直径;
                    円周マスク=[];
                    var 半径 =Math.floor(直径/2);
                    var 半径の二乗 = 直径*直径/4;
                    for (var i = 0; i <= 半径+10; i++) {
                        円周マスク.push([]);//空配列で初期化しとくね
                    }
                    for (var i = -半径; i <= 半径; i++) {
                        for (var j = -半径; j <= 半径; j++) {//正方形領域に対して
                            if (i * i + j * j <= 半径の二乗) {//半径に収まっていれば
                                var 距離 = Math.floor(Math.sqrt(i * i + j * j));
                                円周マスク[距離].push([i, j]);
                            }
                        }
                    }
                }

                slider太さ.addEventListener("input", function() {
                    //太さは1~10で調整しやすいようにして、10~はおおざっぱな選択にする
                    var 本質太さ=1;
                    if(this.value<=50){
                        //1~50は1~20に変換する
                        本質太さ= Math.round(this.value*20/50);
                    }else{
                        ////50~100は20~100に変換する
                        本質太さ= Math.round(this.value*80/50)-60;
                    }
                    太さ.value = 本質太さ;
                });
                function 太さからスライダー位置調整(){
                    //太さは1~10で調整しやすいようにして、10~はおおざっぱな選択にする
                    var slider位置=1;
                    if(太さ.value<=20){
                        //1~20は1~50に変換する
                        slider位置 = Math.floor(太さ.value*50/20);
                    }else{
                        //20~100は50~100に変換する
                        slider位置 = Math.floor(太さ.value*50/80)+38;
                    }
                    slider太さ.value = slider位置;
                }
                太さ.addEventListener("input", 太さからスライダー位置調整);
                太さからスライダー位置調整();//初期化。太さを保存するようにしたら使えるね！

                var 前回のマウス = {
                    x: 0,
                    y: 0
                };
                function 描き始め(e) {
                    drawing = true;

                    //現在の画像を取得しておく。moveで取得するとクソ遅いからね
                    現在キャンバス = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    現在キャンバス_データ部分 = 現在キャンバス.data;

                    var キャンバス位置 = canvas.getBoundingClientRect();
                    if (e.touches) {//これ指じゃね？
                        前回のマウス.x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        前回のマウス.x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    スマホチョン押し保存=e;
                    //描き初めで点を描くのをやめた（二本指指スクロールで暴発するので）
                    //→でもそれだと点をちょん押しで描けないじゃん
                    //→じゃあ移動じゃなかったと後から判断して後で描くか→描き終わり()                    
                }

                function 描き途中(e) {
                    if (!drawing){//そんなことあるか？
                        return;
                    }
                    if(スマホチョン押し保存){
                        スマホチョン押し保存=null;//無効にしないと、描き終わりで暴発する。
                    }

                    var キャンバス位置 = canvas.getBoundingClientRect();
                    var x, y;

                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    
                    //アンチエイリアスが嫌なので、1ピクセルずつ.fillRect()で描く
                    //前回のマウスの座標から、現在のマスウの座標までの移動距離だけループする
                    var dx = x - 前回のマウス.x;
                    var dy = y - 前回のマウス.y;
                    if(Math.abs(dx)>Math.abs(dy)){
                        var ループ回数 = Math.abs(dx)+1;
                    }else{
                        var ループ回数 = Math.abs(dy)+1;
                    }
                    //太さ決定。ここでいいのか…？
                    /*
                    //俺のペンタブ、ブラウザで筆圧検知できねえわ（笑）
                    console.log(e.pressure);
                    if(e.pressure){
                        var 圧力直径=Math.floor(太さ.value*e.pressure);//筆圧で太さを変える
                    }else{
                        var 圧力直径=太さ.value;
                    }
                    */
                    var 圧力直径=太さ.value;
                    円マスク作成(圧力直径);
                    var 円データ = [];
                    for (var i = 0; i < ループ回数; i++) {
                        var ループx = Math.floor(前回のマウス.x + (dx / ループ回数) * i);
                        var ループy = Math.floor(前回のマウス.y + (dy / ループ回数) * i);
                        円データ.push([ループx, ループy, 圧力直径]);
                    }
                    for (const [ループx, ループy, 直径] of 円データ) {
                        円を描く(ループx, ループy, 直径, true);//先に円周近くの点だけうめとこうね
                    }
                    ctx.putImageData(現在キャンバス, 0, 0);//渡すのはデータ部ではない。
                    for (const [ループx, ループy, 直径] of 円データ) {
                        円を描く(ループx, ループy, 直径, false);//中身ぬりつぶす
                    }
                    //ここで塗ることで時短。筆圧で変化するようにしたらアレになるかも？
                    ctx.fill();

                    //次回の始点を更新更新！
                    if (e.touches) {//これ指じゃね？
                        前回のマウス.x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        前回のマウス.x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        前回のマウス.y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                }


                function 円を描く(x, y, 直径, 円周だけ) {
                    //円周部分だけはしっかりと3ピクセルくらいだけ描いて、真ん中はまあ適当にって感じ
                    var 半径 =Math.floor(直径/2);
                    var 半径の二乗 = 直径*直径/4;
                    if (円周だけ) {
                        for(var r=Math.max(0, 半径-2); r<=半径; r++){//円周付近だけ点をおいてく
                            for (const [i, j] of 円周マスク[r]) {
                                if(i+x<0 || i+x>=canvas.width || j+y<0 || j+y>=canvas.height){
                                    continue;//キャンバス外は無視
                                }
                                if (i * i + j * j <= 半径の二乗) {//半径に収まっていれば
                                    現在キャンバス_データ部分[((y + j) * canvas.width + (x + i))*4] = 現在の色.r;//直接色変える
                                    現在キャンバス_データ部分[((y + j) * canvas.width + (x + i))*4+1] = 現在の色.g;//直接色変える
                                    現在キャンバス_データ部分[((y + j) * canvas.width + (x + i))*4+2] = 現在の色.b;//直接色変える
                                }
                            }
                        }
                    } else {
                        //残りはもう直接塗っちゃえばよくね？
                        ctx.fillStyle = 現在の色.rgb;
                        //ctx.fillStyle = "#FF0000";
                        ctx.beginPath();
                        ctx.arc(x+0.5, y+0.5, Math.max(0,半径-1), 0, Math.PI * 2);//ちょっとちっちゃめにしとこうぜ
                        //+0.5は、円周の表示と比べて中心位置がちょいずれてるから入れた
                        //fillはmoveの終わりでやればいいよね。                        
                    }                  
                }
                
                function 描き終わり() {
                    if(スマホチョン押し保存){//二本指タップ時にスマホチョン押し保存を破壊してる。
                        描き途中(スマホチョン押し保存);
                    }
                    drawing = false;
                    履歴残し();
                    
                }

                function バケツ(e){
                    現在キャンバス = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    現在キャンバス_データ部分 = 現在キャンバス.data;

                    var キャンバス位置 = canvas.getBoundingClientRect();
                    var x, y;

                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    //マウス位置の色を取得
                    var 塗られる色 = ctx.getImageData(x, y, 1, 1).data;
                    //塗られる色と、今から塗る色が同じだと意味ないし無限ループ入るから終了する。
                    if (塗られる色[0] === 現在の色.r && 塗られる色[1] === 現在の色.g && 塗られる色[2] === 現在の色.b) {
                        return;
                    }
                    var キュー = [[x, y]];

                    //キューが無くなるまでループして、色を判定→周囲をキューに入れる→自分を塗って削除を繰り返す
                    while (キュー.length > 0) {
                        var [キューx, キューy] = キュー.pop();//キューの先頭を取り出す
                        //キャンバス外は無視
                        if (キューx < 0 || キューx >= canvas.width || キューy < 0 || キューy >= canvas.height) {
                            continue;
                        }
                        //すでに塗られている色は無視
                        if (現在キャンバス_データ部分[(キューy * canvas.width + キューx) * 4] === 塗られる色[0] && 現在キャンバス_データ部分[(キューy * canvas.width + キューx) * 4+1] === 塗られる色[1] && 現在キャンバス_データ部分[(キューy * canvas.width + キューx) * 4+2] === 塗られる色[2]) {
                            //お前の色はバケツ対象だから、周囲をキューにぶち込む
                            キュー.push([キューx + 1, キューy]);
                            キュー.push([キューx - 1, キューy]);
                            キュー.push([キューx, キューy + 1]);
                            キュー.push([キューx, キューy - 1]);

                            //塗る
                            現在キャンバス_データ部分[(キューy * canvas.width + キューx) * 4] = 現在の色.r;//直接色変える
                            現在キャンバス_データ部分[(キューy * canvas.width + キューx) * 4 + 1] = 現在の色.g;//直接色変える  
                            現在キャンバス_データ部分[(キューy * canvas.width + キューx) * 4 + 2] = 現在の色.b;//直接色変える
                        }
                    }
                    //画像をcanvasへ反映
                    ctx.putImageData(現在キャンバス, 0, 0);//渡すのはデータ部ではない。
                    //document.getElementById("デバッグ用").textContent ="終";
                    履歴残し();
                }

                function スポイトの色表示(x,y){
                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.left = x+10+"px";
                    マウス追従.style.top =  y+10+"px";

                    var canv_x, canv_y;
                    var キャンバス位置 = canvas.getBoundingClientRect();
                    canv_x = Math.floor((x - キャンバス位置.left )/キャンバス拡大率);
                    canv_y = Math.floor((y - キャンバス位置.top )/キャンバス拡大率);
                    
                    マウス追従.style.display = "block"; // マウス追従を表示

                    //色縫っていく
                    var そこの色 = ctx.getImageData(canv_x, canv_y, 1, 1).data;
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    マウス追従.style.backgroundColor = 色文字列; // 色を適用
                    
                }

                function スポイト端っこ表示(e){
                    var キャンバス位置 = canvas.getBoundingClientRect();
                    var x, y;
                    
                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }

                    //範囲外なら無視
                    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                        return;
                    }

                    var マウス追従 = document.getElementById("マウス追従");
                    //ここでは画面の左下に表示
                    マウス追従.style.left = 0 + "px";
                    マウス追従.style.top =真ん中分割.clientHeight+"px";

                    マウス追従.style.display = "block"; // マウス追従を表示
                    
                    //色縫っていく
                    var そこの色 = ctx.getImageData(x,y, 1, 1).data;
                    var 色文字列 = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    マウス追従.style.backgroundColor = 色文字列; // 色を適用

                }

                function スポイト反映(e){
                    var キャンバス位置 = canvas.getBoundingClientRect();
                    var x, y;
                    
                    if (e.touches) {//これ指じゃね？
                        x = Math.floor((e.touches[0].clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.touches[0].clientY - キャンバス位置.top )/キャンバス拡大率);
                    } else {//マウスだわ
                        x = Math.floor((e.clientX - キャンバス位置.left )/キャンバス拡大率);
                        y = Math.floor((e.clientY - キャンバス位置.top )/キャンバス拡大率);
                    }
                    
                    //範囲外なら無視
                    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                        return;
                    }

                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.display = "none"; // マウス追従を非表示

                    現在のツール="pen";//スポイトの後はペンに戻す
                    真ん中分割.style.cursor = "url(../images/omocha/deyukaki/pen16.png),default"; // カスタムカーソルを適用
                    //radioもペンにする
                    var radio_div要素 = document.getElementById("pen");
                    var radio要素 = radio_div要素.querySelector(".tool_radio");
                    radio要素.checked = true; // ペンを選択

                    //マウス位置の色を取得
                    var そこの色 = ctx.getImageData(x, y, 1, 1).data;
                    //今選択されているradioの色をこいつに変える
                    var radio_div要素 = document.getElementById("color_" + 現在の色.layer + "_" + 現在の色.num);
                    var input要素 = radio_div要素.querySelector(".色箱_input");
                    input要素.value = "#" + そこの色[0].toString(16).padStart(2, "0") + そこの色[1].toString(16).padStart(2, "0") + そこの色[2].toString(16).padStart(2, "0");
                    選択色変更(input要素.value,"color_" + 現在の色.layer + "_" + 現在の色.num);
                    radio_div要素.querySelector(".色箱_cover").style.backgroundColor = input要素.value;
                }
                function スポイト非表示(){
                    var マウス追従 = document.getElementById("マウス追従");
                    マウス追従.style.display = "none"; // マウス追従を非表示
                }

                var 動かし前指間距離 = 0;
                var 前回指間座標 = [0, 0];

                function 指間距離計算(touches) {
                    var dx = touches[0].clientX - touches[1].clientX;
                    var dy = touches[0].clientY - touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }

                function 指間座標計算(e) {
                    return [(e.touches[0].clientX + e.touches[1].clientX) / 2, (e.touches[0].clientY + e.touches[1].clientY) / 2];
                }
                真ん中分割.addEventListener("pointerdown", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    // 右クリックは無視
                    if (e.button === 2) {
                        return;
                    }
                    // スクロールバー上でのクリックを無視
                    if (e.clientX > 真ん中分割.clientWidth || e.clientY > 真ん中分割.clientHeight) {
                        return;
                    }
                    真ん中分割.setPointerCapture(e.pointerId);//ポインターを追跡する。どっか行ってもキャンセルを監視できる
                    if(現在のツール==="pen"){
                        描き始め(e);
                    }else if(現在のツール==="baketu"){
                        バケツ(e);
                    }else if(現在のツール==="supoito"){
                        スポイト反映(e);
                    }
                });
                真ん中分割.addEventListener("pointermove", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    if(現在のツール==="pen"){
                        描き途中(e);
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                    }
                    
                });
                canvas.addEventListener("pointermove", function(e){
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    if(現在のツール==="pen"){

                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                        スポイトの色表示(e.x, e.y);
                    }

                });
                canvas.addEventListener("pointerleave", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    if(現在のツール==="pen"){
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){
                        スポイト非表示();
                    }
                });

                真ん中分割.addEventListener("pointerup", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    if(現在のツール==="pen"){
                        描き終わり();
                    }else if(現在のツール==="baketu"){
                        
                    }else if(現在のツール==="supoito"){

                    }
                    
                });
                真ん中分割.addEventListener("pointercancel", function(e) {
                    //スマホは下のほうで実装してるからここでは無視。
                    if (e.pointerType==="touch"){
                        return;
                    }
                    if(現在のツール==="pen"){
                        描き終わり();
                    }else if(現在のツール==="baketu"){

                    }else if(現在のツール==="supoito"){

                    }
                });

                真ん中分割.addEventListener("wheel", function(e) {
                    //スクロールバーの上でのホイール操作を無視
                    console.log(e.clientX, e.clientY, 真ん中分割.clientWidth, 真ん中分割.clientHeight);
                    if (e.clientX < 真ん中分割.clientWidth && e.clientY < 真ん中分割.clientHeight) {
                        e.preventDefault();
                        キャンバス拡大(e.deltaY > 0 ? -0.1 : 0.1, e.clientX, e.clientY);
                    }else if(e.clientY > 真ん中分割.clientHeight){//なんか、ここバグってるんだけど意味わかんないんだよね
                        e.preventDefault();
                        //上下スクロールでキャンバスの横向きの位置を調整する.カクカクするけど、いいよね！
                        真ん中分割.scrollLeft += e.deltaY/2;
                    }
                }); 

                function キャンバス拡大(拡大率, 中心x, 中心y){                    
                    var キャンバス位置 = canvas.getBoundingClientRect();
                    var 変動前位置x=(中心x - キャンバス位置.left )/キャンバス拡大率;
                    var 変動前位置y=(中心y - キャンバス位置.top )/キャンバス拡大率;

                    var 前拡大率 = キャンバス拡大率;
                    キャンバス拡大率 += 拡大率;
                    キャンバス拡大率 = Math.max(0.1, キャンバス拡大率);
                    キャンバス拡大率 = Math.min(10, キャンバス拡大率);

                    //キャンバスの位置を調整する
                    真ん中分割.scrollLeft +=  (中心x - キャンバス位置.left )*(キャンバス拡大率/前拡大率-1);
                    真ん中分割.scrollTop += (中心y - キャンバス位置.top )*(キャンバス拡大率/前拡大率-1);
                 

                    //キャンバスを拡大（ズラす→拡大の順番じゃないとどうやら非同期処理で計算狂うっぽい）
                    canvas.style.transform = "scale("+キャンバス拡大率+")";
                    キャンバスボーダー設定();
                    //ま、それでもちょっとずれてるけどね

                }

                真ん中分割.addEventListener("touchstart", function(e) {
                    if (e.touches.length === 2) {
                        動かし前指間距離 = 指間距離計算(e.touches);
                        e.preventDefault();
                        前回指間座標 = 指間座標計算(e);
                        撒き戻しやり直し判定=2;
                        moveカウント=0;
                    } else if (e.touches.length ===3) {
                        e.preventDefault();
                        撒き戻しやり直し判定=3;
                        moveカウント=0;
                    } else if (e.touches.length > 3) {
                        // 指が4本以上の場合は反応しない
                    }else{
                        e.preventDefault();
                        if(現在のツール==="pen"){
                            描き始め(e);
                        }else if(現在のツール==="baketu"){
                            moveカウント=0;
                            スマホチョン押し保存=e;//ここで保存しないと、指を離したときにはどっかいってる。
                        }else if(現在のツール==="supoito"){
                            スポイト追従座標=e;
                        }
                    }
                });

                真ん中分割.addEventListener("touchmove", function(e) {
                    if(moveカウント>10){
                        撒き戻しやり直し判定=0;//まあちょっと動いたし無効化…って判定シビアじゃない？
                        スマホチョン押し保存=null;//無効にしないと、バケツで暴発する。
                        document.getElementById("デバッグ用").textContent ="poe";
                    }else{
                        moveカウント+=1;
                        
                        if (e.touches.length === 2 & 撒き戻しやり直し判定!=3) {
                            撒き戻しやり直し判定=2;
                            スマホチョン押し保存=null;//なんか違うよね、君
                        }else if (e.touches.length === 3) {
                            撒き戻しやり直し判定=3;
                            スマホチョン押し保存=null;//なんか違うよね、君
                        }
                        document.getElementById("デバッグ用").textContent =撒き戻しやり直し判定;
                        return;//動いてないとする。1pxくらい動くと反応するかな
                    }
                    
                    if (e.touches.length === 2) {
                        drawing=false;
                        スマホチョン押し保存=null;//無効にしないと、描き終わりで暴発する。描き途中()の中でdrawing殺してるんだからわざわざやらんでもいいんだけどね
                        スポイト追従座標=null;
                        e.preventDefault();
                        //拡大操作
                        var 指間距離 = 指間距離計算(e.touches);
                        var 変動率 = 指間距離 / 動かし前指間距離;
                        動かし前指間距離 = 指間距離;
                        キャンバス拡大((変動率-1)*キャンバス拡大率,指間座標計算(e)[0] , 指間座標計算(e)[1]);
                        //移動操作
                        //合計移動量が少ないなら移動しない…は実装せんでええか
                        真ん中分割.scrollLeft += (前回指間座標[0] - 指間座標計算(e)[0]);//拡大してても影響ないよ～～ん
                        真ん中分割.scrollTop += (前回指間座標[1] - 指間座標計算(e)[1]);
                        前回指間座標 = 指間座標計算(e);
                    } else if (e.touches.length ===3) {
                        drawing=false;
                        スマホチョン押し保存=null;//無効にしないと、描き終わりで暴発する。描き途中()の中でdrawing殺してるんだからわざわざやらんでもいいんだけどね
                        スポイト追従座標=null;
                        e.preventDefault();
                    } else if (e.touches.length > 3) {
                        // 指が4本以上の場合は反応しない
                    }else{
                        e.preventDefault();//画面スクロールとか無効にしちゃうよ～ん
                        if(現在のツール==="pen"){
                            描き途中(e);
                            
                        }else if(現在のツール==="baketu"){
                            //判定はこの関数の上のほうでやってるので。
                        }else if(現在のツール==="supoito"){
                            スポイト追従座標=e;
                            スポイト端っこ表示(スポイト追従座標);
                        }
                    }
                });

                真ん中分割.addEventListener("touchend", function(e) {
                    e.preventDefault();//画面スクロールとか無効にしちゃうよ～ん
                    if(現在のツール==="pen"){
                        描き終わり();
                    }else if(現在のツール==="baketu"){
                        if(スマホチョン押し保存){
                            バケツ(スマホチョン押し保存);
                            スマホチョン押し保存=null;
                        }
                    }else if(現在のツール==="supoito"){
                        if(スポイト追従座標){
                            スポイト反映(スポイト追従座標);
                        }
                        
                    }
                    

                    if(撒き戻しやり直し判定===2){
                        描き戻し();
                    }else if(撒き戻しやり直し判定===3){
                        やり直し();
                    }
                    撒き戻しやり直し判定=0;
                });

                document.addEventListener("keydown", function(e) {
                    if (e.ctrlKey && e.key === "z") {
                        e.preventDefault(); // デフォルトの動作を無効化
                        描き戻し();
                    } else if (e.ctrlKey && e.key === "y") {
                        e.preventDefault(); // デフォルトの動作を無効化
                        やり直し();
                    }
                });

                document.getElementById("コピーボタン").addEventListener("click", function() {
                    //テキストもコピーできるかな～て思ったけど、できるけどできないみたい。
                    canvas.toBlob(function(blob) {
                        const item = new ClipboardItem({ "image/png": blob });//HTTPSかhttp://127.0.0.1/じゃないとうごかない、らしいね。
                        navigator.clipboard.write([item]).then(function() {
                        }).catch(function(err) {
                            console.error("クリップボードへのコピーに失敗しました:", err);
                        });
                    });
                });

                document.getElementById("保存").addEventListener("click", function() {
                    var link = document.createElement('a');
                    link.href = canvas.toDataURL("image/png");
                    const date = new Date();
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');  // 月は0から始まるので+1
                    const day = String(date.getDate()).padStart(2, '0');
                    const hours = String(date.getHours()).padStart(2, '0');
                    const minutes = String(date.getMinutes()).padStart(2, '0');
                    const seconds = String(date.getSeconds()).padStart(2, '0');
                    link.download = year+""+month+""+day+"_"+hours+""+minutes+""+seconds+"_deyukaki.png";//ファイル名決めてる
                    link.click();//強制クリック
                });

                document.getElementById("白紙").addEventListener("click", function() {
                    キャンバスを白で塗りつぶす();
                    履歴残し();
                    
                });

                //ページ下部のツイートボタンを上書き
                document.getElementById("foot_tweet_a").href=URL_tweet_text="https://twitter.com/intent/tweet?hashtags=deyukaki";           

            }
        </script>
    </head>
    <body>
        <div id="top"></div>
        <header id="header">
            <button onclick="html_link_btn()" id="html_link_btn"></button>
            <nav id="html_link_nav">
                <ul id="html_link_ul"></ul>
            </nav>
            <a href="../index.html">
                <img id="go_home" src="../images/site/omotyabako_deka.png" alt="トップページへ" height="1px"><!--ここで高さを入れておかないと、クソでかい画像が一瞬読み込まれてボタンの大きさが暴走する-->
            </a>
            <h1 id="title_h1">
                JUN汁ｗおもちゃばこ。
            </h1>
        </header>
        <div id="mannaka">
            <div id="三分割くん">
                <div id="左分割" class="浮かせる">
                    <div id="左最小化領域">
                        <div id="color_0" class="color_行">

                            <div class="radio_div" id="color_0_0">
                                <input type="radio" class="radio" id="color_radio_0_0" name="color">
                                <div class="色箱" id="color_div_0_0">
                                    <input class="色箱_input" type="color" id="color_pick_0_0" value="#ffffff">
                                    <div class="色箱_cover"></div>
                                </div>
                            </div>

                            <div class="radio_div" id="color_0_1">
                                <input type="radio" class="radio" id="color_radio_0_1" name="color" checked>
                                <div class="色箱" id="color_div_0_1">
                                    <input class="色箱_input" type="color" id="color_pick_0_1" value="#000000">
                                    <div class="色箱_cover"></div>
                                </div>
                            </div>

                            <div class="radio_div" id="color_0_2">
                                <input type="radio" class="radio" id="color_radio_0_2" name="color">
                                <div class="色箱" id="color_div_0_2">
                                    <input class="色箱_input" type="color" id="color_pick_0_2" value="#aaffaa">
                                    <div class="色箱_cover"></div>
                                </div>
                            </div>
                            
                        </div>
                        <div id="ツール系">
                            <div id="筆の太さ">
                                <div>
                                    <label for="太さ">太さ：</label>
                                    <input type="number" id="太さ" min="1" max="100" value="5">
                                </div>
                                <input type="range" id="slider太さ" min="1" max="100" value="12" step="1">
                                <!--デフォルトは12なんだけど計算すると5pxになる。まあここは初期化してるのでなんでもいいんですが…-->
                            </div>
                            <div id="ツール選択">
                                <label id="pen">
                                    <input type="radio" name="tool" class="tool_radio" id="ペン" value="pen" checked>
                                    <span class="ペンボタン" id="ペン_ボタン"></span>
                                </label>
                                <label id="baketu">
                                    <input type="radio" name="tool" class="tool_radio" id="バケツ" value="bucket">
                                    <span class="ペンボタン" id="バケツ_ボタン"></span>
                                </label>
                                <label id="supoito">
                                    <input type="radio" name="tool" class="tool_radio" id="スポイト" value="supoito">
                                    <span class="ペンボタン" id="スポイト_ボタン"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <button id="左最小化"><</button>
                    <div id="デバッグ用">test</div>
                </div>

                <div id="真ん中分割">
                    <div id="スクロールサイズ調整">         
                        <canvas id="cnvs" height="450px" width="600px"><!--styleのheigthは見た目の大きさを変えているにすぎない。表示領域はcssじゃない。-->
                        </canvas>               
                    </div>
                </div>
                
                
                <div id="右分割"class="浮かせる">
                    <button id="右最小化">></button>
                    <div id="右最小化領域">
                        <button id="コピーボタン" class="保存系ボタン">コピー</button>
                        <button id="保存" class="保存系ボタン">保存</button>
                        <button id="白紙" class="保存系ボタン">左色で埋める</button>
                    </div>

                </div>
            </div>

            <footer>
                <ul id="footul">
                    <li id="foot_tweet_li">
                        <a href=""  target="_blank" rel="noopener noreferrer" id="foot_tweet_a"><!--onload_functions()でhrefを書き込んでるで！-->
                            <img src="../images/site/twitterbutton.gif" alt="ツイートボタン" id="tweet_img">
                        </a>
                    </li>
                    <li>
                        <a href="#top" id="totop"> 
                            ページ上部に移動
                        </a>
                    </li>
                </ul>
            </footer>
            <div id="マウス追従" calss="マウス追従"></div>
        </div>
    </body>
</html>
